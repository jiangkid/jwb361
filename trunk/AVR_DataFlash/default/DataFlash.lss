
DataFlash.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800100  00002aa0  00002b34  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002aa0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001a  0080017a  0080017a  00002bae  2**0
                  ALLOC
  3 .debug_aranges 00000060  00000000  00000000  00002bae  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000004a5  00000000  00000000  00002c0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000e57  00000000  00000000  000030b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003ff  00000000  00000000  00003f0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001082  00000000  00000000  00004309  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002b0  00000000  00000000  0000538c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000679  00000000  00000000  0000563c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 9f 00 	jmp	0x13e	; 0x13e <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e0 ea       	ldi	r30, 0xA0	; 160
      a0:	fa e2       	ldi	r31, 0x2A	; 42
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	aa 37       	cpi	r26, 0x7A	; 122
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	11 e0       	ldi	r17, 0x01	; 1
      b4:	aa e7       	ldi	r26, 0x7A	; 122
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a4 39       	cpi	r26, 0x94	; 148
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 7d 01 	call	0x2fa	; 0x2fa <main>
      c6:	0c 94 4e 15 	jmp	0x2a9c	; 0x2a9c <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <io_init>:
//函数声明
void io_init(void);


/*IO口初始化函数*/
void io_init(void) {
      ce:	df 93       	push	r29
      d0:	cf 93       	push	r28
      d2:	cd b7       	in	r28, 0x3d	; 61
      d4:	de b7       	in	r29, 0x3e	; 62

	DDRA = 0x00;										
      d6:	ea e3       	ldi	r30, 0x3A	; 58
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	10 82       	st	Z, r1
	PORTA = 0xFF;										
      dc:	eb e3       	ldi	r30, 0x3B	; 59
      de:	f0 e0       	ldi	r31, 0x00	; 0
      e0:	8f ef       	ldi	r24, 0xFF	; 255
      e2:	80 83       	st	Z, r24
	DDRB = 0x00;										
      e4:	e7 e3       	ldi	r30, 0x37	; 55
      e6:	f0 e0       	ldi	r31, 0x00	; 0
      e8:	10 82       	st	Z, r1
	PORTB = 0xFF;										
      ea:	e8 e3       	ldi	r30, 0x38	; 56
      ec:	f0 e0       	ldi	r31, 0x00	; 0
      ee:	8f ef       	ldi	r24, 0xFF	; 255
      f0:	80 83       	st	Z, r24
	DDRC = 0x00;										/*不用的IO口建议设置为输入带上拉*/
      f2:	e4 e3       	ldi	r30, 0x34	; 52
      f4:	f0 e0       	ldi	r31, 0x00	; 0
      f6:	10 82       	st	Z, r1
	PORTC = 0xFF;
      f8:	e5 e3       	ldi	r30, 0x35	; 53
      fa:	f0 e0       	ldi	r31, 0x00	; 0
      fc:	8f ef       	ldi	r24, 0xFF	; 255
      fe:	80 83       	st	Z, r24
	DDRD = 0x00;
     100:	e1 e3       	ldi	r30, 0x31	; 49
     102:	f0 e0       	ldi	r31, 0x00	; 0
     104:	10 82       	st	Z, r1
	PORTD = 0xFF;
     106:	e2 e3       	ldi	r30, 0x32	; 50
     108:	f0 e0       	ldi	r31, 0x00	; 0
     10a:	8f ef       	ldi	r24, 0xFF	; 255
     10c:	80 83       	st	Z, r24
	DDRE = 0x00;
     10e:	e2 e2       	ldi	r30, 0x22	; 34
     110:	f0 e0       	ldi	r31, 0x00	; 0
     112:	10 82       	st	Z, r1
	PORTE = 0xFF;
     114:	e3 e2       	ldi	r30, 0x23	; 35
     116:	f0 e0       	ldi	r31, 0x00	; 0
     118:	8f ef       	ldi	r24, 0xFF	; 255
     11a:	80 83       	st	Z, r24
	DDRF = 0x00;
     11c:	e1 e6       	ldi	r30, 0x61	; 97
     11e:	f0 e0       	ldi	r31, 0x00	; 0
     120:	10 82       	st	Z, r1
	PORTF = 0xFF;
     122:	e2 e6       	ldi	r30, 0x62	; 98
     124:	f0 e0       	ldi	r31, 0x00	; 0
     126:	8f ef       	ldi	r24, 0xFF	; 255
     128:	80 83       	st	Z, r24
	DDRG = 0x00;
     12a:	e4 e6       	ldi	r30, 0x64	; 100
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	10 82       	st	Z, r1
	PORTG = 0xFF;
     130:	e5 e6       	ldi	r30, 0x65	; 101
     132:	f0 e0       	ldi	r31, 0x00	; 0
     134:	8f ef       	ldi	r24, 0xFF	; 255
     136:	80 83       	st	Z, r24
}
     138:	cf 91       	pop	r28
     13a:	df 91       	pop	r29
     13c:	08 95       	ret

0000013e <__vector_18>:

struct S_UARTFrame recvFrame;
struct S_UARTFrame sendFrame;
//接收中断，串口0
SIGNAL(SIG_UART0_RECV)
{
     13e:	1f 92       	push	r1
     140:	0f 92       	push	r0
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	0f 92       	push	r0
     146:	00 90 5b 00 	lds	r0, 0x005B
     14a:	0f 92       	push	r0
     14c:	11 24       	eor	r1, r1
     14e:	2f 93       	push	r18
     150:	3f 93       	push	r19
     152:	4f 93       	push	r20
     154:	5f 93       	push	r21
     156:	6f 93       	push	r22
     158:	7f 93       	push	r23
     15a:	8f 93       	push	r24
     15c:	9f 93       	push	r25
     15e:	af 93       	push	r26
     160:	bf 93       	push	r27
     162:	ef 93       	push	r30
     164:	ff 93       	push	r31
     166:	df 93       	push	r29
     168:	cf 93       	push	r28
     16a:	00 d0       	rcall	.+0      	; 0x16c <__vector_18+0x2e>
     16c:	cd b7       	in	r28, 0x3d	; 61
     16e:	de b7       	in	r29, 0x3e	; 62
	cData = UDR0;
     170:	ec e2       	ldi	r30, 0x2C	; 44
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	80 81       	ld	r24, Z
     176:	80 93 7b 01 	sts	0x017B, r24
	switch(r_status)
     17a:	80 91 7a 01 	lds	r24, 0x017A
     17e:	28 2f       	mov	r18, r24
     180:	30 e0       	ldi	r19, 0x00	; 0
     182:	3a 83       	std	Y+2, r19	; 0x02
     184:	29 83       	std	Y+1, r18	; 0x01
     186:	89 81       	ldd	r24, Y+1	; 0x01
     188:	9a 81       	ldd	r25, Y+2	; 0x02
     18a:	82 30       	cpi	r24, 0x02	; 2
     18c:	91 05       	cpc	r25, r1
     18e:	59 f1       	breq	.+86     	; 0x1e6 <__vector_18+0xa8>
     190:	29 81       	ldd	r18, Y+1	; 0x01
     192:	3a 81       	ldd	r19, Y+2	; 0x02
     194:	23 30       	cpi	r18, 0x03	; 3
     196:	31 05       	cpc	r19, r1
     198:	34 f4       	brge	.+12     	; 0x1a6 <__vector_18+0x68>
     19a:	89 81       	ldd	r24, Y+1	; 0x01
     19c:	9a 81       	ldd	r25, Y+2	; 0x02
     19e:	81 30       	cpi	r24, 0x01	; 1
     1a0:	91 05       	cpc	r25, r1
     1a2:	69 f0       	breq	.+26     	; 0x1be <__vector_18+0x80>
     1a4:	92 c0       	rjmp	.+292    	; 0x2ca <__vector_18+0x18c>
     1a6:	29 81       	ldd	r18, Y+1	; 0x01
     1a8:	3a 81       	ldd	r19, Y+2	; 0x02
     1aa:	23 30       	cpi	r18, 0x03	; 3
     1ac:	31 05       	cpc	r19, r1
     1ae:	79 f0       	breq	.+30     	; 0x1ce <__vector_18+0x90>
     1b0:	89 81       	ldd	r24, Y+1	; 0x01
     1b2:	9a 81       	ldd	r25, Y+2	; 0x02
     1b4:	84 30       	cpi	r24, 0x04	; 4
     1b6:	91 05       	cpc	r25, r1
     1b8:	09 f4       	brne	.+2      	; 0x1bc <__vector_18+0x7e>
     1ba:	63 c0       	rjmp	.+198    	; 0x282 <__vector_18+0x144>
     1bc:	86 c0       	rjmp	.+268    	; 0x2ca <__vector_18+0x18c>
	{
		case R_CMD:
			recvFrame.cmd = cData;
     1be:	80 91 7b 01 	lds	r24, 0x017B
     1c2:	80 93 80 01 	sts	0x0180, r24
			r_status = R_LEN_L;
     1c6:	83 e0       	ldi	r24, 0x03	; 3
     1c8:	80 93 7a 01 	sts	0x017A, r24
     1cc:	7e c0       	rjmp	.+252    	; 0x2ca <__vector_18+0x18c>
			break;
		case R_LEN_L:
			tempData = cData;
     1ce:	80 91 7b 01 	lds	r24, 0x017B
     1d2:	88 2f       	mov	r24, r24
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	90 93 7f 01 	sts	0x017F, r25
     1da:	80 93 7e 01 	sts	0x017E, r24
			r_status = R_LEN_H;
     1de:	82 e0       	ldi	r24, 0x02	; 2
     1e0:	80 93 7a 01 	sts	0x017A, r24
     1e4:	72 c0       	rjmp	.+228    	; 0x2ca <__vector_18+0x18c>
			break;
		case R_LEN_H:
			recvFrame.dataLen = cData;
     1e6:	80 91 7b 01 	lds	r24, 0x017B
     1ea:	88 2f       	mov	r24, r24
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	90 93 82 01 	sts	0x0182, r25
     1f2:	80 93 81 01 	sts	0x0181, r24
			recvFrame.dataLen <<= 8;
     1f6:	80 91 81 01 	lds	r24, 0x0181
     1fa:	90 91 82 01 	lds	r25, 0x0182
     1fe:	98 2f       	mov	r25, r24
     200:	88 27       	eor	r24, r24
     202:	90 93 82 01 	sts	0x0182, r25
     206:	80 93 81 01 	sts	0x0181, r24
			recvFrame.dataLen |= tempData;
     20a:	20 91 81 01 	lds	r18, 0x0181
     20e:	30 91 82 01 	lds	r19, 0x0182
     212:	80 91 7e 01 	lds	r24, 0x017E
     216:	90 91 7f 01 	lds	r25, 0x017F
     21a:	82 2b       	or	r24, r18
     21c:	93 2b       	or	r25, r19
     21e:	90 93 82 01 	sts	0x0182, r25
     222:	80 93 81 01 	sts	0x0181, r24
			tempData = 0;
     226:	10 92 7f 01 	sts	0x017F, r1
     22a:	10 92 7e 01 	sts	0x017E, r1
			currentLen = 0;
     22e:	10 92 7d 01 	sts	0x017D, r1
     232:	10 92 7c 01 	sts	0x017C, r1
			recvFrame.data = malloc(recvFrame.dataLen);
     236:	80 91 81 01 	lds	r24, 0x0181
     23a:	90 91 82 01 	lds	r25, 0x0182
     23e:	0e 94 a1 13 	call	0x2742	; 0x2742 <malloc>
     242:	90 93 84 01 	sts	0x0184, r25
     246:	80 93 83 01 	sts	0x0183, r24
			if(recvFrame.data != 0)
     24a:	80 91 83 01 	lds	r24, 0x0183
     24e:	90 91 84 01 	lds	r25, 0x0184
     252:	00 97       	sbiw	r24, 0x00	; 0
     254:	89 f0       	breq	.+34     	; 0x278 <__vector_18+0x13a>
			{
				memset(recvFrame.data, 0, recvFrame.dataLen);
     256:	80 91 83 01 	lds	r24, 0x0183
     25a:	90 91 84 01 	lds	r25, 0x0184
     25e:	20 91 81 01 	lds	r18, 0x0181
     262:	30 91 82 01 	lds	r19, 0x0182
     266:	60 e0       	ldi	r22, 0x00	; 0
     268:	70 e0       	ldi	r23, 0x00	; 0
     26a:	a9 01       	movw	r20, r18
     26c:	0e 94 a6 14 	call	0x294c	; 0x294c <memset>
				r_status = R_CONTENT;
     270:	84 e0       	ldi	r24, 0x04	; 4
     272:	80 93 7a 01 	sts	0x017A, r24
     276:	29 c0       	rjmp	.+82     	; 0x2ca <__vector_18+0x18c>
			}
			else
				printf("malloc error!\n");
     278:	80 e0       	ldi	r24, 0x00	; 0
     27a:	91 e0       	ldi	r25, 0x01	; 1
     27c:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <puts>
     280:	24 c0       	rjmp	.+72     	; 0x2ca <__vector_18+0x18c>
			
			break;
		case R_CONTENT:
			*(recvFrame.data + currentLen) = cData;
     282:	20 91 83 01 	lds	r18, 0x0183
     286:	30 91 84 01 	lds	r19, 0x0184
     28a:	80 91 7c 01 	lds	r24, 0x017C
     28e:	90 91 7d 01 	lds	r25, 0x017D
     292:	f9 01       	movw	r30, r18
     294:	e8 0f       	add	r30, r24
     296:	f9 1f       	adc	r31, r25
     298:	80 91 7b 01 	lds	r24, 0x017B
     29c:	80 83       	st	Z, r24
			currentLen++;
     29e:	80 91 7c 01 	lds	r24, 0x017C
     2a2:	90 91 7d 01 	lds	r25, 0x017D
     2a6:	01 96       	adiw	r24, 0x01	; 1
     2a8:	90 93 7d 01 	sts	0x017D, r25
     2ac:	80 93 7c 01 	sts	0x017C, r24
			if (currentLen == recvFrame.dataLen)//接收完成
     2b0:	20 91 81 01 	lds	r18, 0x0181
     2b4:	30 91 82 01 	lds	r19, 0x0182
     2b8:	80 91 7c 01 	lds	r24, 0x017C
     2bc:	90 91 7d 01 	lds	r25, 0x017D
     2c0:	28 17       	cp	r18, r24
     2c2:	39 07       	cpc	r19, r25
     2c4:	11 f4       	brne	.+4      	; 0x2ca <__vector_18+0x18c>
			{
				r_status = R_NULL;
     2c6:	10 92 7a 01 	sts	0x017A, r1
			}
			break;
		default:
			break;
	}
}
     2ca:	0f 90       	pop	r0
     2cc:	0f 90       	pop	r0
     2ce:	cf 91       	pop	r28
     2d0:	df 91       	pop	r29
     2d2:	ff 91       	pop	r31
     2d4:	ef 91       	pop	r30
     2d6:	bf 91       	pop	r27
     2d8:	af 91       	pop	r26
     2da:	9f 91       	pop	r25
     2dc:	8f 91       	pop	r24
     2de:	7f 91       	pop	r23
     2e0:	6f 91       	pop	r22
     2e2:	5f 91       	pop	r21
     2e4:	4f 91       	pop	r20
     2e6:	3f 91       	pop	r19
     2e8:	2f 91       	pop	r18
     2ea:	0f 90       	pop	r0
     2ec:	00 92 5b 00 	sts	0x005B, r0
     2f0:	0f 90       	pop	r0
     2f2:	0f be       	out	0x3f, r0	; 63
     2f4:	0f 90       	pop	r0
     2f6:	1f 90       	pop	r1
     2f8:	18 95       	reti

000002fa <main>:

/***************主函数****************************/

int main(void)
{
     2fa:	0f 93       	push	r16
     2fc:	1f 93       	push	r17
     2fe:	df 93       	push	r29
     300:	cf 93       	push	r28
     302:	cd b7       	in	r28, 0x3d	; 61
     304:	de b7       	in	r29, 0x3e	; 62
     306:	c0 51       	subi	r28, 0x10	; 16
     308:	d1 40       	sbci	r29, 0x01	; 1
     30a:	0f b6       	in	r0, 0x3f	; 63
     30c:	f8 94       	cli
     30e:	de bf       	out	0x3e, r29	; 62
     310:	0f be       	out	0x3f, r0	; 63
     312:	cd bf       	out	0x3d, r28	; 61
	unsigned char readBuffer[264] ={0};
     314:	88 e0       	ldi	r24, 0x08	; 8
     316:	91 e0       	ldi	r25, 0x01	; 1
     318:	fe 01       	movw	r30, r28
     31a:	37 96       	adiw	r30, 0x07	; 7
     31c:	df 01       	movw	r26, r30
     31e:	9c 01       	movw	r18, r24
     320:	1d 92       	st	X+, r1
     322:	21 50       	subi	r18, 0x01	; 1
     324:	30 40       	sbci	r19, 0x00	; 0
     326:	e1 f7       	brne	.-8      	; 0x320 <main+0x26>
	unsigned int page = 0, dataNum = 0;
     328:	1e 82       	std	Y+6, r1	; 0x06
     32a:	1d 82       	std	Y+5, r1	; 0x05
     32c:	1c 82       	std	Y+4, r1	; 0x04
     32e:	1b 82       	std	Y+3, r1	; 0x03
	unsigned char *pData = 0;
     330:	1a 82       	std	Y+2, r1	; 0x02
     332:	19 82       	std	Y+1, r1	; 0x01
	recvFrame.cmd = CMD_NULL;
     334:	10 92 80 01 	sts	0x0180, r1
	recvFrame.dataLen = 0;
     338:	10 92 82 01 	sts	0x0182, r1
     33c:	10 92 81 01 	sts	0x0181, r1
	recvFrame.data = 0;
     340:	10 92 84 01 	sts	0x0184, r1
     344:	10 92 83 01 	sts	0x0183, r1
	//io_init();
	uart_init();
     348:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <uart_init>
	SPI_Init();
     34c:	0e 94 3a 04 	call	0x874	; 0x874 <SPI_Init>
	sei();				//总中断标志置位
     350:	78 94       	sei
	printf("Init OK!\n");
     352:	8e e0       	ldi	r24, 0x0E	; 14
     354:	91 e0       	ldi	r25, 0x01	; 1
     356:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <puts>
	Test_Flash_Buffer_to_Buffer();			//ok
	Test_Flash_Page_to_Page();				//ok	
	Test_Flash_Buffer_Page_to_Page();			//ok
	Test_Flash_Buffer_Page_to_Page_Buffer();	//ok
*/
	r_status = R_CMD;
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	80 93 7a 01 	sts	0x017A, r24
	while(1)
	{
		switch(recvFrame.cmd)
     360:	80 91 80 01 	lds	r24, 0x0180
     364:	a8 2f       	mov	r26, r24
     366:	b0 e0       	ldi	r27, 0x00	; 0
     368:	c1 5f       	subi	r28, 0xF1	; 241
     36a:	de 4f       	sbci	r29, 0xFE	; 254
     36c:	b9 83       	std	Y+1, r27	; 0x01
     36e:	a8 83       	st	Y, r26
     370:	cf 50       	subi	r28, 0x0F	; 15
     372:	d1 40       	sbci	r29, 0x01	; 1
     374:	c1 5f       	subi	r28, 0xF1	; 241
     376:	de 4f       	sbci	r29, 0xFE	; 254
     378:	28 81       	ld	r18, Y
     37a:	39 81       	ldd	r19, Y+1	; 0x01
     37c:	cf 50       	subi	r28, 0x0F	; 15
     37e:	d1 40       	sbci	r29, 0x01	; 1
     380:	21 30       	cpi	r18, 0x01	; 1
     382:	31 05       	cpc	r19, r1
     384:	59 f0       	breq	.+22     	; 0x39c <main+0xa2>
     386:	c1 5f       	subi	r28, 0xF1	; 241
     388:	de 4f       	sbci	r29, 0xFE	; 254
     38a:	88 81       	ld	r24, Y
     38c:	99 81       	ldd	r25, Y+1	; 0x01
     38e:	cf 50       	subi	r28, 0x0F	; 15
     390:	d1 40       	sbci	r29, 0x01	; 1
     392:	83 30       	cpi	r24, 0x03	; 3
     394:	91 05       	cpc	r25, r1
     396:	09 f4       	brne	.+2      	; 0x39a <main+0xa0>
     398:	59 c0       	rjmp	.+178    	; 0x44c <main+0x152>
     39a:	e2 cf       	rjmp	.-60     	; 0x360 <main+0x66>
		{
			case WR_DF:
				if ((currentLen == recvFrame.dataLen) && (r_status == R_NULL))
     39c:	20 91 81 01 	lds	r18, 0x0181
     3a0:	30 91 82 01 	lds	r19, 0x0182
     3a4:	80 91 7c 01 	lds	r24, 0x017C
     3a8:	90 91 7d 01 	lds	r25, 0x017D
     3ac:	28 17       	cp	r18, r24
     3ae:	39 07       	cpc	r19, r25
     3b0:	b9 f6       	brne	.-82     	; 0x360 <main+0x66>
     3b2:	80 91 7a 01 	lds	r24, 0x017A
     3b6:	88 23       	and	r24, r24
     3b8:	99 f6       	brne	.-90     	; 0x360 <main+0x66>
				{					
					//将数据写到内存中(自动先写到BUFFER1 OR BURRER2中再将数据写到内存中)
					page = *(unsigned int *)recvFrame.data; 
     3ba:	80 91 83 01 	lds	r24, 0x0183
     3be:	90 91 84 01 	lds	r25, 0x0184
     3c2:	fc 01       	movw	r30, r24
     3c4:	80 81       	ld	r24, Z
     3c6:	91 81       	ldd	r25, Z+1	; 0x01
     3c8:	9e 83       	std	Y+6, r25	; 0x06
     3ca:	8d 83       	std	Y+5, r24	; 0x05
					pData = recvFrame.data+2;
     3cc:	80 91 83 01 	lds	r24, 0x0183
     3d0:	90 91 84 01 	lds	r25, 0x0184
     3d4:	02 96       	adiw	r24, 0x02	; 2
     3d6:	9a 83       	std	Y+2, r25	; 0x02
     3d8:	89 83       	std	Y+1, r24	; 0x01
					Main_Memory_Page_Program_Through_Buffer(Buffer1, page, 0, pData, recvFrame.dataLen-2);
     3da:	80 91 81 01 	lds	r24, 0x0181
     3de:	90 91 82 01 	lds	r25, 0x0182
     3e2:	dc 01       	movw	r26, r24
     3e4:	12 97       	sbiw	r26, 0x02	; 2
     3e6:	2d 81       	ldd	r18, Y+5	; 0x05
     3e8:	3e 81       	ldd	r19, Y+6	; 0x06
     3ea:	e9 81       	ldd	r30, Y+1	; 0x01
     3ec:	fa 81       	ldd	r31, Y+2	; 0x02
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	b9 01       	movw	r22, r18
     3f2:	40 e0       	ldi	r20, 0x00	; 0
     3f4:	9f 01       	movw	r18, r30
     3f6:	8d 01       	movw	r16, r26
     3f8:	0e 94 4a 08 	call	0x1094	; 0x1094 <Main_Memory_Page_Program_Through_Buffer>
					currentLen = 0;
     3fc:	10 92 7d 01 	sts	0x017D, r1
     400:	10 92 7c 01 	sts	0x017C, r1
					recvFrame.cmd = CMD_NULL;
     404:	10 92 80 01 	sts	0x0180, r1
					recvFrame.dataLen = 0;
     408:	10 92 82 01 	sts	0x0182, r1
     40c:	10 92 81 01 	sts	0x0181, r1
					r_status = R_CMD;
     410:	81 e0       	ldi	r24, 0x01	; 1
     412:	80 93 7a 01 	sts	0x017A, r24
					free(recvFrame.data);
     416:	80 91 83 01 	lds	r24, 0x0183
     41a:	90 91 84 01 	lds	r25, 0x0184
     41e:	0e 94 4e 14 	call	0x289c	; 0x289c <free>
					
					//写dataFlash应答
					sendFrame.cmd = WR_DF_RSP;
     422:	82 e0       	ldi	r24, 0x02	; 2
     424:	80 93 85 01 	sts	0x0185, r24
					sendFrame.dataLen = 0;
     428:	10 92 87 01 	sts	0x0187, r1
     42c:	10 92 86 01 	sts	0x0186, r1
					usart_send((char *)&sendFrame, sendFrame.dataLen+3, CH_USART0);		
     430:	80 91 86 01 	lds	r24, 0x0186
     434:	90 91 87 01 	lds	r25, 0x0187
     438:	9c 01       	movw	r18, r24
     43a:	2d 5f       	subi	r18, 0xFD	; 253
     43c:	3f 4f       	sbci	r19, 0xFF	; 255
     43e:	85 e8       	ldi	r24, 0x85	; 133
     440:	91 e0       	ldi	r25, 0x01	; 1
     442:	b9 01       	movw	r22, r18
     444:	40 e0       	ldi	r20, 0x00	; 0
     446:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <usart_send>
     44a:	8a cf       	rjmp	.-236    	; 0x360 <main+0x66>
				}
				break;
			case RD_CHECK:
				if ((currentLen == recvFrame.dataLen) && (r_status == R_NULL))				
     44c:	20 91 81 01 	lds	r18, 0x0181
     450:	30 91 82 01 	lds	r19, 0x0182
     454:	80 91 7c 01 	lds	r24, 0x017C
     458:	90 91 7d 01 	lds	r25, 0x017D
     45c:	28 17       	cp	r18, r24
     45e:	39 07       	cpc	r19, r25
     460:	09 f0       	breq	.+2      	; 0x464 <main+0x16a>
     462:	7e cf       	rjmp	.-260    	; 0x360 <main+0x66>
     464:	80 91 7a 01 	lds	r24, 0x017A
     468:	88 23       	and	r24, r24
     46a:	09 f0       	breq	.+2      	; 0x46e <main+0x174>
     46c:	79 cf       	rjmp	.-270    	; 0x360 <main+0x66>
				{
					currentLen = 0;
     46e:	10 92 7d 01 	sts	0x017D, r1
     472:	10 92 7c 01 	sts	0x017C, r1
					recvFrame.cmd = CMD_NULL;
     476:	10 92 80 01 	sts	0x0180, r1
					recvFrame.dataLen = 0;
     47a:	10 92 82 01 	sts	0x0182, r1
     47e:	10 92 81 01 	sts	0x0181, r1
					r_status = R_CMD;
     482:	81 e0       	ldi	r24, 0x01	; 1
     484:	80 93 7a 01 	sts	0x017A, r24
					//从内存中读取数据到数组rData中(直接读取数据不经过BUFFER1 OR BURRER2)
					page = *(unsigned int *)recvFrame.data;
     488:	80 91 83 01 	lds	r24, 0x0183
     48c:	90 91 84 01 	lds	r25, 0x0184
     490:	fc 01       	movw	r30, r24
     492:	80 81       	ld	r24, Z
     494:	91 81       	ldd	r25, Z+1	; 0x01
     496:	9e 83       	std	Y+6, r25	; 0x06
     498:	8d 83       	std	Y+5, r24	; 0x05
					dataNum = *((unsigned int *)(recvFrame.data + 2));
     49a:	80 91 83 01 	lds	r24, 0x0183
     49e:	90 91 84 01 	lds	r25, 0x0184
     4a2:	fc 01       	movw	r30, r24
     4a4:	32 96       	adiw	r30, 0x02	; 2
     4a6:	80 81       	ld	r24, Z
     4a8:	91 81       	ldd	r25, Z+1	; 0x01
     4aa:	9c 83       	std	Y+4, r25	; 0x04
     4ac:	8b 83       	std	Y+3, r24	; 0x03
					DF_Main_Memory_Page_Read(page, 0, readBuffer, dataNum);					
     4ae:	8d 81       	ldd	r24, Y+5	; 0x05
     4b0:	9e 81       	ldd	r25, Y+6	; 0x06
     4b2:	9e 01       	movw	r18, r28
     4b4:	29 5f       	subi	r18, 0xF9	; 249
     4b6:	3f 4f       	sbci	r19, 0xFF	; 255
     4b8:	eb 81       	ldd	r30, Y+3	; 0x03
     4ba:	fc 81       	ldd	r31, Y+4	; 0x04
     4bc:	60 e0       	ldi	r22, 0x00	; 0
     4be:	a9 01       	movw	r20, r18
     4c0:	9f 01       	movw	r18, r30
     4c2:	0e 94 aa 08 	call	0x1154	; 0x1154 <DF_Main_Memory_Page_Read>
					sendFrame.cmd = RD_CHECK_RSP;
     4c6:	84 e0       	ldi	r24, 0x04	; 4
     4c8:	80 93 85 01 	sts	0x0185, r24
					sendFrame.dataLen = dataNum;
     4cc:	8b 81       	ldd	r24, Y+3	; 0x03
     4ce:	9c 81       	ldd	r25, Y+4	; 0x04
     4d0:	90 93 87 01 	sts	0x0187, r25
     4d4:	80 93 86 01 	sts	0x0186, r24
					sendFrame.data = readBuffer;
     4d8:	ce 01       	movw	r24, r28
     4da:	07 96       	adiw	r24, 0x07	; 7
     4dc:	90 93 89 01 	sts	0x0189, r25
     4e0:	80 93 88 01 	sts	0x0188, r24
					usart_send((char *)&sendFrame, 3, CH_USART0);//send head
     4e4:	85 e8       	ldi	r24, 0x85	; 133
     4e6:	91 e0       	ldi	r25, 0x01	; 1
     4e8:	63 e0       	ldi	r22, 0x03	; 3
     4ea:	70 e0       	ldi	r23, 0x00	; 0
     4ec:	40 e0       	ldi	r20, 0x00	; 0
     4ee:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <usart_send>
					usart_send((char *)&readBuffer, sendFrame.dataLen, CH_USART0);//send data
     4f2:	20 91 86 01 	lds	r18, 0x0186
     4f6:	30 91 87 01 	lds	r19, 0x0187
     4fa:	ce 01       	movw	r24, r28
     4fc:	07 96       	adiw	r24, 0x07	; 7
     4fe:	b9 01       	movw	r22, r18
     500:	40 e0       	ldi	r20, 0x00	; 0
     502:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <usart_send>
					free(recvFrame.data);//释放
     506:	80 91 83 01 	lds	r24, 0x0183
     50a:	90 91 84 01 	lds	r25, 0x0184
     50e:	0e 94 4e 14 	call	0x289c	; 0x289c <free>
     512:	26 cf       	rjmp	.-436    	; 0x360 <main+0x66>

00000514 <Enable_DFLASH>:

/************************************************************
*使能FLASH(低电平使能)
************************************************************/
void Enable_DFLASH(void)
{
     514:	df 93       	push	r29
     516:	cf 93       	push	r28
     518:	cd b7       	in	r28, 0x3d	; 61
     51a:	de b7       	in	r29, 0x3e	; 62
     51c:	68 97       	sbiw	r28, 0x18	; 24
     51e:	0f b6       	in	r0, 0x3f	; 63
     520:	f8 94       	cli
     522:	de bf       	out	0x3e, r29	; 62
     524:	0f be       	out	0x3f, r0	; 63
     526:	cd bf       	out	0x3d, r28	; 61
     528:	80 e0       	ldi	r24, 0x00	; 0
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	a0 e2       	ldi	r26, 0x20	; 32
     52e:	b1 e4       	ldi	r27, 0x41	; 65
     530:	8d 8b       	std	Y+21, r24	; 0x15
     532:	9e 8b       	std	Y+22, r25	; 0x16
     534:	af 8b       	std	Y+23, r26	; 0x17
     536:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
     538:	6d 89       	ldd	r22, Y+21	; 0x15
     53a:	7e 89       	ldd	r23, Y+22	; 0x16
     53c:	8f 89       	ldd	r24, Y+23	; 0x17
     53e:	98 8d       	ldd	r25, Y+24	; 0x18
     540:	2a ef       	ldi	r18, 0xFA	; 250
     542:	3d ee       	ldi	r19, 0xED	; 237
     544:	4b e6       	ldi	r20, 0x6B	; 107
     546:	50 e4       	ldi	r21, 0x40	; 64
     548:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
     54c:	dc 01       	movw	r26, r24
     54e:	cb 01       	movw	r24, r22
     550:	89 8b       	std	Y+17, r24	; 0x11
     552:	9a 8b       	std	Y+18, r25	; 0x12
     554:	ab 8b       	std	Y+19, r26	; 0x13
     556:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
     558:	69 89       	ldd	r22, Y+17	; 0x11
     55a:	7a 89       	ldd	r23, Y+18	; 0x12
     55c:	8b 89       	ldd	r24, Y+19	; 0x13
     55e:	9c 89       	ldd	r25, Y+20	; 0x14
     560:	20 e0       	ldi	r18, 0x00	; 0
     562:	30 e0       	ldi	r19, 0x00	; 0
     564:	40 e8       	ldi	r20, 0x80	; 128
     566:	5f e3       	ldi	r21, 0x3F	; 63
     568:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
     56c:	88 23       	and	r24, r24
     56e:	1c f4       	brge	.+6      	; 0x576 <Enable_DFLASH+0x62>
		__ticks = 1;
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	88 8b       	std	Y+16, r24	; 0x10
     574:	91 c0       	rjmp	.+290    	; 0x698 <Enable_DFLASH+0x184>
	else if (__tmp > 255)
     576:	69 89       	ldd	r22, Y+17	; 0x11
     578:	7a 89       	ldd	r23, Y+18	; 0x12
     57a:	8b 89       	ldd	r24, Y+19	; 0x13
     57c:	9c 89       	ldd	r25, Y+20	; 0x14
     57e:	20 e0       	ldi	r18, 0x00	; 0
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	4f e7       	ldi	r20, 0x7F	; 127
     584:	53 e4       	ldi	r21, 0x43	; 67
     586:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
     58a:	18 16       	cp	r1, r24
     58c:	0c f0       	brlt	.+2      	; 0x590 <Enable_DFLASH+0x7c>
     58e:	7b c0       	rjmp	.+246    	; 0x686 <Enable_DFLASH+0x172>
	{
		_delay_ms(__us / 1000.0);
     590:	6d 89       	ldd	r22, Y+21	; 0x15
     592:	7e 89       	ldd	r23, Y+22	; 0x16
     594:	8f 89       	ldd	r24, Y+23	; 0x17
     596:	98 8d       	ldd	r25, Y+24	; 0x18
     598:	20 e0       	ldi	r18, 0x00	; 0
     59a:	30 e0       	ldi	r19, 0x00	; 0
     59c:	4a e7       	ldi	r20, 0x7A	; 122
     59e:	54 e4       	ldi	r21, 0x44	; 68
     5a0:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <__divsf3>
     5a4:	dc 01       	movw	r26, r24
     5a6:	cb 01       	movw	r24, r22
     5a8:	8c 87       	std	Y+12, r24	; 0x0c
     5aa:	9d 87       	std	Y+13, r25	; 0x0d
     5ac:	ae 87       	std	Y+14, r26	; 0x0e
     5ae:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     5b0:	6c 85       	ldd	r22, Y+12	; 0x0c
     5b2:	7d 85       	ldd	r23, Y+13	; 0x0d
     5b4:	8e 85       	ldd	r24, Y+14	; 0x0e
     5b6:	9f 85       	ldd	r25, Y+15	; 0x0f
     5b8:	2d ec       	ldi	r18, 0xCD	; 205
     5ba:	3c ec       	ldi	r19, 0xCC	; 204
     5bc:	4c e2       	ldi	r20, 0x2C	; 44
     5be:	55 e4       	ldi	r21, 0x45	; 69
     5c0:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
     5c4:	dc 01       	movw	r26, r24
     5c6:	cb 01       	movw	r24, r22
     5c8:	88 87       	std	Y+8, r24	; 0x08
     5ca:	99 87       	std	Y+9, r25	; 0x09
     5cc:	aa 87       	std	Y+10, r26	; 0x0a
     5ce:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
     5d0:	68 85       	ldd	r22, Y+8	; 0x08
     5d2:	79 85       	ldd	r23, Y+9	; 0x09
     5d4:	8a 85       	ldd	r24, Y+10	; 0x0a
     5d6:	9b 85       	ldd	r25, Y+11	; 0x0b
     5d8:	20 e0       	ldi	r18, 0x00	; 0
     5da:	30 e0       	ldi	r19, 0x00	; 0
     5dc:	40 e8       	ldi	r20, 0x80	; 128
     5de:	5f e3       	ldi	r21, 0x3F	; 63
     5e0:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
     5e4:	88 23       	and	r24, r24
     5e6:	2c f4       	brge	.+10     	; 0x5f2 <Enable_DFLASH+0xde>
		__ticks = 1;
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	9f 83       	std	Y+7, r25	; 0x07
     5ee:	8e 83       	std	Y+6, r24	; 0x06
     5f0:	3f c0       	rjmp	.+126    	; 0x670 <Enable_DFLASH+0x15c>
	else if (__tmp > 65535)
     5f2:	68 85       	ldd	r22, Y+8	; 0x08
     5f4:	79 85       	ldd	r23, Y+9	; 0x09
     5f6:	8a 85       	ldd	r24, Y+10	; 0x0a
     5f8:	9b 85       	ldd	r25, Y+11	; 0x0b
     5fa:	20 e0       	ldi	r18, 0x00	; 0
     5fc:	3f ef       	ldi	r19, 0xFF	; 255
     5fe:	4f e7       	ldi	r20, 0x7F	; 127
     600:	57 e4       	ldi	r21, 0x47	; 71
     602:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
     606:	18 16       	cp	r1, r24
     608:	4c f5       	brge	.+82     	; 0x65c <Enable_DFLASH+0x148>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     60a:	6c 85       	ldd	r22, Y+12	; 0x0c
     60c:	7d 85       	ldd	r23, Y+13	; 0x0d
     60e:	8e 85       	ldd	r24, Y+14	; 0x0e
     610:	9f 85       	ldd	r25, Y+15	; 0x0f
     612:	20 e0       	ldi	r18, 0x00	; 0
     614:	30 e0       	ldi	r19, 0x00	; 0
     616:	40 e2       	ldi	r20, 0x20	; 32
     618:	51 e4       	ldi	r21, 0x41	; 65
     61a:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
     61e:	dc 01       	movw	r26, r24
     620:	cb 01       	movw	r24, r22
     622:	bc 01       	movw	r22, r24
     624:	cd 01       	movw	r24, r26
     626:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
     62a:	dc 01       	movw	r26, r24
     62c:	cb 01       	movw	r24, r22
     62e:	9f 83       	std	Y+7, r25	; 0x07
     630:	8e 83       	std	Y+6, r24	; 0x06
     632:	0f c0       	rjmp	.+30     	; 0x652 <Enable_DFLASH+0x13e>
     634:	84 e1       	ldi	r24, 0x14	; 20
     636:	91 e0       	ldi	r25, 0x01	; 1
     638:	9d 83       	std	Y+5, r25	; 0x05
     63a:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     63c:	8c 81       	ldd	r24, Y+4	; 0x04
     63e:	9d 81       	ldd	r25, Y+5	; 0x05
     640:	01 97       	sbiw	r24, 0x01	; 1
     642:	f1 f7       	brne	.-4      	; 0x640 <Enable_DFLASH+0x12c>
     644:	9d 83       	std	Y+5, r25	; 0x05
     646:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     648:	8e 81       	ldd	r24, Y+6	; 0x06
     64a:	9f 81       	ldd	r25, Y+7	; 0x07
     64c:	01 97       	sbiw	r24, 0x01	; 1
     64e:	9f 83       	std	Y+7, r25	; 0x07
     650:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     652:	8e 81       	ldd	r24, Y+6	; 0x06
     654:	9f 81       	ldd	r25, Y+7	; 0x07
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	69 f7       	brne	.-38     	; 0x634 <Enable_DFLASH+0x120>
     65a:	24 c0       	rjmp	.+72     	; 0x6a4 <Enable_DFLASH+0x190>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     65c:	68 85       	ldd	r22, Y+8	; 0x08
     65e:	79 85       	ldd	r23, Y+9	; 0x09
     660:	8a 85       	ldd	r24, Y+10	; 0x0a
     662:	9b 85       	ldd	r25, Y+11	; 0x0b
     664:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
     668:	dc 01       	movw	r26, r24
     66a:	cb 01       	movw	r24, r22
     66c:	9f 83       	std	Y+7, r25	; 0x07
     66e:	8e 83       	std	Y+6, r24	; 0x06
     670:	8e 81       	ldd	r24, Y+6	; 0x06
     672:	9f 81       	ldd	r25, Y+7	; 0x07
     674:	9b 83       	std	Y+3, r25	; 0x03
     676:	8a 83       	std	Y+2, r24	; 0x02
     678:	8a 81       	ldd	r24, Y+2	; 0x02
     67a:	9b 81       	ldd	r25, Y+3	; 0x03
     67c:	01 97       	sbiw	r24, 0x01	; 1
     67e:	f1 f7       	brne	.-4      	; 0x67c <Enable_DFLASH+0x168>
     680:	9b 83       	std	Y+3, r25	; 0x03
     682:	8a 83       	std	Y+2, r24	; 0x02
     684:	0f c0       	rjmp	.+30     	; 0x6a4 <Enable_DFLASH+0x190>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     686:	69 89       	ldd	r22, Y+17	; 0x11
     688:	7a 89       	ldd	r23, Y+18	; 0x12
     68a:	8b 89       	ldd	r24, Y+19	; 0x13
     68c:	9c 89       	ldd	r25, Y+20	; 0x14
     68e:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
     692:	dc 01       	movw	r26, r24
     694:	cb 01       	movw	r24, r22
     696:	88 8b       	std	Y+16, r24	; 0x10
     698:	88 89       	ldd	r24, Y+16	; 0x10
     69a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     69c:	89 81       	ldd	r24, Y+1	; 0x01
     69e:	8a 95       	dec	r24
     6a0:	f1 f7       	brne	.-4      	; 0x69e <Enable_DFLASH+0x18a>
     6a2:	89 83       	std	Y+1, r24	; 0x01
  _delay_us(10);
  SPI_PORT &= ~(1<<SS);
     6a4:	a8 e3       	ldi	r26, 0x38	; 56
     6a6:	b0 e0       	ldi	r27, 0x00	; 0
     6a8:	e8 e3       	ldi	r30, 0x38	; 56
     6aa:	f0 e0       	ldi	r31, 0x00	; 0
     6ac:	80 81       	ld	r24, Z
     6ae:	8e 7f       	andi	r24, 0xFE	; 254
     6b0:	8c 93       	st	X, r24
}
     6b2:	68 96       	adiw	r28, 0x18	; 24
     6b4:	0f b6       	in	r0, 0x3f	; 63
     6b6:	f8 94       	cli
     6b8:	de bf       	out	0x3e, r29	; 62
     6ba:	0f be       	out	0x3f, r0	; 63
     6bc:	cd bf       	out	0x3d, r28	; 61
     6be:	cf 91       	pop	r28
     6c0:	df 91       	pop	r29
     6c2:	08 95       	ret

000006c4 <Disable_DFLASH>:
/************************************************************
*禁止FLASH(高电平禁止)
************************************************************/
void Disable_DFLASH(void)
{
     6c4:	df 93       	push	r29
     6c6:	cf 93       	push	r28
     6c8:	cd b7       	in	r28, 0x3d	; 61
     6ca:	de b7       	in	r29, 0x3e	; 62
     6cc:	68 97       	sbiw	r28, 0x18	; 24
     6ce:	0f b6       	in	r0, 0x3f	; 63
     6d0:	f8 94       	cli
     6d2:	de bf       	out	0x3e, r29	; 62
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	cd bf       	out	0x3d, r28	; 61
  SPI_PORT |= (1<<SS);
     6d8:	a8 e3       	ldi	r26, 0x38	; 56
     6da:	b0 e0       	ldi	r27, 0x00	; 0
     6dc:	e8 e3       	ldi	r30, 0x38	; 56
     6de:	f0 e0       	ldi	r31, 0x00	; 0
     6e0:	80 81       	ld	r24, Z
     6e2:	81 60       	ori	r24, 0x01	; 1
     6e4:	8c 93       	st	X, r24
     6e6:	80 e0       	ldi	r24, 0x00	; 0
     6e8:	90 e0       	ldi	r25, 0x00	; 0
     6ea:	a0 e2       	ldi	r26, 0x20	; 32
     6ec:	b1 e4       	ldi	r27, 0x41	; 65
     6ee:	8d 8b       	std	Y+21, r24	; 0x15
     6f0:	9e 8b       	std	Y+22, r25	; 0x16
     6f2:	af 8b       	std	Y+23, r26	; 0x17
     6f4:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
     6f6:	6d 89       	ldd	r22, Y+21	; 0x15
     6f8:	7e 89       	ldd	r23, Y+22	; 0x16
     6fa:	8f 89       	ldd	r24, Y+23	; 0x17
     6fc:	98 8d       	ldd	r25, Y+24	; 0x18
     6fe:	2a ef       	ldi	r18, 0xFA	; 250
     700:	3d ee       	ldi	r19, 0xED	; 237
     702:	4b e6       	ldi	r20, 0x6B	; 107
     704:	50 e4       	ldi	r21, 0x40	; 64
     706:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
     70a:	dc 01       	movw	r26, r24
     70c:	cb 01       	movw	r24, r22
     70e:	89 8b       	std	Y+17, r24	; 0x11
     710:	9a 8b       	std	Y+18, r25	; 0x12
     712:	ab 8b       	std	Y+19, r26	; 0x13
     714:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
     716:	69 89       	ldd	r22, Y+17	; 0x11
     718:	7a 89       	ldd	r23, Y+18	; 0x12
     71a:	8b 89       	ldd	r24, Y+19	; 0x13
     71c:	9c 89       	ldd	r25, Y+20	; 0x14
     71e:	20 e0       	ldi	r18, 0x00	; 0
     720:	30 e0       	ldi	r19, 0x00	; 0
     722:	40 e8       	ldi	r20, 0x80	; 128
     724:	5f e3       	ldi	r21, 0x3F	; 63
     726:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
     72a:	88 23       	and	r24, r24
     72c:	1c f4       	brge	.+6      	; 0x734 <Disable_DFLASH+0x70>
		__ticks = 1;
     72e:	81 e0       	ldi	r24, 0x01	; 1
     730:	88 8b       	std	Y+16, r24	; 0x10
     732:	91 c0       	rjmp	.+290    	; 0x856 <Disable_DFLASH+0x192>
	else if (__tmp > 255)
     734:	69 89       	ldd	r22, Y+17	; 0x11
     736:	7a 89       	ldd	r23, Y+18	; 0x12
     738:	8b 89       	ldd	r24, Y+19	; 0x13
     73a:	9c 89       	ldd	r25, Y+20	; 0x14
     73c:	20 e0       	ldi	r18, 0x00	; 0
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	4f e7       	ldi	r20, 0x7F	; 127
     742:	53 e4       	ldi	r21, 0x43	; 67
     744:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
     748:	18 16       	cp	r1, r24
     74a:	0c f0       	brlt	.+2      	; 0x74e <Disable_DFLASH+0x8a>
     74c:	7b c0       	rjmp	.+246    	; 0x844 <Disable_DFLASH+0x180>
	{
		_delay_ms(__us / 1000.0);
     74e:	6d 89       	ldd	r22, Y+21	; 0x15
     750:	7e 89       	ldd	r23, Y+22	; 0x16
     752:	8f 89       	ldd	r24, Y+23	; 0x17
     754:	98 8d       	ldd	r25, Y+24	; 0x18
     756:	20 e0       	ldi	r18, 0x00	; 0
     758:	30 e0       	ldi	r19, 0x00	; 0
     75a:	4a e7       	ldi	r20, 0x7A	; 122
     75c:	54 e4       	ldi	r21, 0x44	; 68
     75e:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <__divsf3>
     762:	dc 01       	movw	r26, r24
     764:	cb 01       	movw	r24, r22
     766:	8c 87       	std	Y+12, r24	; 0x0c
     768:	9d 87       	std	Y+13, r25	; 0x0d
     76a:	ae 87       	std	Y+14, r26	; 0x0e
     76c:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     76e:	6c 85       	ldd	r22, Y+12	; 0x0c
     770:	7d 85       	ldd	r23, Y+13	; 0x0d
     772:	8e 85       	ldd	r24, Y+14	; 0x0e
     774:	9f 85       	ldd	r25, Y+15	; 0x0f
     776:	2d ec       	ldi	r18, 0xCD	; 205
     778:	3c ec       	ldi	r19, 0xCC	; 204
     77a:	4c e2       	ldi	r20, 0x2C	; 44
     77c:	55 e4       	ldi	r21, 0x45	; 69
     77e:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
     782:	dc 01       	movw	r26, r24
     784:	cb 01       	movw	r24, r22
     786:	88 87       	std	Y+8, r24	; 0x08
     788:	99 87       	std	Y+9, r25	; 0x09
     78a:	aa 87       	std	Y+10, r26	; 0x0a
     78c:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
     78e:	68 85       	ldd	r22, Y+8	; 0x08
     790:	79 85       	ldd	r23, Y+9	; 0x09
     792:	8a 85       	ldd	r24, Y+10	; 0x0a
     794:	9b 85       	ldd	r25, Y+11	; 0x0b
     796:	20 e0       	ldi	r18, 0x00	; 0
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	40 e8       	ldi	r20, 0x80	; 128
     79c:	5f e3       	ldi	r21, 0x3F	; 63
     79e:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
     7a2:	88 23       	and	r24, r24
     7a4:	2c f4       	brge	.+10     	; 0x7b0 <Disable_DFLASH+0xec>
		__ticks = 1;
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	9f 83       	std	Y+7, r25	; 0x07
     7ac:	8e 83       	std	Y+6, r24	; 0x06
     7ae:	3f c0       	rjmp	.+126    	; 0x82e <Disable_DFLASH+0x16a>
	else if (__tmp > 65535)
     7b0:	68 85       	ldd	r22, Y+8	; 0x08
     7b2:	79 85       	ldd	r23, Y+9	; 0x09
     7b4:	8a 85       	ldd	r24, Y+10	; 0x0a
     7b6:	9b 85       	ldd	r25, Y+11	; 0x0b
     7b8:	20 e0       	ldi	r18, 0x00	; 0
     7ba:	3f ef       	ldi	r19, 0xFF	; 255
     7bc:	4f e7       	ldi	r20, 0x7F	; 127
     7be:	57 e4       	ldi	r21, 0x47	; 71
     7c0:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
     7c4:	18 16       	cp	r1, r24
     7c6:	4c f5       	brge	.+82     	; 0x81a <Disable_DFLASH+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     7c8:	6c 85       	ldd	r22, Y+12	; 0x0c
     7ca:	7d 85       	ldd	r23, Y+13	; 0x0d
     7cc:	8e 85       	ldd	r24, Y+14	; 0x0e
     7ce:	9f 85       	ldd	r25, Y+15	; 0x0f
     7d0:	20 e0       	ldi	r18, 0x00	; 0
     7d2:	30 e0       	ldi	r19, 0x00	; 0
     7d4:	40 e2       	ldi	r20, 0x20	; 32
     7d6:	51 e4       	ldi	r21, 0x41	; 65
     7d8:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
     7dc:	dc 01       	movw	r26, r24
     7de:	cb 01       	movw	r24, r22
     7e0:	bc 01       	movw	r22, r24
     7e2:	cd 01       	movw	r24, r26
     7e4:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
     7e8:	dc 01       	movw	r26, r24
     7ea:	cb 01       	movw	r24, r22
     7ec:	9f 83       	std	Y+7, r25	; 0x07
     7ee:	8e 83       	std	Y+6, r24	; 0x06
     7f0:	0f c0       	rjmp	.+30     	; 0x810 <Disable_DFLASH+0x14c>
     7f2:	84 e1       	ldi	r24, 0x14	; 20
     7f4:	91 e0       	ldi	r25, 0x01	; 1
     7f6:	9d 83       	std	Y+5, r25	; 0x05
     7f8:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     7fa:	8c 81       	ldd	r24, Y+4	; 0x04
     7fc:	9d 81       	ldd	r25, Y+5	; 0x05
     7fe:	01 97       	sbiw	r24, 0x01	; 1
     800:	f1 f7       	brne	.-4      	; 0x7fe <Disable_DFLASH+0x13a>
     802:	9d 83       	std	Y+5, r25	; 0x05
     804:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     806:	8e 81       	ldd	r24, Y+6	; 0x06
     808:	9f 81       	ldd	r25, Y+7	; 0x07
     80a:	01 97       	sbiw	r24, 0x01	; 1
     80c:	9f 83       	std	Y+7, r25	; 0x07
     80e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     810:	8e 81       	ldd	r24, Y+6	; 0x06
     812:	9f 81       	ldd	r25, Y+7	; 0x07
     814:	00 97       	sbiw	r24, 0x00	; 0
     816:	69 f7       	brne	.-38     	; 0x7f2 <Disable_DFLASH+0x12e>
     818:	24 c0       	rjmp	.+72     	; 0x862 <Disable_DFLASH+0x19e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     81a:	68 85       	ldd	r22, Y+8	; 0x08
     81c:	79 85       	ldd	r23, Y+9	; 0x09
     81e:	8a 85       	ldd	r24, Y+10	; 0x0a
     820:	9b 85       	ldd	r25, Y+11	; 0x0b
     822:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
     826:	dc 01       	movw	r26, r24
     828:	cb 01       	movw	r24, r22
     82a:	9f 83       	std	Y+7, r25	; 0x07
     82c:	8e 83       	std	Y+6, r24	; 0x06
     82e:	8e 81       	ldd	r24, Y+6	; 0x06
     830:	9f 81       	ldd	r25, Y+7	; 0x07
     832:	9b 83       	std	Y+3, r25	; 0x03
     834:	8a 83       	std	Y+2, r24	; 0x02
     836:	8a 81       	ldd	r24, Y+2	; 0x02
     838:	9b 81       	ldd	r25, Y+3	; 0x03
     83a:	01 97       	sbiw	r24, 0x01	; 1
     83c:	f1 f7       	brne	.-4      	; 0x83a <Disable_DFLASH+0x176>
     83e:	9b 83       	std	Y+3, r25	; 0x03
     840:	8a 83       	std	Y+2, r24	; 0x02
     842:	0f c0       	rjmp	.+30     	; 0x862 <Disable_DFLASH+0x19e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     844:	69 89       	ldd	r22, Y+17	; 0x11
     846:	7a 89       	ldd	r23, Y+18	; 0x12
     848:	8b 89       	ldd	r24, Y+19	; 0x13
     84a:	9c 89       	ldd	r25, Y+20	; 0x14
     84c:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
     850:	dc 01       	movw	r26, r24
     852:	cb 01       	movw	r24, r22
     854:	88 8b       	std	Y+16, r24	; 0x10
     856:	88 89       	ldd	r24, Y+16	; 0x10
     858:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     85a:	89 81       	ldd	r24, Y+1	; 0x01
     85c:	8a 95       	dec	r24
     85e:	f1 f7       	brne	.-4      	; 0x85c <Disable_DFLASH+0x198>
     860:	89 83       	std	Y+1, r24	; 0x01
  _delay_us(10);
}
     862:	68 96       	adiw	r28, 0x18	; 24
     864:	0f b6       	in	r0, 0x3f	; 63
     866:	f8 94       	cli
     868:	de bf       	out	0x3e, r29	; 62
     86a:	0f be       	out	0x3f, r0	; 63
     86c:	cd bf       	out	0x3d, r28	; 61
     86e:	cf 91       	pop	r28
     870:	df 91       	pop	r29
     872:	08 95       	ret

00000874 <SPI_Init>:
/************************************************************
*初始化SPI
************************************************************/

void SPI_Init(void)
{
     874:	df 93       	push	r29
     876:	cf 93       	push	r28
     878:	cd b7       	in	r28, 0x3d	; 61
     87a:	de b7       	in	r29, 0x3e	; 62
	SPI_DDR  |= ((1<<SS)|(1<<SCK)|(1<<MOSI));//设为输出
     87c:	a7 e3       	ldi	r26, 0x37	; 55
     87e:	b0 e0       	ldi	r27, 0x00	; 0
     880:	e7 e3       	ldi	r30, 0x37	; 55
     882:	f0 e0       	ldi	r31, 0x00	; 0
     884:	80 81       	ld	r24, Z
     886:	87 60       	ori	r24, 0x07	; 7
     888:	8c 93       	st	X, r24
	SPI_DDR  &=~ (1<<MISO);                  //设为输入
     88a:	a7 e3       	ldi	r26, 0x37	; 55
     88c:	b0 e0       	ldi	r27, 0x00	; 0
     88e:	e7 e3       	ldi	r30, 0x37	; 55
     890:	f0 e0       	ldi	r31, 0x00	; 0
     892:	80 81       	ld	r24, Z
     894:	87 7f       	andi	r24, 0xF7	; 247
     896:	8c 93       	st	X, r24
	SPI_PORT |= (1<<SS)|(1<<SCK)|(1<<MOSI);  //输出高电平
     898:	a8 e3       	ldi	r26, 0x38	; 56
     89a:	b0 e0       	ldi	r27, 0x00	; 0
     89c:	e8 e3       	ldi	r30, 0x38	; 56
     89e:	f0 e0       	ldi	r31, 0x00	; 0
     8a0:	80 81       	ld	r24, Z
     8a2:	87 60       	ori	r24, 0x07	; 7
     8a4:	8c 93       	st	X, r24
	SPI_PORT |= (1<<MOSI);				   //上拉
     8a6:	a8 e3       	ldi	r26, 0x38	; 56
     8a8:	b0 e0       	ldi	r27, 0x00	; 0
     8aa:	e8 e3       	ldi	r30, 0x38	; 56
     8ac:	f0 e0       	ldi	r31, 0x00	; 0
     8ae:	80 81       	ld	r24, Z
     8b0:	84 60       	ori	r24, 0x04	; 4
     8b2:	8c 93       	st	X, r24
	SPI_DDR|=(1<<RESET);                     //复位引脚设为输出
     8b4:	a7 e3       	ldi	r26, 0x37	; 55
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	e7 e3       	ldi	r30, 0x37	; 55
     8ba:	f0 e0       	ldi	r31, 0x00	; 0
     8bc:	80 81       	ld	r24, Z
     8be:	80 61       	ori	r24, 0x10	; 16
     8c0:	8c 93       	st	X, r24
	//SPI使能, master模式, MSB 前,  SPI 模式 3, SCK频率为fosc/4 平时SCK为高电平
	SPCR |= (1<<SPE)|(1<<MSTR)|(1<<CPHA)|(1<<CPOL);
     8c2:	ad e2       	ldi	r26, 0x2D	; 45
     8c4:	b0 e0       	ldi	r27, 0x00	; 0
     8c6:	ed e2       	ldi	r30, 0x2D	; 45
     8c8:	f0 e0       	ldi	r31, 0x00	; 0
     8ca:	80 81       	ld	r24, Z
     8cc:	8c 65       	ori	r24, 0x5C	; 92
     8ce:	8c 93       	st	X, r24
	//频率加倍,SCK频率为fosc/2
	SPSR |= (1<<SPI2X);
     8d0:	ae e2       	ldi	r26, 0x2E	; 46
     8d2:	b0 e0       	ldi	r27, 0x00	; 0
     8d4:	ee e2       	ldi	r30, 0x2E	; 46
     8d6:	f0 e0       	ldi	r31, 0x00	; 0
     8d8:	80 81       	ld	r24, Z
     8da:	81 60       	ori	r24, 0x01	; 1
     8dc:	8c 93       	st	X, r24
	Disable_DFLASH();
     8de:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     8e2:	cf 91       	pop	r28
     8e4:	df 91       	pop	r29
     8e6:	08 95       	ret

000008e8 <SPI_Transfer>:

unsigned char SPI_Transfer(unsigned char data)
{
     8e8:	df 93       	push	r29
     8ea:	cf 93       	push	r28
     8ec:	00 d0       	rcall	.+0      	; 0x8ee <SPI_Transfer+0x6>
     8ee:	cd b7       	in	r28, 0x3d	; 61
     8f0:	de b7       	in	r29, 0x3e	; 62
     8f2:	8a 83       	std	Y+2, r24	; 0x02
    unsigned char tempData;
	//printf("spi_transfer:0x%02x \t ", data);
	SPDR = data;
     8f4:	ef e2       	ldi	r30, 0x2F	; 47
     8f6:	f0 e0       	ldi	r31, 0x00	; 0
     8f8:	8a 81       	ldd	r24, Y+2	; 0x02
     8fa:	80 83       	st	Z, r24
    while(!(SPSR & (1<<SPIF))); // 等待传输结束
     8fc:	ee e2       	ldi	r30, 0x2E	; 46
     8fe:	f0 e0       	ldi	r31, 0x00	; 0
     900:	80 81       	ld	r24, Z
     902:	88 23       	and	r24, r24
     904:	dc f7       	brge	.-10     	; 0x8fc <SPI_Transfer+0x14>
	tempData = SPDR;
     906:	ef e2       	ldi	r30, 0x2F	; 47
     908:	f0 e0       	ldi	r31, 0x00	; 0
     90a:	80 81       	ld	r24, Z
     90c:	89 83       	std	Y+1, r24	; 0x01
	//printf("get 0x%02x\n", tempData);
	return tempData;
     90e:	89 81       	ldd	r24, Y+1	; 0x01
}
     910:	0f 90       	pop	r0
     912:	0f 90       	pop	r0
     914:	cf 91       	pop	r28
     916:	df 91       	pop	r29
     918:	08 95       	ret

0000091a <DF_Read_status_Register>:
*Bit 7:Ready/busy status (1:no busy ; 0:busy)
*Bit 6:Compare (1: no matche ; 0:matche) 最近的一次比较结果
*Bit 0:PAGE SIZE (1:256 bytes ; 0:264 bytes)
************************************************************/
unsigned char DF_Read_status_Register(void)
{
     91a:	df 93       	push	r29
     91c:	cf 93       	push	r28
     91e:	0f 92       	push	r0
     920:	cd b7       	in	r28, 0x3d	; 61
     922:	de b7       	in	r29, 0x3e	; 62
  unsigned char rData=0;
     924:	19 82       	std	Y+1, r1	; 0x01
  Enable_DFLASH();
     926:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  SPI_Transfer(Status_Register_Opcode);//write opcode
     92a:	87 ed       	ldi	r24, 0xD7	; 215
     92c:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  rData = SPI_Transfer(0x00);//read device's status
     930:	80 e0       	ldi	r24, 0x00	; 0
     932:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     936:	89 83       	std	Y+1, r24	; 0x01
  Disable_DFLASH();
     938:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
  return rData;
     93c:	89 81       	ldd	r24, Y+1	; 0x01
}
     93e:	0f 90       	pop	r0
     940:	cf 91       	pop	r28
     942:	df 91       	pop	r29
     944:	08 95       	ret

00000946 <DF_Check_Page_Size>:
/************************************************************
*读取FLASH的页大小
*返回1表示每一页的大小为264 bytes,否则为256 bytes
************************************************************/
unsigned char DF_Check_Page_Size(void)
{
     946:	df 93       	push	r29
     948:	cf 93       	push	r28
     94a:	00 d0       	rcall	.+0      	; 0x94c <DF_Check_Page_Size+0x6>
     94c:	cd b7       	in	r28, 0x3d	; 61
     94e:	de b7       	in	r29, 0x3e	; 62
  unsigned char Page_Size;
  Page_Size=DF_Read_status_Register();
     950:	0e 94 8d 04 	call	0x91a	; 0x91a <DF_Read_status_Register>
     954:	89 83       	std	Y+1, r24	; 0x01
  if(Page_Size&0x01) return 0;
     956:	89 81       	ldd	r24, Y+1	; 0x01
     958:	88 2f       	mov	r24, r24
     95a:	90 e0       	ldi	r25, 0x00	; 0
     95c:	81 70       	andi	r24, 0x01	; 1
     95e:	90 70       	andi	r25, 0x00	; 0
     960:	88 23       	and	r24, r24
     962:	11 f0       	breq	.+4      	; 0x968 <DF_Check_Page_Size+0x22>
     964:	1a 82       	std	Y+2, r1	; 0x02
     966:	02 c0       	rjmp	.+4      	; 0x96c <DF_Check_Page_Size+0x26>
  return 1;
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	8a 83       	std	Y+2, r24	; 0x02
     96c:	8a 81       	ldd	r24, Y+2	; 0x02
}
     96e:	0f 90       	pop	r0
     970:	0f 90       	pop	r0
     972:	cf 91       	pop	r28
     974:	df 91       	pop	r29
     976:	08 95       	ret

00000978 <DF_Check_Busy_State>:
/************************************************************
*读取FLASH忙标志位(最多判断255次,不行还是返回且返回0)
************************************************************/
unsigned char DF_Check_Busy_State(void)
{
     978:	df 93       	push	r29
     97a:	cf 93       	push	r28
     97c:	00 d0       	rcall	.+0      	; 0x97e <DF_Check_Busy_State+0x6>
     97e:	cd b7       	in	r28, 0x3d	; 61
     980:	de b7       	in	r29, 0x3e	; 62
  unsigned char state;
  unsigned char i=255;
     982:	8f ef       	ldi	r24, 0xFF	; 255
     984:	89 83       	std	Y+1, r24	; 0x01
     986:	09 c0       	rjmp	.+18     	; 0x99a <DF_Check_Busy_State+0x22>
  while(i)
  {
     state=DF_Read_status_Register();
     988:	0e 94 8d 04 	call	0x91a	; 0x91a <DF_Read_status_Register>
     98c:	8a 83       	std	Y+2, r24	; 0x02
	 if(state & 0x80) break;		//读取的最高位0时器件忙
     98e:	8a 81       	ldd	r24, Y+2	; 0x02
     990:	88 23       	and	r24, r24
     992:	34 f0       	brlt	.+12     	; 0x9a0 <DF_Check_Busy_State+0x28>
	 --i;
     994:	89 81       	ldd	r24, Y+1	; 0x01
     996:	81 50       	subi	r24, 0x01	; 1
     998:	89 83       	std	Y+1, r24	; 0x01
************************************************************/
unsigned char DF_Check_Busy_State(void)
{
  unsigned char state;
  unsigned char i=255;
  while(i)
     99a:	89 81       	ldd	r24, Y+1	; 0x01
     99c:	88 23       	and	r24, r24
     99e:	a1 f7       	brne	.-24     	; 0x988 <DF_Check_Busy_State+0x10>
  {
     state=DF_Read_status_Register();
	 if(state & 0x80) break;		//读取的最高位0时器件忙
	 --i;
  }
  return i;
     9a0:	89 81       	ldd	r24, Y+1	; 0x01
}
     9a2:	0f 90       	pop	r0
     9a4:	0f 90       	pop	r0
     9a6:	cf 91       	pop	r28
     9a8:	df 91       	pop	r29
     9aa:	08 95       	ret

000009ac <DF_Manufacturer_and_Device_ID>:
*以下函数会返回四个值,第一个数对AT45DB041D来说为0x1F;
*第四个数为 0x00;
*用此函数可以判断芯片的好坏,是否正常;
************************************************************/
void DF_Manufacturer_and_Device_ID(unsigned char *ID)
{
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	df 93       	push	r29
     9b2:	cf 93       	push	r28
     9b4:	00 d0       	rcall	.+0      	; 0x9b6 <DF_Manufacturer_and_Device_ID+0xa>
     9b6:	0f 92       	push	r0
     9b8:	cd b7       	in	r28, 0x3d	; 61
     9ba:	de b7       	in	r29, 0x3e	; 62
     9bc:	9b 83       	std	Y+3, r25	; 0x03
     9be:	8a 83       	std	Y+2, r24	; 0x02
  unsigned char i;

  DF_Check_Busy_State();
     9c0:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
     9c4:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  SPI_Transfer(Device_ID_Opcode);
     9c8:	8f e9       	ldi	r24, 0x9F	; 159
     9ca:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  for(i=0;i<4;i++)
     9ce:	19 82       	std	Y+1, r1	; 0x01
     9d0:	10 c0       	rjmp	.+32     	; 0x9f2 <DF_Manufacturer_and_Device_ID+0x46>
  {
    ID[i] = SPI_Transfer(0);
     9d2:	89 81       	ldd	r24, Y+1	; 0x01
     9d4:	28 2f       	mov	r18, r24
     9d6:	30 e0       	ldi	r19, 0x00	; 0
     9d8:	8a 81       	ldd	r24, Y+2	; 0x02
     9da:	9b 81       	ldd	r25, Y+3	; 0x03
     9dc:	8c 01       	movw	r16, r24
     9de:	02 0f       	add	r16, r18
     9e0:	13 1f       	adc	r17, r19
     9e2:	80 e0       	ldi	r24, 0x00	; 0
     9e4:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     9e8:	f8 01       	movw	r30, r16
     9ea:	80 83       	st	Z, r24

  Enable_DFLASH();

  SPI_Transfer(Device_ID_Opcode);

  for(i=0;i<4;i++)
     9ec:	89 81       	ldd	r24, Y+1	; 0x01
     9ee:	8f 5f       	subi	r24, 0xFF	; 255
     9f0:	89 83       	std	Y+1, r24	; 0x01
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	84 30       	cpi	r24, 0x04	; 4
     9f6:	68 f3       	brcs	.-38     	; 0x9d2 <DF_Manufacturer_and_Device_ID+0x26>
  {
    ID[i] = SPI_Transfer(0);
  }

  Disable_DFLASH();
     9f8:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     9fc:	0f 90       	pop	r0
     9fe:	0f 90       	pop	r0
     a00:	0f 90       	pop	r0
     a02:	cf 91       	pop	r28
     a04:	df 91       	pop	r29
     a06:	1f 91       	pop	r17
     a08:	0f 91       	pop	r16
     a0a:	08 95       	ret

00000a0c <DF_Deep_Power_Down>:

/************************************************************
*使FLASH进入Deep_Power_Down
************************************************************/
void DF_Deep_Power_Down(void)
{
     a0c:	df 93       	push	r29
     a0e:	cf 93       	push	r28
     a10:	cd b7       	in	r28, 0x3d	; 61
     a12:	de b7       	in	r29, 0x3e	; 62
  DF_Check_Busy_State();
     a14:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     a18:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  SPI_Transfer(0xB9);//写Deep Power-down操作码
     a1c:	89 eb       	ldi	r24, 0xB9	; 185
     a1e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  Disable_DFLASH();
     a22:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     a26:	cf 91       	pop	r28
     a28:	df 91       	pop	r29
     a2a:	08 95       	ret

00000a2c <DF_Resume_from_Deep_Power_Down>:
/************************************************************
*使FLASH退出Deep_Power_Down
************************************************************/
void DF_Resume_from_Deep_Power_Down(void)
{
     a2c:	df 93       	push	r29
     a2e:	cf 93       	push	r28
     a30:	cd b7       	in	r28, 0x3d	; 61
     a32:	de b7       	in	r29, 0x3e	; 62
  DF_Check_Busy_State();
     a34:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     a38:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  SPI_Transfer(0xAB);//写Resume from Deep Power-down操作码
     a3c:	8b ea       	ldi	r24, 0xAB	; 171
     a3e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  Disable_DFLASH();
     a42:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     a46:	cf 91       	pop	r28
     a48:	df 91       	pop	r29
     a4a:	08 95       	ret

00000a4c <DF_Enable_Sector_Protection>:
/************************************************************
*使能扇区保护
************************************************************/
void DF_Enable_Sector_Protection(void)
{
     a4c:	df 93       	push	r29
     a4e:	cf 93       	push	r28
     a50:	00 d0       	rcall	.+0      	; 0xa52 <DF_Enable_Sector_Protection+0x6>
     a52:	00 d0       	rcall	.+0      	; 0xa54 <DF_Enable_Sector_Protection+0x8>
     a54:	0f 92       	push	r0
     a56:	cd b7       	in	r28, 0x3d	; 61
     a58:	de b7       	in	r29, 0x3e	; 62
  unsigned char Enable_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0xA9}; //使能扇区保护操作码
     a5a:	8d e3       	ldi	r24, 0x3D	; 61
     a5c:	8a 83       	std	Y+2, r24	; 0x02
     a5e:	8a e2       	ldi	r24, 0x2A	; 42
     a60:	8b 83       	std	Y+3, r24	; 0x03
     a62:	8f e7       	ldi	r24, 0x7F	; 127
     a64:	8c 83       	std	Y+4, r24	; 0x04
     a66:	89 ea       	ldi	r24, 0xA9	; 169
     a68:	8d 83       	std	Y+5, r24	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     a6a:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     a6e:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  for(i=0;i<4;i++)
     a72:	19 82       	std	Y+1, r1	; 0x01
     a74:	0e c0       	rjmp	.+28     	; 0xa92 <DF_Enable_Sector_Protection+0x46>
  {
	  SPI_Transfer(Enable_Sector_Protection_Command[i]);//写使能扇区保护操作码
     a76:	89 81       	ldd	r24, Y+1	; 0x01
     a78:	28 2f       	mov	r18, r24
     a7a:	30 e0       	ldi	r19, 0x00	; 0
     a7c:	ce 01       	movw	r24, r28
     a7e:	02 96       	adiw	r24, 0x02	; 2
     a80:	fc 01       	movw	r30, r24
     a82:	e2 0f       	add	r30, r18
     a84:	f3 1f       	adc	r31, r19
     a86:	80 81       	ld	r24, Z
     a88:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char Enable_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0xA9}; //使能扇区保护操作码
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();
  for(i=0;i<4;i++)
     a8c:	89 81       	ldd	r24, Y+1	; 0x01
     a8e:	8f 5f       	subi	r24, 0xFF	; 255
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	89 81       	ldd	r24, Y+1	; 0x01
     a94:	84 30       	cpi	r24, 0x04	; 4
     a96:	78 f3       	brcs	.-34     	; 0xa76 <DF_Enable_Sector_Protection+0x2a>
  {
	  SPI_Transfer(Enable_Sector_Protection_Command[i]);//写使能扇区保护操作码
  }
  Disable_DFLASH();
     a98:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     a9c:	0f 90       	pop	r0
     a9e:	0f 90       	pop	r0
     aa0:	0f 90       	pop	r0
     aa2:	0f 90       	pop	r0
     aa4:	0f 90       	pop	r0
     aa6:	cf 91       	pop	r28
     aa8:	df 91       	pop	r29
     aaa:	08 95       	ret

00000aac <DF_Disable_Sector_Protection>:
/************************************************************
*禁止扇区保护
************************************************************/
void DF_Disable_Sector_Protection(void)
{
     aac:	df 93       	push	r29
     aae:	cf 93       	push	r28
     ab0:	00 d0       	rcall	.+0      	; 0xab2 <DF_Disable_Sector_Protection+0x6>
     ab2:	00 d0       	rcall	.+0      	; 0xab4 <DF_Disable_Sector_Protection+0x8>
     ab4:	0f 92       	push	r0
     ab6:	cd b7       	in	r28, 0x3d	; 61
     ab8:	de b7       	in	r29, 0x3e	; 62
  unsigned char Disable_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0x9A};//禁止扇区保护操作码
     aba:	8d e3       	ldi	r24, 0x3D	; 61
     abc:	8a 83       	std	Y+2, r24	; 0x02
     abe:	8a e2       	ldi	r24, 0x2A	; 42
     ac0:	8b 83       	std	Y+3, r24	; 0x03
     ac2:	8f e7       	ldi	r24, 0x7F	; 127
     ac4:	8c 83       	std	Y+4, r24	; 0x04
     ac6:	8a e9       	ldi	r24, 0x9A	; 154
     ac8:	8d 83       	std	Y+5, r24	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     aca:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     ace:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  for(i=0;i<4;i++)
     ad2:	19 82       	std	Y+1, r1	; 0x01
     ad4:	0e c0       	rjmp	.+28     	; 0xaf2 <DF_Disable_Sector_Protection+0x46>
  {
      SPI_Transfer(Disable_Sector_Protection_Command[i]);//写禁止扇区保护操作码
     ad6:	89 81       	ldd	r24, Y+1	; 0x01
     ad8:	28 2f       	mov	r18, r24
     ada:	30 e0       	ldi	r19, 0x00	; 0
     adc:	ce 01       	movw	r24, r28
     ade:	02 96       	adiw	r24, 0x02	; 2
     ae0:	fc 01       	movw	r30, r24
     ae2:	e2 0f       	add	r30, r18
     ae4:	f3 1f       	adc	r31, r19
     ae6:	80 81       	ld	r24, Z
     ae8:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char Disable_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0x9A};//禁止扇区保护操作码
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();
  for(i=0;i<4;i++)
     aec:	89 81       	ldd	r24, Y+1	; 0x01
     aee:	8f 5f       	subi	r24, 0xFF	; 255
     af0:	89 83       	std	Y+1, r24	; 0x01
     af2:	89 81       	ldd	r24, Y+1	; 0x01
     af4:	84 30       	cpi	r24, 0x04	; 4
     af6:	78 f3       	brcs	.-34     	; 0xad6 <DF_Disable_Sector_Protection+0x2a>
  {
      SPI_Transfer(Disable_Sector_Protection_Command[i]);//写禁止扇区保护操作码
  }
  Disable_DFLASH();
     af8:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     afc:	0f 90       	pop	r0
     afe:	0f 90       	pop	r0
     b00:	0f 90       	pop	r0
     b02:	0f 90       	pop	r0
     b04:	0f 90       	pop	r0
     b06:	cf 91       	pop	r28
     b08:	df 91       	pop	r29
     b0a:	08 95       	ret

00000b0c <DF_Erase_Sector_Protection_Register>:
/************************************************************
*擦除扇区保护
************************************************************/
void DF_Erase_Sector_Protection_Register(void)
{
     b0c:	df 93       	push	r29
     b0e:	cf 93       	push	r28
     b10:	00 d0       	rcall	.+0      	; 0xb12 <DF_Erase_Sector_Protection_Register+0x6>
     b12:	00 d0       	rcall	.+0      	; 0xb14 <DF_Erase_Sector_Protection_Register+0x8>
     b14:	0f 92       	push	r0
     b16:	cd b7       	in	r28, 0x3d	; 61
     b18:	de b7       	in	r29, 0x3e	; 62
  unsigned char Erase_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0xCF};//擦除扇区保护操作码
     b1a:	8d e3       	ldi	r24, 0x3D	; 61
     b1c:	8a 83       	std	Y+2, r24	; 0x02
     b1e:	8a e2       	ldi	r24, 0x2A	; 42
     b20:	8b 83       	std	Y+3, r24	; 0x03
     b22:	8f e7       	ldi	r24, 0x7F	; 127
     b24:	8c 83       	std	Y+4, r24	; 0x04
     b26:	8f ec       	ldi	r24, 0xCF	; 207
     b28:	8d 83       	std	Y+5, r24	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     b2a:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     b2e:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  for(i=0;i<4;i++)
     b32:	19 82       	std	Y+1, r1	; 0x01
     b34:	0e c0       	rjmp	.+28     	; 0xb52 <DF_Erase_Sector_Protection_Register+0x46>
  {
      SPI_Transfer(Erase_Sector_Protection_Command[i]);//写擦除扇区保护操作码
     b36:	89 81       	ldd	r24, Y+1	; 0x01
     b38:	28 2f       	mov	r18, r24
     b3a:	30 e0       	ldi	r19, 0x00	; 0
     b3c:	ce 01       	movw	r24, r28
     b3e:	02 96       	adiw	r24, 0x02	; 2
     b40:	fc 01       	movw	r30, r24
     b42:	e2 0f       	add	r30, r18
     b44:	f3 1f       	adc	r31, r19
     b46:	80 81       	ld	r24, Z
     b48:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char Erase_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0xCF};//擦除扇区保护操作码
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();
  for(i=0;i<4;i++)
     b4c:	89 81       	ldd	r24, Y+1	; 0x01
     b4e:	8f 5f       	subi	r24, 0xFF	; 255
     b50:	89 83       	std	Y+1, r24	; 0x01
     b52:	89 81       	ldd	r24, Y+1	; 0x01
     b54:	84 30       	cpi	r24, 0x04	; 4
     b56:	78 f3       	brcs	.-34     	; 0xb36 <DF_Erase_Sector_Protection_Register+0x2a>
  {
      SPI_Transfer(Erase_Sector_Protection_Command[i]);//写擦除扇区保护操作码
  }
  Disable_DFLASH();
     b58:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     b5c:	0f 90       	pop	r0
     b5e:	0f 90       	pop	r0
     b60:	0f 90       	pop	r0
     b62:	0f 90       	pop	r0
     b64:	0f 90       	pop	r0
     b66:	cf 91       	pop	r28
     b68:	df 91       	pop	r29
     b6a:	08 95       	ret

00000b6c <DF_Program_Sector_Protection_Register>:
abled. Being able to reprogram the Sector Protection Register with the sector protection enabled
allows the user to temporarily disable the sector protection to an individual sector rather than
disabling sector protection completely
************************************************************/
void DF_Program_Sector_Protection_Register(unsigned char *Sector_Protection_Register)
{
     b6c:	df 93       	push	r29
     b6e:	cf 93       	push	r28
     b70:	cd b7       	in	r28, 0x3d	; 61
     b72:	de b7       	in	r29, 0x3e	; 62
     b74:	27 97       	sbiw	r28, 0x07	; 7
     b76:	0f b6       	in	r0, 0x3f	; 63
     b78:	f8 94       	cli
     b7a:	de bf       	out	0x3e, r29	; 62
     b7c:	0f be       	out	0x3f, r0	; 63
     b7e:	cd bf       	out	0x3d, r28	; 61
     b80:	9f 83       	std	Y+7, r25	; 0x07
     b82:	8e 83       	std	Y+6, r24	; 0x06
  unsigned char Program_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0xFC};//设置扇区保护操作码
     b84:	8d e3       	ldi	r24, 0x3D	; 61
     b86:	8a 83       	std	Y+2, r24	; 0x02
     b88:	8a e2       	ldi	r24, 0x2A	; 42
     b8a:	8b 83       	std	Y+3, r24	; 0x03
     b8c:	8f e7       	ldi	r24, 0x7F	; 127
     b8e:	8c 83       	std	Y+4, r24	; 0x04
     b90:	8c ef       	ldi	r24, 0xFC	; 252
     b92:	8d 83       	std	Y+5, r24	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     b94:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     b98:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>
  for(i=0;i<4;i++)
     b9c:	19 82       	std	Y+1, r1	; 0x01
     b9e:	0e c0       	rjmp	.+28     	; 0xbbc <DF_Program_Sector_Protection_Register+0x50>
  {
      SPI_Transfer(Program_Sector_Protection_Command[i]);//写设置扇区保护操作码
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	28 2f       	mov	r18, r24
     ba4:	30 e0       	ldi	r19, 0x00	; 0
     ba6:	ce 01       	movw	r24, r28
     ba8:	02 96       	adiw	r24, 0x02	; 2
     baa:	fc 01       	movw	r30, r24
     bac:	e2 0f       	add	r30, r18
     bae:	f3 1f       	adc	r31, r19
     bb0:	80 81       	ld	r24, Z
     bb2:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char Program_Sector_Protection_Command[4]={0x3D,0x2A,0x7F,0xFC};//设置扇区保护操作码
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();
  for(i=0;i<4;i++)
     bb6:	89 81       	ldd	r24, Y+1	; 0x01
     bb8:	8f 5f       	subi	r24, 0xFF	; 255
     bba:	89 83       	std	Y+1, r24	; 0x01
     bbc:	89 81       	ldd	r24, Y+1	; 0x01
     bbe:	84 30       	cpi	r24, 0x04	; 4
     bc0:	78 f3       	brcs	.-34     	; 0xba0 <DF_Program_Sector_Protection_Register+0x34>
  {
      SPI_Transfer(Program_Sector_Protection_Command[i]);//写设置扇区保护操作码
  }
  for(i=0;i<8;i++)
     bc2:	19 82       	std	Y+1, r1	; 0x01
     bc4:	0e c0       	rjmp	.+28     	; 0xbe2 <DF_Program_Sector_Protection_Register+0x76>
  {
      SPI_Transfer(Sector_Protection_Register[i]);//写设置扇区保护数据
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	28 2f       	mov	r18, r24
     bca:	30 e0       	ldi	r19, 0x00	; 0
     bcc:	8e 81       	ldd	r24, Y+6	; 0x06
     bce:	9f 81       	ldd	r25, Y+7	; 0x07
     bd0:	fc 01       	movw	r30, r24
     bd2:	e2 0f       	add	r30, r18
     bd4:	f3 1f       	adc	r31, r19
     bd6:	80 81       	ld	r24, Z
     bd8:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  Enable_DFLASH();
  for(i=0;i<4;i++)
  {
      SPI_Transfer(Program_Sector_Protection_Command[i]);//写设置扇区保护操作码
  }
  for(i=0;i<8;i++)
     bdc:	89 81       	ldd	r24, Y+1	; 0x01
     bde:	8f 5f       	subi	r24, 0xFF	; 255
     be0:	89 83       	std	Y+1, r24	; 0x01
     be2:	89 81       	ldd	r24, Y+1	; 0x01
     be4:	88 30       	cpi	r24, 0x08	; 8
     be6:	78 f3       	brcs	.-34     	; 0xbc6 <DF_Program_Sector_Protection_Register+0x5a>
  {
      SPI_Transfer(Sector_Protection_Register[i]);//写设置扇区保护数据
  }
  Disable_DFLASH();
     be8:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     bec:	27 96       	adiw	r28, 0x07	; 7
     bee:	0f b6       	in	r0, 0x3f	; 63
     bf0:	f8 94       	cli
     bf2:	de bf       	out	0x3e, r29	; 62
     bf4:	0f be       	out	0x3f, r0	; 63
     bf6:	cd bf       	out	0x3d, r28	; 61
     bf8:	cf 91       	pop	r28
     bfa:	df 91       	pop	r29
     bfc:	08 95       	ret

00000bfe <DF_Read_Sector_Protection_Register>:
----------------   See PDF  -----------
|Unprotected   |            | 00H	  |
---------------------------------------
************************************************************/
void DF_Read_Sector_Protection_Register(unsigned char *Sector_Protection_Register)
{
     bfe:	0f 93       	push	r16
     c00:	1f 93       	push	r17
     c02:	df 93       	push	r29
     c04:	cf 93       	push	r28
     c06:	cd b7       	in	r28, 0x3d	; 61
     c08:	de b7       	in	r29, 0x3e	; 62
     c0a:	27 97       	sbiw	r28, 0x07	; 7
     c0c:	0f b6       	in	r0, 0x3f	; 63
     c0e:	f8 94       	cli
     c10:	de bf       	out	0x3e, r29	; 62
     c12:	0f be       	out	0x3f, r0	; 63
     c14:	cd bf       	out	0x3d, r28	; 61
     c16:	9f 83       	std	Y+7, r25	; 0x07
     c18:	8e 83       	std	Y+6, r24	; 0x06
  unsigned char Read_Sector_Protection_Register_Command[4]={0x32,0,0,0};
     c1a:	82 e3       	ldi	r24, 0x32	; 50
     c1c:	8a 83       	std	Y+2, r24	; 0x02
     c1e:	1b 82       	std	Y+3, r1	; 0x03
     c20:	1c 82       	std	Y+4, r1	; 0x04
     c22:	1d 82       	std	Y+5, r1	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     c24:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     c28:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  for(i=0;i<4;i++)//write
     c2c:	19 82       	std	Y+1, r1	; 0x01
     c2e:	0e c0       	rjmp	.+28     	; 0xc4c <DF_Read_Sector_Protection_Register+0x4e>
  {
    SPI_Transfer(Read_Sector_Protection_Register_Command[i]);
     c30:	89 81       	ldd	r24, Y+1	; 0x01
     c32:	28 2f       	mov	r18, r24
     c34:	30 e0       	ldi	r19, 0x00	; 0
     c36:	ce 01       	movw	r24, r28
     c38:	02 96       	adiw	r24, 0x02	; 2
     c3a:	fc 01       	movw	r30, r24
     c3c:	e2 0f       	add	r30, r18
     c3e:	f3 1f       	adc	r31, r19
     c40:	80 81       	ld	r24, Z
     c42:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();

  for(i=0;i<4;i++)//write
     c46:	89 81       	ldd	r24, Y+1	; 0x01
     c48:	8f 5f       	subi	r24, 0xFF	; 255
     c4a:	89 83       	std	Y+1, r24	; 0x01
     c4c:	89 81       	ldd	r24, Y+1	; 0x01
     c4e:	84 30       	cpi	r24, 0x04	; 4
     c50:	78 f3       	brcs	.-34     	; 0xc30 <DF_Read_Sector_Protection_Register+0x32>
  {
    SPI_Transfer(Read_Sector_Protection_Register_Command[i]);
  }
  for(i=0;i<8;i++)//read
     c52:	19 82       	std	Y+1, r1	; 0x01
     c54:	10 c0       	rjmp	.+32     	; 0xc76 <DF_Read_Sector_Protection_Register+0x78>
  {
    Sector_Protection_Register[i] = SPI_Transfer(0);
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	28 2f       	mov	r18, r24
     c5a:	30 e0       	ldi	r19, 0x00	; 0
     c5c:	8e 81       	ldd	r24, Y+6	; 0x06
     c5e:	9f 81       	ldd	r25, Y+7	; 0x07
     c60:	8c 01       	movw	r16, r24
     c62:	02 0f       	add	r16, r18
     c64:	13 1f       	adc	r17, r19
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     c6c:	f8 01       	movw	r30, r16
     c6e:	80 83       	st	Z, r24

  for(i=0;i<4;i++)//write
  {
    SPI_Transfer(Read_Sector_Protection_Register_Command[i]);
  }
  for(i=0;i<8;i++)//read
     c70:	89 81       	ldd	r24, Y+1	; 0x01
     c72:	8f 5f       	subi	r24, 0xFF	; 255
     c74:	89 83       	std	Y+1, r24	; 0x01
     c76:	89 81       	ldd	r24, Y+1	; 0x01
     c78:	88 30       	cpi	r24, 0x08	; 8
     c7a:	68 f3       	brcs	.-38     	; 0xc56 <DF_Read_Sector_Protection_Register+0x58>
  {
    Sector_Protection_Register[i] = SPI_Transfer(0);
  }
  Disable_DFLASH();
     c7c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     c80:	27 96       	adiw	r28, 0x07	; 7
     c82:	0f b6       	in	r0, 0x3f	; 63
     c84:	f8 94       	cli
     c86:	de bf       	out	0x3e, r29	; 62
     c88:	0f be       	out	0x3f, r0	; 63
     c8a:	cd bf       	out	0x3d, r28	; 61
     c8c:	cf 91       	pop	r28
     c8e:	df 91       	pop	r29
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	08 95       	ret

00000c96 <DF_Cancel_Sector_Protection>:
/************************************************************
*取消所有扇区保护
*返回1表示成功取消扇区所以保护
************************************************************/
unsigned char DF_Cancel_Sector_Protection(void)
{
     c96:	df 93       	push	r29
     c98:	cf 93       	push	r28
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
     c9e:	68 97       	sbiw	r28, 0x18	; 24
     ca0:	0f b6       	in	r0, 0x3f	; 63
     ca2:	f8 94       	cli
     ca4:	de bf       	out	0x3e, r29	; 62
     ca6:	0f be       	out	0x3f, r0	; 63
     ca8:	cd bf       	out	0x3d, r28	; 61
  unsigned char Sector_Protection_Register_for_Write[8]={0,0,0,0,0,0,0,0};//写入0为去保护
     caa:	88 e0       	ldi	r24, 0x08	; 8
     cac:	fe 01       	movw	r30, r28
     cae:	34 96       	adiw	r30, 0x04	; 4
     cb0:	df 01       	movw	r26, r30
     cb2:	98 2f       	mov	r25, r24
     cb4:	1d 92       	st	X+, r1
     cb6:	9a 95       	dec	r25
     cb8:	e9 f7       	brne	.-6      	; 0xcb4 <DF_Cancel_Sector_Protection+0x1e>
  unsigned char Sector_Protection_Register_for_Read[8]={1,1,1,1,1,1,1,1};//防止默认值为0
     cba:	de 01       	movw	r26, r28
     cbc:	1c 96       	adiw	r26, 0x0c	; 12
     cbe:	bd 8b       	std	Y+21, r27	; 0x15
     cc0:	ac 8b       	std	Y+20, r26	; 0x14
     cc2:	e7 e1       	ldi	r30, 0x17	; 23
     cc4:	f1 e0       	ldi	r31, 0x01	; 1
     cc6:	ff 8b       	std	Y+23, r31	; 0x17
     cc8:	ee 8b       	std	Y+22, r30	; 0x16
     cca:	f8 e0       	ldi	r31, 0x08	; 8
     ccc:	f8 8f       	std	Y+24, r31	; 0x18
     cce:	ae 89       	ldd	r26, Y+22	; 0x16
     cd0:	bf 89       	ldd	r27, Y+23	; 0x17
     cd2:	0c 90       	ld	r0, X
     cd4:	ee 89       	ldd	r30, Y+22	; 0x16
     cd6:	ff 89       	ldd	r31, Y+23	; 0x17
     cd8:	31 96       	adiw	r30, 0x01	; 1
     cda:	ff 8b       	std	Y+23, r31	; 0x17
     cdc:	ee 8b       	std	Y+22, r30	; 0x16
     cde:	ac 89       	ldd	r26, Y+20	; 0x14
     ce0:	bd 89       	ldd	r27, Y+21	; 0x15
     ce2:	0c 92       	st	X, r0
     ce4:	ec 89       	ldd	r30, Y+20	; 0x14
     ce6:	fd 89       	ldd	r31, Y+21	; 0x15
     ce8:	31 96       	adiw	r30, 0x01	; 1
     cea:	fd 8b       	std	Y+21, r31	; 0x15
     cec:	ec 8b       	std	Y+20, r30	; 0x14
     cee:	f8 8d       	ldd	r31, Y+24	; 0x18
     cf0:	f1 50       	subi	r31, 0x01	; 1
     cf2:	f8 8f       	std	Y+24, r31	; 0x18
     cf4:	88 8d       	ldd	r24, Y+24	; 0x18
     cf6:	88 23       	and	r24, r24
     cf8:	51 f7       	brne	.-44     	; 0xcce <DF_Cancel_Sector_Protection+0x38>
  unsigned int i;
  unsigned char j=1;
     cfa:	81 e0       	ldi	r24, 0x01	; 1
     cfc:	89 83       	std	Y+1, r24	; 0x01
  //使能扇区保护
  DF_Enable_Sector_Protection();
     cfe:	0e 94 26 05 	call	0xa4c	; 0xa4c <DF_Enable_Sector_Protection>
  //设置扇区保护

  DF_Program_Sector_Protection_Register(Sector_Protection_Register_for_Write);
     d02:	ce 01       	movw	r24, r28
     d04:	04 96       	adiw	r24, 0x04	; 4
     d06:	0e 94 b6 05 	call	0xb6c	; 0xb6c <DF_Program_Sector_Protection_Register>
  //读取扇区保护寄存器内容
  DF_Read_Sector_Protection_Register(Sector_Protection_Register_for_Read);
     d0a:	ce 01       	movw	r24, r28
     d0c:	0c 96       	adiw	r24, 0x0c	; 12
     d0e:	0e 94 ff 05 	call	0xbfe	; 0xbfe <DF_Read_Sector_Protection_Register>
  //判断扇区保护寄存器内容
  for(i=0;i<8;i++)
     d12:	1b 82       	std	Y+3, r1	; 0x03
     d14:	1a 82       	std	Y+2, r1	; 0x02
     d16:	12 c0       	rjmp	.+36     	; 0xd3c <DF_Cancel_Sector_Protection+0xa6>
  {
    if(Sector_Protection_Register_for_Read[i]!=0) j++;
     d18:	2a 81       	ldd	r18, Y+2	; 0x02
     d1a:	3b 81       	ldd	r19, Y+3	; 0x03
     d1c:	ce 01       	movw	r24, r28
     d1e:	0c 96       	adiw	r24, 0x0c	; 12
     d20:	fc 01       	movw	r30, r24
     d22:	e2 0f       	add	r30, r18
     d24:	f3 1f       	adc	r31, r19
     d26:	80 81       	ld	r24, Z
     d28:	88 23       	and	r24, r24
     d2a:	19 f0       	breq	.+6      	; 0xd32 <DF_Cancel_Sector_Protection+0x9c>
     d2c:	89 81       	ldd	r24, Y+1	; 0x01
     d2e:	8f 5f       	subi	r24, 0xFF	; 255
     d30:	89 83       	std	Y+1, r24	; 0x01

  DF_Program_Sector_Protection_Register(Sector_Protection_Register_for_Write);
  //读取扇区保护寄存器内容
  DF_Read_Sector_Protection_Register(Sector_Protection_Register_for_Read);
  //判断扇区保护寄存器内容
  for(i=0;i<8;i++)
     d32:	8a 81       	ldd	r24, Y+2	; 0x02
     d34:	9b 81       	ldd	r25, Y+3	; 0x03
     d36:	01 96       	adiw	r24, 0x01	; 1
     d38:	9b 83       	std	Y+3, r25	; 0x03
     d3a:	8a 83       	std	Y+2, r24	; 0x02
     d3c:	8a 81       	ldd	r24, Y+2	; 0x02
     d3e:	9b 81       	ldd	r25, Y+3	; 0x03
     d40:	88 30       	cpi	r24, 0x08	; 8
     d42:	91 05       	cpc	r25, r1
     d44:	48 f3       	brcs	.-46     	; 0xd18 <DF_Cancel_Sector_Protection+0x82>
  {
    if(Sector_Protection_Register_for_Read[i]!=0) j++;
  }
  //禁止扇区保护
  DF_Disable_Sector_Protection();
     d46:	0e 94 56 05 	call	0xaac	; 0xaac <DF_Disable_Sector_Protection>

  return j;
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d4c:	68 96       	adiw	r28, 0x18	; 24
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	cf 91       	pop	r28
     d5a:	df 91       	pop	r29
     d5c:	08 95       	ret

00000d5e <DF_Program_Sector_Lockdown>:
*被设置的扇区就只能读不能写
*非一般情况不要使用(除非数据不用再改)
*Sector_Addr :地址在哪个扇区中就会锁上那个扇区
************************************************************/
void DF_Program_Sector_Lockdown(unsigned long Sector_Addr)
{
     d5e:	df 93       	push	r29
     d60:	cf 93       	push	r28
     d62:	cd b7       	in	r28, 0x3d	; 61
     d64:	de b7       	in	r29, 0x3e	; 62
     d66:	29 97       	sbiw	r28, 0x09	; 9
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	6e 83       	std	Y+6, r22	; 0x06
     d74:	7f 83       	std	Y+7, r23	; 0x07
     d76:	88 87       	std	Y+8, r24	; 0x08
     d78:	99 87       	std	Y+9, r25	; 0x09
  //unsigned char Sector_Lockdown_Command=[4]={0x3D,0x2A,0x7F,0x30};//加锁操作码
  unsigned char Sector_Lockdown_Command[4]={0x00,0x00,0x00,0x00};//防止写到,这里乱写
     d7a:	1a 82       	std	Y+2, r1	; 0x02
     d7c:	1b 82       	std	Y+3, r1	; 0x03
     d7e:	1c 82       	std	Y+4, r1	; 0x04
     d80:	1d 82       	std	Y+5, r1	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     d82:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     d86:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  for(i=0;i<4;i++)//write
     d8a:	19 82       	std	Y+1, r1	; 0x01
     d8c:	0e c0       	rjmp	.+28     	; 0xdaa <DF_Program_Sector_Lockdown+0x4c>
  {
    SPI_Transfer(Sector_Lockdown_Command[i]);
     d8e:	89 81       	ldd	r24, Y+1	; 0x01
     d90:	28 2f       	mov	r18, r24
     d92:	30 e0       	ldi	r19, 0x00	; 0
     d94:	ce 01       	movw	r24, r28
     d96:	02 96       	adiw	r24, 0x02	; 2
     d98:	fc 01       	movw	r30, r24
     d9a:	e2 0f       	add	r30, r18
     d9c:	f3 1f       	adc	r31, r19
     d9e:	80 81       	ld	r24, Z
     da0:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();

  for(i=0;i<4;i++)//write
     da4:	89 81       	ldd	r24, Y+1	; 0x01
     da6:	8f 5f       	subi	r24, 0xFF	; 255
     da8:	89 83       	std	Y+1, r24	; 0x01
     daa:	89 81       	ldd	r24, Y+1	; 0x01
     dac:	84 30       	cpi	r24, 0x04	; 4
     dae:	78 f3       	brcs	.-34     	; 0xd8e <DF_Program_Sector_Lockdown+0x30>
  {
    SPI_Transfer(Sector_Lockdown_Command[i]);
  }

  //write address
  SPI_Transfer((unsigned char)(Sector_Addr>>16));
     db0:	8e 81       	ldd	r24, Y+6	; 0x06
     db2:	9f 81       	ldd	r25, Y+7	; 0x07
     db4:	a8 85       	ldd	r26, Y+8	; 0x08
     db6:	b9 85       	ldd	r27, Y+9	; 0x09
     db8:	cd 01       	movw	r24, r26
     dba:	aa 27       	eor	r26, r26
     dbc:	bb 27       	eor	r27, r27
     dbe:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)(Sector_Addr>>8));
     dc2:	8e 81       	ldd	r24, Y+6	; 0x06
     dc4:	9f 81       	ldd	r25, Y+7	; 0x07
     dc6:	a8 85       	ldd	r26, Y+8	; 0x08
     dc8:	b9 85       	ldd	r27, Y+9	; 0x09
     dca:	89 2f       	mov	r24, r25
     dcc:	9a 2f       	mov	r25, r26
     dce:	ab 2f       	mov	r26, r27
     dd0:	bb 27       	eor	r27, r27
     dd2:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)Sector_Addr);
     dd6:	8e 81       	ldd	r24, Y+6	; 0x06
     dd8:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  Disable_DFLASH();
     ddc:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     de0:	29 96       	adiw	r28, 0x09	; 9
     de2:	0f b6       	in	r0, 0x3f	; 63
     de4:	f8 94       	cli
     de6:	de bf       	out	0x3e, r29	; 62
     de8:	0f be       	out	0x3f, r0	; 63
     dea:	cd bf       	out	0x3d, r28	; 61
     dec:	cf 91       	pop	r28
     dee:	df 91       	pop	r29
     df0:	08 95       	ret

00000df2 <DF_Read_Sector_Lockdown_Register>:
*读取扇区加锁寄存器(返回8个扇区的加锁寄存器值)
*如果有读到不为0的表示已被加锁
*(0扇区的高四位为0也表示没加锁,其它扇区一定要全为O)
************************************************************/
void DF_Read_Sector_Lockdown_Register(unsigned char *Sector_Lockdown_Register)
{
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	cd b7       	in	r28, 0x3d	; 61
     dfc:	de b7       	in	r29, 0x3e	; 62
     dfe:	27 97       	sbiw	r28, 0x07	; 7
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	de bf       	out	0x3e, r29	; 62
     e06:	0f be       	out	0x3f, r0	; 63
     e08:	cd bf       	out	0x3d, r28	; 61
     e0a:	9f 83       	std	Y+7, r25	; 0x07
     e0c:	8e 83       	std	Y+6, r24	; 0x06
  unsigned char Read_Sector_Lockdown_Register[4]={0x35,0x00,0x00,0x00};
     e0e:	85 e3       	ldi	r24, 0x35	; 53
     e10:	8a 83       	std	Y+2, r24	; 0x02
     e12:	1b 82       	std	Y+3, r1	; 0x03
     e14:	1c 82       	std	Y+4, r1	; 0x04
     e16:	1d 82       	std	Y+5, r1	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
     e18:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
     e1c:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  for(i=0;i<4;i++)//write
     e20:	19 82       	std	Y+1, r1	; 0x01
     e22:	0e c0       	rjmp	.+28     	; 0xe40 <DF_Read_Sector_Lockdown_Register+0x4e>
  {
    SPI_Transfer(Read_Sector_Lockdown_Register[i]);
     e24:	89 81       	ldd	r24, Y+1	; 0x01
     e26:	28 2f       	mov	r18, r24
     e28:	30 e0       	ldi	r19, 0x00	; 0
     e2a:	ce 01       	movw	r24, r28
     e2c:	02 96       	adiw	r24, 0x02	; 2
     e2e:	fc 01       	movw	r30, r24
     e30:	e2 0f       	add	r30, r18
     e32:	f3 1f       	adc	r31, r19
     e34:	80 81       	ld	r24, Z
     e36:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();

  for(i=0;i<4;i++)//write
     e3a:	89 81       	ldd	r24, Y+1	; 0x01
     e3c:	8f 5f       	subi	r24, 0xFF	; 255
     e3e:	89 83       	std	Y+1, r24	; 0x01
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	84 30       	cpi	r24, 0x04	; 4
     e44:	78 f3       	brcs	.-34     	; 0xe24 <DF_Read_Sector_Lockdown_Register+0x32>
  {
    SPI_Transfer(Read_Sector_Lockdown_Register[i]);
  }
  for(i=0;i<8;i++)//read
     e46:	19 82       	std	Y+1, r1	; 0x01
     e48:	10 c0       	rjmp	.+32     	; 0xe6a <DF_Read_Sector_Lockdown_Register+0x78>
  {
    Sector_Lockdown_Register[i] = SPI_Transfer(0);
     e4a:	89 81       	ldd	r24, Y+1	; 0x01
     e4c:	28 2f       	mov	r18, r24
     e4e:	30 e0       	ldi	r19, 0x00	; 0
     e50:	8e 81       	ldd	r24, Y+6	; 0x06
     e52:	9f 81       	ldd	r25, Y+7	; 0x07
     e54:	8c 01       	movw	r16, r24
     e56:	02 0f       	add	r16, r18
     e58:	13 1f       	adc	r17, r19
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     e60:	f8 01       	movw	r30, r16
     e62:	80 83       	st	Z, r24

  for(i=0;i<4;i++)//write
  {
    SPI_Transfer(Read_Sector_Lockdown_Register[i]);
  }
  for(i=0;i<8;i++)//read
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	8f 5f       	subi	r24, 0xFF	; 255
     e68:	89 83       	std	Y+1, r24	; 0x01
     e6a:	89 81       	ldd	r24, Y+1	; 0x01
     e6c:	88 30       	cpi	r24, 0x08	; 8
     e6e:	68 f3       	brcs	.-38     	; 0xe4a <DF_Read_Sector_Lockdown_Register+0x58>
  {
    Sector_Lockdown_Register[i] = SPI_Transfer(0);
  }
  Disable_DFLASH();
     e70:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     e74:	27 96       	adiw	r28, 0x07	; 7
     e76:	0f b6       	in	r0, 0x3f	; 63
     e78:	f8 94       	cli
     e7a:	de bf       	out	0x3e, r29	; 62
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	cd bf       	out	0x3d, r28	; 61
     e80:	cf 91       	pop	r28
     e82:	df 91       	pop	r29
     e84:	1f 91       	pop	r17
     e86:	0f 91       	pop	r16
     e88:	08 95       	ret

00000e8a <DF_Write_to_Buffer>:
*wData     :要写入的数据
*wDataSize :要写入的数据长度(1~264)
************************************************************/
void DF_Write_to_Buffer(unsigned char BufferX,unsigned int BFA,
                        unsigned char *wData,unsigned int wDataSize)
{
     e8a:	df 93       	push	r29
     e8c:	cf 93       	push	r28
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	29 97       	sbiw	r28, 0x09	; 9
     e94:	0f b6       	in	r0, 0x3f	; 63
     e96:	f8 94       	cli
     e98:	de bf       	out	0x3e, r29	; 62
     e9a:	0f be       	out	0x3f, r0	; 63
     e9c:	cd bf       	out	0x3d, r28	; 61
     e9e:	8b 83       	std	Y+3, r24	; 0x03
     ea0:	7d 83       	std	Y+5, r23	; 0x05
     ea2:	6c 83       	std	Y+4, r22	; 0x04
     ea4:	5f 83       	std	Y+7, r21	; 0x07
     ea6:	4e 83       	std	Y+6, r20	; 0x06
     ea8:	39 87       	std	Y+9, r19	; 0x09
     eaa:	28 87       	std	Y+8, r18	; 0x08
  unsigned int i;

  DF_Check_Busy_State();            //check busy bit
     eac:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
     eb0:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  if(BufferX == Buffer1)  SPI_Transfer(Write_Data_to_Buffer1);//0x84
     eb4:	8b 81       	ldd	r24, Y+3	; 0x03
     eb6:	81 30       	cpi	r24, 0x01	; 1
     eb8:	21 f4       	brne	.+8      	; 0xec2 <DF_Write_to_Buffer+0x38>
     eba:	84 e8       	ldi	r24, 0x84	; 132
     ebc:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     ec0:	03 c0       	rjmp	.+6      	; 0xec8 <DF_Write_to_Buffer+0x3e>
  else                    SPI_Transfer(Write_Data_to_Buffer2);//0x87
     ec2:	87 e8       	ldi	r24, 0x87	; 135
     ec4:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //Page Size (264 Bytes)
  //15 don't care bits + 9 addrress
  SPI_Transfer(0xFF);                      //8 can't care bits
     ec8:	8f ef       	ldi	r24, 0xFF	; 255
     eca:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)(BFA>>8));   //7 can't care bits + 1 bit address
     ece:	8c 81       	ldd	r24, Y+4	; 0x04
     ed0:	9d 81       	ldd	r25, Y+5	; 0x05
     ed2:	89 2f       	mov	r24, r25
     ed4:	99 27       	eor	r25, r25
     ed6:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)BFA);        //address
     eda:	8c 81       	ldd	r24, Y+4	; 0x04
     edc:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  for(i=0;i<wDataSize;i++)  SPI_Transfer(wData[i]);//写入数据
     ee0:	1a 82       	std	Y+2, r1	; 0x02
     ee2:	19 82       	std	Y+1, r1	; 0x01
     ee4:	0f c0       	rjmp	.+30     	; 0xf04 <DF_Write_to_Buffer+0x7a>
     ee6:	2e 81       	ldd	r18, Y+6	; 0x06
     ee8:	3f 81       	ldd	r19, Y+7	; 0x07
     eea:	89 81       	ldd	r24, Y+1	; 0x01
     eec:	9a 81       	ldd	r25, Y+2	; 0x02
     eee:	f9 01       	movw	r30, r18
     ef0:	e8 0f       	add	r30, r24
     ef2:	f9 1f       	adc	r31, r25
     ef4:	80 81       	ld	r24, Z
     ef6:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     efa:	89 81       	ldd	r24, Y+1	; 0x01
     efc:	9a 81       	ldd	r25, Y+2	; 0x02
     efe:	01 96       	adiw	r24, 0x01	; 1
     f00:	9a 83       	std	Y+2, r25	; 0x02
     f02:	89 83       	std	Y+1, r24	; 0x01
     f04:	29 81       	ldd	r18, Y+1	; 0x01
     f06:	3a 81       	ldd	r19, Y+2	; 0x02
     f08:	88 85       	ldd	r24, Y+8	; 0x08
     f0a:	99 85       	ldd	r25, Y+9	; 0x09
     f0c:	28 17       	cp	r18, r24
     f0e:	39 07       	cpc	r19, r25
     f10:	50 f3       	brcs	.-44     	; 0xee6 <DF_Write_to_Buffer+0x5c>

  Disable_DFLASH();
     f12:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     f16:	29 96       	adiw	r28, 0x09	; 9
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	f8 94       	cli
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	0f be       	out	0x3f, r0	; 63
     f20:	cd bf       	out	0x3d, r28	; 61
     f22:	cf 91       	pop	r28
     f24:	df 91       	pop	r29
     f26:	08 95       	ret

00000f28 <DF_Read_from_Buffer>:
*wDataSize :要写入的数据长度(1~264)
*注意:高速和低速发的操作码和要发送的数据长度不同
************************************************************/
void DF_Read_from_Buffer(unsigned char BufferX,unsigned int BFA,
                         unsigned char *rData,unsigned int rDataLen)
{
     f28:	0f 93       	push	r16
     f2a:	1f 93       	push	r17
     f2c:	df 93       	push	r29
     f2e:	cf 93       	push	r28
     f30:	cd b7       	in	r28, 0x3d	; 61
     f32:	de b7       	in	r29, 0x3e	; 62
     f34:	29 97       	sbiw	r28, 0x09	; 9
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	f8 94       	cli
     f3a:	de bf       	out	0x3e, r29	; 62
     f3c:	0f be       	out	0x3f, r0	; 63
     f3e:	cd bf       	out	0x3d, r28	; 61
     f40:	8b 83       	std	Y+3, r24	; 0x03
     f42:	7d 83       	std	Y+5, r23	; 0x05
     f44:	6c 83       	std	Y+4, r22	; 0x04
     f46:	5f 83       	std	Y+7, r21	; 0x07
     f48:	4e 83       	std	Y+6, r20	; 0x06
     f4a:	39 87       	std	Y+9, r19	; 0x09
     f4c:	28 87       	std	Y+8, r18	; 0x08
  unsigned int i;

  DF_Check_Busy_State();            //check busy bit
     f4e:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
     f52:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  if(BufferX == Buffer1)  SPI_Transfer(Read_Data_from_Buffer1);//0xD4 or 0xD1(lower frequency)
     f56:	8b 81       	ldd	r24, Y+3	; 0x03
     f58:	81 30       	cpi	r24, 0x01	; 1
     f5a:	21 f4       	brne	.+8      	; 0xf64 <DF_Read_from_Buffer+0x3c>
     f5c:	84 ed       	ldi	r24, 0xD4	; 212
     f5e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     f62:	03 c0       	rjmp	.+6      	; 0xf6a <DF_Read_from_Buffer+0x42>
  else                    SPI_Transfer(Read_Data_from_Buffer2);//0xD6 or 0xD3(lower frequency)
     f64:	86 ed       	ldi	r24, 0xD6	; 214
     f66:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //Page Size (264 Bytes)
  //15 don't care bits + 9 addrress
  SPI_Transfer(0xFF);                      //8 can't care bits
     f6a:	8f ef       	ldi	r24, 0xFF	; 255
     f6c:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)(BFA>>8));   //7 can't care bits
     f70:	8c 81       	ldd	r24, Y+4	; 0x04
     f72:	9d 81       	ldd	r25, Y+5	; 0x05
     f74:	89 2f       	mov	r24, r25
     f76:	99 27       	eor	r25, r25
     f78:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)BFA);        //address
     f7c:	8c 81       	ldd	r24, Y+4	; 0x04
     f7e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer(0xFF);       				 //1 can't care byte (lower frequency 不用这个字节)
     f82:	8f ef       	ldi	r24, 0xFF	; 255
     f84:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  for(i=0;i<rDataLen;i++)  rData[i] = SPI_Transfer(0xFF);//读取数据
     f88:	1a 82       	std	Y+2, r1	; 0x02
     f8a:	19 82       	std	Y+1, r1	; 0x01
     f8c:	11 c0       	rjmp	.+34     	; 0xfb0 <DF_Read_from_Buffer+0x88>
     f8e:	2e 81       	ldd	r18, Y+6	; 0x06
     f90:	3f 81       	ldd	r19, Y+7	; 0x07
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	89 01       	movw	r16, r18
     f98:	08 0f       	add	r16, r24
     f9a:	19 1f       	adc	r17, r25
     f9c:	8f ef       	ldi	r24, 0xFF	; 255
     f9e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     fa2:	f8 01       	movw	r30, r16
     fa4:	80 83       	st	Z, r24
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	9a 81       	ldd	r25, Y+2	; 0x02
     faa:	01 96       	adiw	r24, 0x01	; 1
     fac:	9a 83       	std	Y+2, r25	; 0x02
     fae:	89 83       	std	Y+1, r24	; 0x01
     fb0:	29 81       	ldd	r18, Y+1	; 0x01
     fb2:	3a 81       	ldd	r19, Y+2	; 0x02
     fb4:	88 85       	ldd	r24, Y+8	; 0x08
     fb6:	99 85       	ldd	r25, Y+9	; 0x09
     fb8:	28 17       	cp	r18, r24
     fba:	39 07       	cpc	r19, r25
     fbc:	40 f3       	brcs	.-48     	; 0xf8e <DF_Read_from_Buffer+0x66>

  Disable_DFLASH();
     fbe:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
     fc2:	29 96       	adiw	r28, 0x09	; 9
     fc4:	0f b6       	in	r0, 0x3f	; 63
     fc6:	f8 94       	cli
     fc8:	de bf       	out	0x3e, r29	; 62
     fca:	0f be       	out	0x3f, r0	; 63
     fcc:	cd bf       	out	0x3d, r28	; 61
     fce:	cf 91       	pop	r28
     fd0:	df 91       	pop	r29
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	08 95       	ret

00000fd8 <DF_Write_Buffer_to_Page>:
*先擦除再写数据(硬件支持的带擦除写)
*BufferX   :选择缓冲器(Buffer1或Buffer2)
*PA        :内存中页的地址 0~2047
************************************************************/
void DF_Write_Buffer_to_Page(unsigned char BufferX,unsigned int PA)
{
     fd8:	df 93       	push	r29
     fda:	cf 93       	push	r28
     fdc:	00 d0       	rcall	.+0      	; 0xfde <DF_Write_Buffer_to_Page+0x6>
     fde:	0f 92       	push	r0
     fe0:	cd b7       	in	r28, 0x3d	; 61
     fe2:	de b7       	in	r29, 0x3e	; 62
     fe4:	89 83       	std	Y+1, r24	; 0x01
     fe6:	7b 83       	std	Y+3, r23	; 0x03
     fe8:	6a 83       	std	Y+2, r22	; 0x02
  DF_Check_Busy_State();
     fea:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
     fee:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  if(BufferX == Buffer1)  SPI_Transfer(Write_Buffer1_to_Page_whin_Erase);//0x83
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	81 30       	cpi	r24, 0x01	; 1
     ff6:	21 f4       	brne	.+8      	; 0x1000 <DF_Write_Buffer_to_Page+0x28>
     ff8:	83 e8       	ldi	r24, 0x83	; 131
     ffa:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
     ffe:	03 c0       	rjmp	.+6      	; 0x1006 <DF_Write_Buffer_to_Page+0x2e>
  else                    SPI_Transfer(Write_Buffer2_to_Page_whin_Erase);//0x86
    1000:	86 e8       	ldi	r24, 0x86	; 134
    1002:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //Page Size (264 Bytes)
  //4 don't care bits + 11 address + 9 don't care bits
  SPI_Transfer((unsigned char)(PA>>7));
    1006:	8a 81       	ldd	r24, Y+2	; 0x02
    1008:	9b 81       	ldd	r25, Y+3	; 0x03
    100a:	88 0f       	add	r24, r24
    100c:	89 2f       	mov	r24, r25
    100e:	88 1f       	adc	r24, r24
    1010:	99 0b       	sbc	r25, r25
    1012:	91 95       	neg	r25
    1014:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)(PA<<1));
    1018:	8a 81       	ldd	r24, Y+2	; 0x02
    101a:	88 0f       	add	r24, r24
    101c:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer(0xFF);                         //8 don't care bits
    1020:	8f ef       	ldi	r24, 0xFF	; 255
    1022:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  Disable_DFLASH();
    1026:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
    102a:	0f 90       	pop	r0
    102c:	0f 90       	pop	r0
    102e:	0f 90       	pop	r0
    1030:	cf 91       	pop	r28
    1032:	df 91       	pop	r29
    1034:	08 95       	ret

00001036 <DF_Read_Buffer_from_Page>:
*读取内存的页(整页)的数据到缓冲器(Buffer1或Buffer2)中
*BufferX   :选择缓冲器(Buffer1或Buffer2)
*PA        :内存中页的地址 0~2047
************************************************************/
void DF_Read_Buffer_from_Page(unsigned char BufferX,unsigned int PA)
{
    1036:	df 93       	push	r29
    1038:	cf 93       	push	r28
    103a:	00 d0       	rcall	.+0      	; 0x103c <DF_Read_Buffer_from_Page+0x6>
    103c:	0f 92       	push	r0
    103e:	cd b7       	in	r28, 0x3d	; 61
    1040:	de b7       	in	r29, 0x3e	; 62
    1042:	89 83       	std	Y+1, r24	; 0x01
    1044:	7b 83       	std	Y+3, r23	; 0x03
    1046:	6a 83       	std	Y+2, r22	; 0x02
  DF_Check_Busy_State();
    1048:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
    104c:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  if(BufferX == Buffer1)  SPI_Transfer(Read_Page_to_Buffer1);//0x53
    1050:	89 81       	ldd	r24, Y+1	; 0x01
    1052:	81 30       	cpi	r24, 0x01	; 1
    1054:	21 f4       	brne	.+8      	; 0x105e <DF_Read_Buffer_from_Page+0x28>
    1056:	83 e5       	ldi	r24, 0x53	; 83
    1058:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    105c:	03 c0       	rjmp	.+6      	; 0x1064 <DF_Read_Buffer_from_Page+0x2e>
  else                    SPI_Transfer(Read_Page_to_Buffer2);//0x55
    105e:	85 e5       	ldi	r24, 0x55	; 85
    1060:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //Page Size (264 Bytes)
  //4 don't care bits + 11 address + 9 don't care bits
  SPI_Transfer((unsigned char)(PA>>7));
    1064:	8a 81       	ldd	r24, Y+2	; 0x02
    1066:	9b 81       	ldd	r25, Y+3	; 0x03
    1068:	88 0f       	add	r24, r24
    106a:	89 2f       	mov	r24, r25
    106c:	88 1f       	adc	r24, r24
    106e:	99 0b       	sbc	r25, r25
    1070:	91 95       	neg	r25
    1072:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)(PA<<1));
    1076:	8a 81       	ldd	r24, Y+2	; 0x02
    1078:	88 0f       	add	r24, r24
    107a:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer(0xFF); //8 don't care bits
    107e:	8f ef       	ldi	r24, 0xFF	; 255
    1080:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  Disable_DFLASH();
    1084:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
    1088:	0f 90       	pop	r0
    108a:	0f 90       	pop	r0
    108c:	0f 90       	pop	r0
    108e:	cf 91       	pop	r28
    1090:	df 91       	pop	r29
    1092:	08 95       	ret

00001094 <Main_Memory_Page_Program_Through_Buffer>:
*DataLen   :要写入的数据长度
************************************************************/
void Main_Memory_Page_Program_Through_Buffer(unsigned char BufferX,
                                             unsigned int PA,unsigned char BA,
	 						                 unsigned char *wData,unsigned int DataLen)
{
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	df 93       	push	r29
    109a:	cf 93       	push	r28
    109c:	cd b7       	in	r28, 0x3d	; 61
    109e:	de b7       	in	r29, 0x3e	; 62
    10a0:	2a 97       	sbiw	r28, 0x0a	; 10
    10a2:	0f b6       	in	r0, 0x3f	; 63
    10a4:	f8 94       	cli
    10a6:	de bf       	out	0x3e, r29	; 62
    10a8:	0f be       	out	0x3f, r0	; 63
    10aa:	cd bf       	out	0x3d, r28	; 61
    10ac:	8b 83       	std	Y+3, r24	; 0x03
    10ae:	7d 83       	std	Y+5, r23	; 0x05
    10b0:	6c 83       	std	Y+4, r22	; 0x04
    10b2:	4e 83       	std	Y+6, r20	; 0x06
    10b4:	38 87       	std	Y+8, r19	; 0x08
    10b6:	2f 83       	std	Y+7, r18	; 0x07
    10b8:	1a 87       	std	Y+10, r17	; 0x0a
    10ba:	09 87       	std	Y+9, r16	; 0x09
  unsigned int i;
  DF_Check_Busy_State();
    10bc:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
    10c0:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  if(BufferX == Buffer1)  SPI_Transfer(Main_Memory_Page_Program_Through_Buffer1);//0x82
    10c4:	8b 81       	ldd	r24, Y+3	; 0x03
    10c6:	81 30       	cpi	r24, 0x01	; 1
    10c8:	21 f4       	brne	.+8      	; 0x10d2 <Main_Memory_Page_Program_Through_Buffer+0x3e>
    10ca:	82 e8       	ldi	r24, 0x82	; 130
    10cc:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    10d0:	03 c0       	rjmp	.+6      	; 0x10d8 <Main_Memory_Page_Program_Through_Buffer+0x44>
  else                    SPI_Transfer(Main_Memory_Page_Program_Through_Buffer2);//0x85
    10d2:	85 e8       	ldi	r24, 0x85	; 133
    10d4:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //4 bits(don't care bits) + 11 bits(page address)+9(address in the page)
  SPI_Transfer((unsigned char)(PA>>7));
    10d8:	8c 81       	ldd	r24, Y+4	; 0x04
    10da:	9d 81       	ldd	r25, Y+5	; 0x05
    10dc:	88 0f       	add	r24, r24
    10de:	89 2f       	mov	r24, r25
    10e0:	88 1f       	adc	r24, r24
    10e2:	99 0b       	sbc	r25, r25
    10e4:	91 95       	neg	r25
    10e6:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)((PA<<1)|(BA>>8)));
    10ea:	8c 81       	ldd	r24, Y+4	; 0x04
    10ec:	28 2f       	mov	r18, r24
    10ee:	22 0f       	add	r18, r18
    10f0:	8e 81       	ldd	r24, Y+6	; 0x06
    10f2:	88 2f       	mov	r24, r24
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	89 2f       	mov	r24, r25
    10f8:	99 0f       	add	r25, r25
    10fa:	99 0b       	sbc	r25, r25
    10fc:	82 2b       	or	r24, r18
    10fe:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)BA);
    1102:	8e 81       	ldd	r24, Y+6	; 0x06
    1104:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  for(i=0;i<DataLen;i++)	SPI_Transfer(wData[i]);
    1108:	1a 82       	std	Y+2, r1	; 0x02
    110a:	19 82       	std	Y+1, r1	; 0x01
    110c:	0f c0       	rjmp	.+30     	; 0x112c <__stack+0x2d>
    110e:	2f 81       	ldd	r18, Y+7	; 0x07
    1110:	38 85       	ldd	r19, Y+8	; 0x08
    1112:	89 81       	ldd	r24, Y+1	; 0x01
    1114:	9a 81       	ldd	r25, Y+2	; 0x02
    1116:	f9 01       	movw	r30, r18
    1118:	e8 0f       	add	r30, r24
    111a:	f9 1f       	adc	r31, r25
    111c:	80 81       	ld	r24, Z
    111e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    1122:	89 81       	ldd	r24, Y+1	; 0x01
    1124:	9a 81       	ldd	r25, Y+2	; 0x02
    1126:	01 96       	adiw	r24, 0x01	; 1
    1128:	9a 83       	std	Y+2, r25	; 0x02
    112a:	89 83       	std	Y+1, r24	; 0x01
    112c:	29 81       	ldd	r18, Y+1	; 0x01
    112e:	3a 81       	ldd	r19, Y+2	; 0x02
    1130:	89 85       	ldd	r24, Y+9	; 0x09
    1132:	9a 85       	ldd	r25, Y+10	; 0x0a
    1134:	28 17       	cp	r18, r24
    1136:	39 07       	cpc	r19, r25
    1138:	50 f3       	brcs	.-44     	; 0x110e <__stack+0xf>

  Disable_DFLASH();
    113a:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
    113e:	2a 96       	adiw	r28, 0x0a	; 10
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	cd bf       	out	0x3d, r28	; 61
    114a:	cf 91       	pop	r28
    114c:	df 91       	pop	r29
    114e:	1f 91       	pop	r17
    1150:	0f 91       	pop	r16
    1152:	08 95       	ret

00001154 <DF_Main_Memory_Page_Read>:
*DataLen   :要读取的数据长度
*与DF_Continuous_Array_Read一样的功能但与Buffer有关,但不改变Buffer中的数据
************************************************************/
void DF_Main_Memory_Page_Read(unsigned int PA,unsigned char BA,
	 						  unsigned char *rData,unsigned int DataLen)
{
    1154:	0f 93       	push	r16
    1156:	1f 93       	push	r17
    1158:	df 93       	push	r29
    115a:	cf 93       	push	r28
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	29 97       	sbiw	r28, 0x09	; 9
    1162:	0f b6       	in	r0, 0x3f	; 63
    1164:	f8 94       	cli
    1166:	de bf       	out	0x3e, r29	; 62
    1168:	0f be       	out	0x3f, r0	; 63
    116a:	cd bf       	out	0x3d, r28	; 61
    116c:	9c 83       	std	Y+4, r25	; 0x04
    116e:	8b 83       	std	Y+3, r24	; 0x03
    1170:	6d 83       	std	Y+5, r22	; 0x05
    1172:	5f 83       	std	Y+7, r21	; 0x07
    1174:	4e 83       	std	Y+6, r20	; 0x06
    1176:	39 87       	std	Y+9, r19	; 0x09
    1178:	28 87       	std	Y+8, r18	; 0x08
  unsigned int i;
  DF_Check_Busy_State();
    117a:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
    117e:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  SPI_Transfer(Main_Memory_Page_Read_Command);//0xD2
    1182:	82 ed       	ldi	r24, 0xD2	; 210
    1184:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //4 bits(don't care bits) + 11 bits(page address)+9(address in the page)
  SPI_Transfer((unsigned char)(PA>>7));
    1188:	8b 81       	ldd	r24, Y+3	; 0x03
    118a:	9c 81       	ldd	r25, Y+4	; 0x04
    118c:	88 0f       	add	r24, r24
    118e:	89 2f       	mov	r24, r25
    1190:	88 1f       	adc	r24, r24
    1192:	99 0b       	sbc	r25, r25
    1194:	91 95       	neg	r25
    1196:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)((PA<<1)|(BA>>8)));
    119a:	8b 81       	ldd	r24, Y+3	; 0x03
    119c:	28 2f       	mov	r18, r24
    119e:	22 0f       	add	r18, r18
    11a0:	8d 81       	ldd	r24, Y+5	; 0x05
    11a2:	88 2f       	mov	r24, r24
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	89 2f       	mov	r24, r25
    11a8:	99 0f       	add	r25, r25
    11aa:	99 0b       	sbc	r25, r25
    11ac:	82 2b       	or	r24, r18
    11ae:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)BA);
    11b2:	8d 81       	ldd	r24, Y+5	; 0x05
    11b4:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  //4 don’t care bytes
  for(i=0;i<4;i++)	SPI_Transfer(0xFF);
    11b8:	1a 82       	std	Y+2, r1	; 0x02
    11ba:	19 82       	std	Y+1, r1	; 0x01
    11bc:	08 c0       	rjmp	.+16     	; 0x11ce <DF_Main_Memory_Page_Read+0x7a>
    11be:	8f ef       	ldi	r24, 0xFF	; 255
    11c0:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	9a 81       	ldd	r25, Y+2	; 0x02
    11c8:	01 96       	adiw	r24, 0x01	; 1
    11ca:	9a 83       	std	Y+2, r25	; 0x02
    11cc:	89 83       	std	Y+1, r24	; 0x01
    11ce:	89 81       	ldd	r24, Y+1	; 0x01
    11d0:	9a 81       	ldd	r25, Y+2	; 0x02
    11d2:	84 30       	cpi	r24, 0x04	; 4
    11d4:	91 05       	cpc	r25, r1
    11d6:	98 f3       	brcs	.-26     	; 0x11be <DF_Main_Memory_Page_Read+0x6a>

  for(i=0;i<DataLen;i++)  rData[i] = SPI_Transfer(0xFF);//读取数据
    11d8:	1a 82       	std	Y+2, r1	; 0x02
    11da:	19 82       	std	Y+1, r1	; 0x01
    11dc:	11 c0       	rjmp	.+34     	; 0x1200 <DF_Main_Memory_Page_Read+0xac>
    11de:	2e 81       	ldd	r18, Y+6	; 0x06
    11e0:	3f 81       	ldd	r19, Y+7	; 0x07
    11e2:	89 81       	ldd	r24, Y+1	; 0x01
    11e4:	9a 81       	ldd	r25, Y+2	; 0x02
    11e6:	89 01       	movw	r16, r18
    11e8:	08 0f       	add	r16, r24
    11ea:	19 1f       	adc	r17, r25
    11ec:	8f ef       	ldi	r24, 0xFF	; 255
    11ee:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    11f2:	f8 01       	movw	r30, r16
    11f4:	80 83       	st	Z, r24
    11f6:	89 81       	ldd	r24, Y+1	; 0x01
    11f8:	9a 81       	ldd	r25, Y+2	; 0x02
    11fa:	01 96       	adiw	r24, 0x01	; 1
    11fc:	9a 83       	std	Y+2, r25	; 0x02
    11fe:	89 83       	std	Y+1, r24	; 0x01
    1200:	29 81       	ldd	r18, Y+1	; 0x01
    1202:	3a 81       	ldd	r19, Y+2	; 0x02
    1204:	88 85       	ldd	r24, Y+8	; 0x08
    1206:	99 85       	ldd	r25, Y+9	; 0x09
    1208:	28 17       	cp	r18, r24
    120a:	39 07       	cpc	r19, r25
    120c:	40 f3       	brcs	.-48     	; 0x11de <DF_Main_Memory_Page_Read+0x8a>

  Disable_DFLASH();
    120e:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
    1212:	29 96       	adiw	r28, 0x09	; 9
    1214:	0f b6       	in	r0, 0x3f	; 63
    1216:	f8 94       	cli
    1218:	de bf       	out	0x3e, r29	; 62
    121a:	0f be       	out	0x3f, r0	; 63
    121c:	cd bf       	out	0x3d, r28	; 61
    121e:	cf 91       	pop	r28
    1220:	df 91       	pop	r29
    1222:	1f 91       	pop	r17
    1224:	0f 91       	pop	r16
    1226:	08 95       	ret

00001228 <DF_Continuous_Array_Read>:
*DataLen   :要读取的数据长度
*与DF_Main_Memory_Page_Read一样的功能但与Buffer无关
************************************************************/
void DF_Continuous_Array_Read(unsigned int PA,unsigned char BA,
	 						  unsigned char *rData,unsigned int DataLen)
{
    1228:	0f 93       	push	r16
    122a:	1f 93       	push	r17
    122c:	df 93       	push	r29
    122e:	cf 93       	push	r28
    1230:	cd b7       	in	r28, 0x3d	; 61
    1232:	de b7       	in	r29, 0x3e	; 62
    1234:	29 97       	sbiw	r28, 0x09	; 9
    1236:	0f b6       	in	r0, 0x3f	; 63
    1238:	f8 94       	cli
    123a:	de bf       	out	0x3e, r29	; 62
    123c:	0f be       	out	0x3f, r0	; 63
    123e:	cd bf       	out	0x3d, r28	; 61
    1240:	9c 83       	std	Y+4, r25	; 0x04
    1242:	8b 83       	std	Y+3, r24	; 0x03
    1244:	6d 83       	std	Y+5, r22	; 0x05
    1246:	5f 83       	std	Y+7, r21	; 0x07
    1248:	4e 83       	std	Y+6, r20	; 0x06
    124a:	39 87       	std	Y+9, r19	; 0x09
    124c:	28 87       	std	Y+8, r18	; 0x08
  unsigned int i;
  DF_Check_Busy_State();
    124e:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>

  Enable_DFLASH();
    1252:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  SPI_Transfer(Continuous_Array_Read_Command);//0xE8
    1256:	88 ee       	ldi	r24, 0xE8	; 232
    1258:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>

  //4 bits(don't care bits) + 11 bits(page address)+9(address in the page)
  SPI_Transfer((unsigned char)(PA>>7));
    125c:	8b 81       	ldd	r24, Y+3	; 0x03
    125e:	9c 81       	ldd	r25, Y+4	; 0x04
    1260:	88 0f       	add	r24, r24
    1262:	89 2f       	mov	r24, r25
    1264:	88 1f       	adc	r24, r24
    1266:	99 0b       	sbc	r25, r25
    1268:	91 95       	neg	r25
    126a:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)((PA<<1)|(BA>>8)));
    126e:	8b 81       	ldd	r24, Y+3	; 0x03
    1270:	28 2f       	mov	r18, r24
    1272:	22 0f       	add	r18, r18
    1274:	8d 81       	ldd	r24, Y+5	; 0x05
    1276:	88 2f       	mov	r24, r24
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	89 2f       	mov	r24, r25
    127c:	99 0f       	add	r25, r25
    127e:	99 0b       	sbc	r25, r25
    1280:	82 2b       	or	r24, r18
    1282:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  SPI_Transfer((unsigned char)BA);
    1286:	8d 81       	ldd	r24, Y+5	; 0x05
    1288:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  //4 don’t care bytes
  for(i=0;i<4;i++)	SPI_Transfer(0xFF);
    128c:	1a 82       	std	Y+2, r1	; 0x02
    128e:	19 82       	std	Y+1, r1	; 0x01
    1290:	08 c0       	rjmp	.+16     	; 0x12a2 <DF_Continuous_Array_Read+0x7a>
    1292:	8f ef       	ldi	r24, 0xFF	; 255
    1294:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    1298:	89 81       	ldd	r24, Y+1	; 0x01
    129a:	9a 81       	ldd	r25, Y+2	; 0x02
    129c:	01 96       	adiw	r24, 0x01	; 1
    129e:	9a 83       	std	Y+2, r25	; 0x02
    12a0:	89 83       	std	Y+1, r24	; 0x01
    12a2:	89 81       	ldd	r24, Y+1	; 0x01
    12a4:	9a 81       	ldd	r25, Y+2	; 0x02
    12a6:	84 30       	cpi	r24, 0x04	; 4
    12a8:	91 05       	cpc	r25, r1
    12aa:	98 f3       	brcs	.-26     	; 0x1292 <DF_Continuous_Array_Read+0x6a>

  for(i=0;i<DataLen;i++)  rData[i] = SPI_Transfer(0xFF);//读取数据
    12ac:	1a 82       	std	Y+2, r1	; 0x02
    12ae:	19 82       	std	Y+1, r1	; 0x01
    12b0:	11 c0       	rjmp	.+34     	; 0x12d4 <DF_Continuous_Array_Read+0xac>
    12b2:	2e 81       	ldd	r18, Y+6	; 0x06
    12b4:	3f 81       	ldd	r19, Y+7	; 0x07
    12b6:	89 81       	ldd	r24, Y+1	; 0x01
    12b8:	9a 81       	ldd	r25, Y+2	; 0x02
    12ba:	89 01       	movw	r16, r18
    12bc:	08 0f       	add	r16, r24
    12be:	19 1f       	adc	r17, r25
    12c0:	8f ef       	ldi	r24, 0xFF	; 255
    12c2:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
    12c6:	f8 01       	movw	r30, r16
    12c8:	80 83       	st	Z, r24
    12ca:	89 81       	ldd	r24, Y+1	; 0x01
    12cc:	9a 81       	ldd	r25, Y+2	; 0x02
    12ce:	01 96       	adiw	r24, 0x01	; 1
    12d0:	9a 83       	std	Y+2, r25	; 0x02
    12d2:	89 83       	std	Y+1, r24	; 0x01
    12d4:	29 81       	ldd	r18, Y+1	; 0x01
    12d6:	3a 81       	ldd	r19, Y+2	; 0x02
    12d8:	88 85       	ldd	r24, Y+8	; 0x08
    12da:	99 85       	ldd	r25, Y+9	; 0x09
    12dc:	28 17       	cp	r18, r24
    12de:	39 07       	cpc	r19, r25
    12e0:	40 f3       	brcs	.-48     	; 0x12b2 <DF_Continuous_Array_Read+0x8a>

  Disable_DFLASH();
    12e2:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
    12e6:	29 96       	adiw	r28, 0x09	; 9
    12e8:	0f b6       	in	r0, 0x3f	; 63
    12ea:	f8 94       	cli
    12ec:	de bf       	out	0x3e, r29	; 62
    12ee:	0f be       	out	0x3f, r0	; 63
    12f0:	cd bf       	out	0x3d, r28	; 61
    12f2:	cf 91       	pop	r28
    12f4:	df 91       	pop	r29
    12f6:	1f 91       	pop	r17
    12f8:	0f 91       	pop	r16
    12fa:	08 95       	ret

000012fc <DF_Chip_Erase>:
/************************************************************
*擦除FLASH全部内容
*not affect sectors that are protected or locked down
************************************************************/
void DF_Chip_Erase(void)
{
    12fc:	df 93       	push	r29
    12fe:	cf 93       	push	r28
    1300:	00 d0       	rcall	.+0      	; 0x1302 <DF_Chip_Erase+0x6>
    1302:	00 d0       	rcall	.+0      	; 0x1304 <DF_Chip_Erase+0x8>
    1304:	0f 92       	push	r0
    1306:	cd b7       	in	r28, 0x3d	; 61
    1308:	de b7       	in	r29, 0x3e	; 62
  unsigned char Chip_Erase_Command[4]={0xC7,0x94,0x80,0x9A};//整片擦除操作码
    130a:	87 ec       	ldi	r24, 0xC7	; 199
    130c:	8a 83       	std	Y+2, r24	; 0x02
    130e:	84 e9       	ldi	r24, 0x94	; 148
    1310:	8b 83       	std	Y+3, r24	; 0x03
    1312:	80 e8       	ldi	r24, 0x80	; 128
    1314:	8c 83       	std	Y+4, r24	; 0x04
    1316:	8a e9       	ldi	r24, 0x9A	; 154
    1318:	8d 83       	std	Y+5, r24	; 0x05
  unsigned char i;

  DF_Check_Busy_State();
    131a:	0e 94 bc 04 	call	0x978	; 0x978 <DF_Check_Busy_State>
  Enable_DFLASH();
    131e:	0e 94 8a 02 	call	0x514	; 0x514 <Enable_DFLASH>

  for(i=0;i<4;i++)
    1322:	19 82       	std	Y+1, r1	; 0x01
    1324:	0e c0       	rjmp	.+28     	; 0x1342 <DF_Chip_Erase+0x46>
  {
     SPI_Transfer(Chip_Erase_Command[i]);
    1326:	89 81       	ldd	r24, Y+1	; 0x01
    1328:	28 2f       	mov	r18, r24
    132a:	30 e0       	ldi	r19, 0x00	; 0
    132c:	ce 01       	movw	r24, r28
    132e:	02 96       	adiw	r24, 0x02	; 2
    1330:	fc 01       	movw	r30, r24
    1332:	e2 0f       	add	r30, r18
    1334:	f3 1f       	adc	r31, r19
    1336:	80 81       	ld	r24, Z
    1338:	0e 94 74 04 	call	0x8e8	; 0x8e8 <SPI_Transfer>
  unsigned char i;

  DF_Check_Busy_State();
  Enable_DFLASH();

  for(i=0;i<4;i++)
    133c:	89 81       	ldd	r24, Y+1	; 0x01
    133e:	8f 5f       	subi	r24, 0xFF	; 255
    1340:	89 83       	std	Y+1, r24	; 0x01
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	84 30       	cpi	r24, 0x04	; 4
    1346:	78 f3       	brcs	.-34     	; 0x1326 <DF_Chip_Erase+0x2a>
  {
     SPI_Transfer(Chip_Erase_Command[i]);
  }

  Disable_DFLASH();
    1348:	0e 94 62 03 	call	0x6c4	; 0x6c4 <Disable_DFLASH>
}
    134c:	0f 90       	pop	r0
    134e:	0f 90       	pop	r0
    1350:	0f 90       	pop	r0
    1352:	0f 90       	pop	r0
    1354:	0f 90       	pop	r0
    1356:	cf 91       	pop	r28
    1358:	df 91       	pop	r29
    135a:	08 95       	ret

0000135c <DF_Reset>:

/************************************************************
*FLASH复位
************************************************************/
void DF_Reset(void)
{
    135c:	df 93       	push	r29
    135e:	cf 93       	push	r28
    1360:	cd b7       	in	r28, 0x3d	; 61
    1362:	de b7       	in	r29, 0x3e	; 62
    1364:	e0 97       	sbiw	r28, 0x30	; 48
    1366:	0f b6       	in	r0, 0x3f	; 63
    1368:	f8 94       	cli
    136a:	de bf       	out	0x3e, r29	; 62
    136c:	0f be       	out	0x3f, r0	; 63
    136e:	cd bf       	out	0x3d, r28	; 61
  SPI_PORT&=~(1<<RESET);	//使能复位
    1370:	a8 e3       	ldi	r26, 0x38	; 56
    1372:	b0 e0       	ldi	r27, 0x00	; 0
    1374:	e8 e3       	ldi	r30, 0x38	; 56
    1376:	f0 e0       	ldi	r31, 0x00	; 0
    1378:	80 81       	ld	r24, Z
    137a:	8f 7e       	andi	r24, 0xEF	; 239
    137c:	8c 93       	st	X, r24
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	90 e0       	ldi	r25, 0x00	; 0
    1382:	a0 e2       	ldi	r26, 0x20	; 32
    1384:	b1 e4       	ldi	r27, 0x41	; 65
    1386:	8d a7       	std	Y+45, r24	; 0x2d
    1388:	9e a7       	std	Y+46, r25	; 0x2e
    138a:	af a7       	std	Y+47, r26	; 0x2f
    138c:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    138e:	6d a5       	ldd	r22, Y+45	; 0x2d
    1390:	7e a5       	ldd	r23, Y+46	; 0x2e
    1392:	8f a5       	ldd	r24, Y+47	; 0x2f
    1394:	98 a9       	ldd	r25, Y+48	; 0x30
    1396:	2a ef       	ldi	r18, 0xFA	; 250
    1398:	3d ee       	ldi	r19, 0xED	; 237
    139a:	4b e6       	ldi	r20, 0x6B	; 107
    139c:	50 e4       	ldi	r21, 0x40	; 64
    139e:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
    13a2:	dc 01       	movw	r26, r24
    13a4:	cb 01       	movw	r24, r22
    13a6:	89 a7       	std	Y+41, r24	; 0x29
    13a8:	9a a7       	std	Y+42, r25	; 0x2a
    13aa:	ab a7       	std	Y+43, r26	; 0x2b
    13ac:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    13ae:	69 a5       	ldd	r22, Y+41	; 0x29
    13b0:	7a a5       	ldd	r23, Y+42	; 0x2a
    13b2:	8b a5       	ldd	r24, Y+43	; 0x2b
    13b4:	9c a5       	ldd	r25, Y+44	; 0x2c
    13b6:	20 e0       	ldi	r18, 0x00	; 0
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	40 e8       	ldi	r20, 0x80	; 128
    13bc:	5f e3       	ldi	r21, 0x3F	; 63
    13be:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
    13c2:	88 23       	and	r24, r24
    13c4:	1c f4       	brge	.+6      	; 0x13cc <DF_Reset+0x70>
		__ticks = 1;
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	88 a7       	std	Y+40, r24	; 0x28
    13ca:	91 c0       	rjmp	.+290    	; 0x14ee <DF_Reset+0x192>
	else if (__tmp > 255)
    13cc:	69 a5       	ldd	r22, Y+41	; 0x29
    13ce:	7a a5       	ldd	r23, Y+42	; 0x2a
    13d0:	8b a5       	ldd	r24, Y+43	; 0x2b
    13d2:	9c a5       	ldd	r25, Y+44	; 0x2c
    13d4:	20 e0       	ldi	r18, 0x00	; 0
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	4f e7       	ldi	r20, 0x7F	; 127
    13da:	53 e4       	ldi	r21, 0x43	; 67
    13dc:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
    13e0:	18 16       	cp	r1, r24
    13e2:	0c f0       	brlt	.+2      	; 0x13e6 <DF_Reset+0x8a>
    13e4:	7b c0       	rjmp	.+246    	; 0x14dc <DF_Reset+0x180>
	{
		_delay_ms(__us / 1000.0);
    13e6:	6d a5       	ldd	r22, Y+45	; 0x2d
    13e8:	7e a5       	ldd	r23, Y+46	; 0x2e
    13ea:	8f a5       	ldd	r24, Y+47	; 0x2f
    13ec:	98 a9       	ldd	r25, Y+48	; 0x30
    13ee:	20 e0       	ldi	r18, 0x00	; 0
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	4a e7       	ldi	r20, 0x7A	; 122
    13f4:	54 e4       	ldi	r21, 0x44	; 68
    13f6:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <__divsf3>
    13fa:	dc 01       	movw	r26, r24
    13fc:	cb 01       	movw	r24, r22
    13fe:	8c a3       	std	Y+36, r24	; 0x24
    1400:	9d a3       	std	Y+37, r25	; 0x25
    1402:	ae a3       	std	Y+38, r26	; 0x26
    1404:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1406:	6c a1       	ldd	r22, Y+36	; 0x24
    1408:	7d a1       	ldd	r23, Y+37	; 0x25
    140a:	8e a1       	ldd	r24, Y+38	; 0x26
    140c:	9f a1       	ldd	r25, Y+39	; 0x27
    140e:	2d ec       	ldi	r18, 0xCD	; 205
    1410:	3c ec       	ldi	r19, 0xCC	; 204
    1412:	4c e2       	ldi	r20, 0x2C	; 44
    1414:	55 e4       	ldi	r21, 0x45	; 69
    1416:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
    141a:	dc 01       	movw	r26, r24
    141c:	cb 01       	movw	r24, r22
    141e:	88 a3       	std	Y+32, r24	; 0x20
    1420:	99 a3       	std	Y+33, r25	; 0x21
    1422:	aa a3       	std	Y+34, r26	; 0x22
    1424:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1426:	68 a1       	ldd	r22, Y+32	; 0x20
    1428:	79 a1       	ldd	r23, Y+33	; 0x21
    142a:	8a a1       	ldd	r24, Y+34	; 0x22
    142c:	9b a1       	ldd	r25, Y+35	; 0x23
    142e:	20 e0       	ldi	r18, 0x00	; 0
    1430:	30 e0       	ldi	r19, 0x00	; 0
    1432:	40 e8       	ldi	r20, 0x80	; 128
    1434:	5f e3       	ldi	r21, 0x3F	; 63
    1436:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
    143a:	88 23       	and	r24, r24
    143c:	2c f4       	brge	.+10     	; 0x1448 <DF_Reset+0xec>
		__ticks = 1;
    143e:	81 e0       	ldi	r24, 0x01	; 1
    1440:	90 e0       	ldi	r25, 0x00	; 0
    1442:	9f 8f       	std	Y+31, r25	; 0x1f
    1444:	8e 8f       	std	Y+30, r24	; 0x1e
    1446:	3f c0       	rjmp	.+126    	; 0x14c6 <DF_Reset+0x16a>
	else if (__tmp > 65535)
    1448:	68 a1       	ldd	r22, Y+32	; 0x20
    144a:	79 a1       	ldd	r23, Y+33	; 0x21
    144c:	8a a1       	ldd	r24, Y+34	; 0x22
    144e:	9b a1       	ldd	r25, Y+35	; 0x23
    1450:	20 e0       	ldi	r18, 0x00	; 0
    1452:	3f ef       	ldi	r19, 0xFF	; 255
    1454:	4f e7       	ldi	r20, 0x7F	; 127
    1456:	57 e4       	ldi	r21, 0x47	; 71
    1458:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
    145c:	18 16       	cp	r1, r24
    145e:	4c f5       	brge	.+82     	; 0x14b2 <DF_Reset+0x156>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1460:	6c a1       	ldd	r22, Y+36	; 0x24
    1462:	7d a1       	ldd	r23, Y+37	; 0x25
    1464:	8e a1       	ldd	r24, Y+38	; 0x26
    1466:	9f a1       	ldd	r25, Y+39	; 0x27
    1468:	20 e0       	ldi	r18, 0x00	; 0
    146a:	30 e0       	ldi	r19, 0x00	; 0
    146c:	40 e2       	ldi	r20, 0x20	; 32
    146e:	51 e4       	ldi	r21, 0x41	; 65
    1470:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
    1474:	dc 01       	movw	r26, r24
    1476:	cb 01       	movw	r24, r22
    1478:	bc 01       	movw	r22, r24
    147a:	cd 01       	movw	r24, r26
    147c:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
    1480:	dc 01       	movw	r26, r24
    1482:	cb 01       	movw	r24, r22
    1484:	9f 8f       	std	Y+31, r25	; 0x1f
    1486:	8e 8f       	std	Y+30, r24	; 0x1e
    1488:	0f c0       	rjmp	.+30     	; 0x14a8 <DF_Reset+0x14c>
    148a:	84 e1       	ldi	r24, 0x14	; 20
    148c:	91 e0       	ldi	r25, 0x01	; 1
    148e:	9d 8f       	std	Y+29, r25	; 0x1d
    1490:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1492:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1494:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1496:	01 97       	sbiw	r24, 0x01	; 1
    1498:	f1 f7       	brne	.-4      	; 0x1496 <DF_Reset+0x13a>
    149a:	9d 8f       	std	Y+29, r25	; 0x1d
    149c:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    149e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14a0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    14a2:	01 97       	sbiw	r24, 0x01	; 1
    14a4:	9f 8f       	std	Y+31, r25	; 0x1f
    14a6:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14aa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    14ac:	00 97       	sbiw	r24, 0x00	; 0
    14ae:	69 f7       	brne	.-38     	; 0x148a <DF_Reset+0x12e>
    14b0:	24 c0       	rjmp	.+72     	; 0x14fa <DF_Reset+0x19e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14b2:	68 a1       	ldd	r22, Y+32	; 0x20
    14b4:	79 a1       	ldd	r23, Y+33	; 0x21
    14b6:	8a a1       	ldd	r24, Y+34	; 0x22
    14b8:	9b a1       	ldd	r25, Y+35	; 0x23
    14ba:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
    14be:	dc 01       	movw	r26, r24
    14c0:	cb 01       	movw	r24, r22
    14c2:	9f 8f       	std	Y+31, r25	; 0x1f
    14c4:	8e 8f       	std	Y+30, r24	; 0x1e
    14c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14c8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    14ca:	9b 8f       	std	Y+27, r25	; 0x1b
    14cc:	8a 8f       	std	Y+26, r24	; 0x1a
    14ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14d0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    14d2:	01 97       	sbiw	r24, 0x01	; 1
    14d4:	f1 f7       	brne	.-4      	; 0x14d2 <DF_Reset+0x176>
    14d6:	9b 8f       	std	Y+27, r25	; 0x1b
    14d8:	8a 8f       	std	Y+26, r24	; 0x1a
    14da:	0f c0       	rjmp	.+30     	; 0x14fa <DF_Reset+0x19e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    14dc:	69 a5       	ldd	r22, Y+41	; 0x29
    14de:	7a a5       	ldd	r23, Y+42	; 0x2a
    14e0:	8b a5       	ldd	r24, Y+43	; 0x2b
    14e2:	9c a5       	ldd	r25, Y+44	; 0x2c
    14e4:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
    14e8:	dc 01       	movw	r26, r24
    14ea:	cb 01       	movw	r24, r22
    14ec:	88 a7       	std	Y+40, r24	; 0x28
    14ee:	88 a5       	ldd	r24, Y+40	; 0x28
    14f0:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    14f2:	89 8d       	ldd	r24, Y+25	; 0x19
    14f4:	8a 95       	dec	r24
    14f6:	f1 f7       	brne	.-4      	; 0x14f4 <DF_Reset+0x198>
    14f8:	89 8f       	std	Y+25, r24	; 0x19
  _delay_us(10);
  SPI_PORT|=(1<<RESET);     //禁止复位
    14fa:	a8 e3       	ldi	r26, 0x38	; 56
    14fc:	b0 e0       	ldi	r27, 0x00	; 0
    14fe:	e8 e3       	ldi	r30, 0x38	; 56
    1500:	f0 e0       	ldi	r31, 0x00	; 0
    1502:	80 81       	ld	r24, Z
    1504:	80 61       	ori	r24, 0x10	; 16
    1506:	8c 93       	st	X, r24
    1508:	80 e0       	ldi	r24, 0x00	; 0
    150a:	90 e0       	ldi	r25, 0x00	; 0
    150c:	a0 e2       	ldi	r26, 0x20	; 32
    150e:	b1 e4       	ldi	r27, 0x41	; 65
    1510:	8d 8b       	std	Y+21, r24	; 0x15
    1512:	9e 8b       	std	Y+22, r25	; 0x16
    1514:	af 8b       	std	Y+23, r26	; 0x17
    1516:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1518:	6d 89       	ldd	r22, Y+21	; 0x15
    151a:	7e 89       	ldd	r23, Y+22	; 0x16
    151c:	8f 89       	ldd	r24, Y+23	; 0x17
    151e:	98 8d       	ldd	r25, Y+24	; 0x18
    1520:	2a ef       	ldi	r18, 0xFA	; 250
    1522:	3d ee       	ldi	r19, 0xED	; 237
    1524:	4b e6       	ldi	r20, 0x6B	; 107
    1526:	50 e4       	ldi	r21, 0x40	; 64
    1528:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
    152c:	dc 01       	movw	r26, r24
    152e:	cb 01       	movw	r24, r22
    1530:	89 8b       	std	Y+17, r24	; 0x11
    1532:	9a 8b       	std	Y+18, r25	; 0x12
    1534:	ab 8b       	std	Y+19, r26	; 0x13
    1536:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1538:	69 89       	ldd	r22, Y+17	; 0x11
    153a:	7a 89       	ldd	r23, Y+18	; 0x12
    153c:	8b 89       	ldd	r24, Y+19	; 0x13
    153e:	9c 89       	ldd	r25, Y+20	; 0x14
    1540:	20 e0       	ldi	r18, 0x00	; 0
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	40 e8       	ldi	r20, 0x80	; 128
    1546:	5f e3       	ldi	r21, 0x3F	; 63
    1548:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
    154c:	88 23       	and	r24, r24
    154e:	1c f4       	brge	.+6      	; 0x1556 <DF_Reset+0x1fa>
		__ticks = 1;
    1550:	81 e0       	ldi	r24, 0x01	; 1
    1552:	88 8b       	std	Y+16, r24	; 0x10
    1554:	91 c0       	rjmp	.+290    	; 0x1678 <DF_Reset+0x31c>
	else if (__tmp > 255)
    1556:	69 89       	ldd	r22, Y+17	; 0x11
    1558:	7a 89       	ldd	r23, Y+18	; 0x12
    155a:	8b 89       	ldd	r24, Y+19	; 0x13
    155c:	9c 89       	ldd	r25, Y+20	; 0x14
    155e:	20 e0       	ldi	r18, 0x00	; 0
    1560:	30 e0       	ldi	r19, 0x00	; 0
    1562:	4f e7       	ldi	r20, 0x7F	; 127
    1564:	53 e4       	ldi	r21, 0x43	; 67
    1566:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
    156a:	18 16       	cp	r1, r24
    156c:	0c f0       	brlt	.+2      	; 0x1570 <DF_Reset+0x214>
    156e:	7b c0       	rjmp	.+246    	; 0x1666 <DF_Reset+0x30a>
	{
		_delay_ms(__us / 1000.0);
    1570:	6d 89       	ldd	r22, Y+21	; 0x15
    1572:	7e 89       	ldd	r23, Y+22	; 0x16
    1574:	8f 89       	ldd	r24, Y+23	; 0x17
    1576:	98 8d       	ldd	r25, Y+24	; 0x18
    1578:	20 e0       	ldi	r18, 0x00	; 0
    157a:	30 e0       	ldi	r19, 0x00	; 0
    157c:	4a e7       	ldi	r20, 0x7A	; 122
    157e:	54 e4       	ldi	r21, 0x44	; 68
    1580:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <__divsf3>
    1584:	dc 01       	movw	r26, r24
    1586:	cb 01       	movw	r24, r22
    1588:	8c 87       	std	Y+12, r24	; 0x0c
    158a:	9d 87       	std	Y+13, r25	; 0x0d
    158c:	ae 87       	std	Y+14, r26	; 0x0e
    158e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1590:	6c 85       	ldd	r22, Y+12	; 0x0c
    1592:	7d 85       	ldd	r23, Y+13	; 0x0d
    1594:	8e 85       	ldd	r24, Y+14	; 0x0e
    1596:	9f 85       	ldd	r25, Y+15	; 0x0f
    1598:	2d ec       	ldi	r18, 0xCD	; 205
    159a:	3c ec       	ldi	r19, 0xCC	; 204
    159c:	4c e2       	ldi	r20, 0x2C	; 44
    159e:	55 e4       	ldi	r21, 0x45	; 69
    15a0:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
    15a4:	dc 01       	movw	r26, r24
    15a6:	cb 01       	movw	r24, r22
    15a8:	88 87       	std	Y+8, r24	; 0x08
    15aa:	99 87       	std	Y+9, r25	; 0x09
    15ac:	aa 87       	std	Y+10, r26	; 0x0a
    15ae:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    15b0:	68 85       	ldd	r22, Y+8	; 0x08
    15b2:	79 85       	ldd	r23, Y+9	; 0x09
    15b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    15b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    15b8:	20 e0       	ldi	r18, 0x00	; 0
    15ba:	30 e0       	ldi	r19, 0x00	; 0
    15bc:	40 e8       	ldi	r20, 0x80	; 128
    15be:	5f e3       	ldi	r21, 0x3F	; 63
    15c0:	0e 94 77 11 	call	0x22ee	; 0x22ee <__ltsf2>
    15c4:	88 23       	and	r24, r24
    15c6:	2c f4       	brge	.+10     	; 0x15d2 <DF_Reset+0x276>
		__ticks = 1;
    15c8:	81 e0       	ldi	r24, 0x01	; 1
    15ca:	90 e0       	ldi	r25, 0x00	; 0
    15cc:	9f 83       	std	Y+7, r25	; 0x07
    15ce:	8e 83       	std	Y+6, r24	; 0x06
    15d0:	3f c0       	rjmp	.+126    	; 0x1650 <DF_Reset+0x2f4>
	else if (__tmp > 65535)
    15d2:	68 85       	ldd	r22, Y+8	; 0x08
    15d4:	79 85       	ldd	r23, Y+9	; 0x09
    15d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    15d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    15da:	20 e0       	ldi	r18, 0x00	; 0
    15dc:	3f ef       	ldi	r19, 0xFF	; 255
    15de:	4f e7       	ldi	r20, 0x7F	; 127
    15e0:	57 e4       	ldi	r21, 0x47	; 71
    15e2:	0e 94 17 11 	call	0x222e	; 0x222e <__gtsf2>
    15e6:	18 16       	cp	r1, r24
    15e8:	4c f5       	brge	.+82     	; 0x163c <DF_Reset+0x2e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    15ea:	6c 85       	ldd	r22, Y+12	; 0x0c
    15ec:	7d 85       	ldd	r23, Y+13	; 0x0d
    15ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    15f0:	9f 85       	ldd	r25, Y+15	; 0x0f
    15f2:	20 e0       	ldi	r18, 0x00	; 0
    15f4:	30 e0       	ldi	r19, 0x00	; 0
    15f6:	40 e2       	ldi	r20, 0x20	; 32
    15f8:	51 e4       	ldi	r21, 0x41	; 65
    15fa:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <__mulsf3>
    15fe:	dc 01       	movw	r26, r24
    1600:	cb 01       	movw	r24, r22
    1602:	bc 01       	movw	r22, r24
    1604:	cd 01       	movw	r24, r26
    1606:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
    160a:	dc 01       	movw	r26, r24
    160c:	cb 01       	movw	r24, r22
    160e:	9f 83       	std	Y+7, r25	; 0x07
    1610:	8e 83       	std	Y+6, r24	; 0x06
    1612:	0f c0       	rjmp	.+30     	; 0x1632 <DF_Reset+0x2d6>
    1614:	84 e1       	ldi	r24, 0x14	; 20
    1616:	91 e0       	ldi	r25, 0x01	; 1
    1618:	9d 83       	std	Y+5, r25	; 0x05
    161a:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    161c:	8c 81       	ldd	r24, Y+4	; 0x04
    161e:	9d 81       	ldd	r25, Y+5	; 0x05
    1620:	01 97       	sbiw	r24, 0x01	; 1
    1622:	f1 f7       	brne	.-4      	; 0x1620 <DF_Reset+0x2c4>
    1624:	9d 83       	std	Y+5, r25	; 0x05
    1626:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1628:	8e 81       	ldd	r24, Y+6	; 0x06
    162a:	9f 81       	ldd	r25, Y+7	; 0x07
    162c:	01 97       	sbiw	r24, 0x01	; 1
    162e:	9f 83       	std	Y+7, r25	; 0x07
    1630:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1632:	8e 81       	ldd	r24, Y+6	; 0x06
    1634:	9f 81       	ldd	r25, Y+7	; 0x07
    1636:	00 97       	sbiw	r24, 0x00	; 0
    1638:	69 f7       	brne	.-38     	; 0x1614 <DF_Reset+0x2b8>
    163a:	24 c0       	rjmp	.+72     	; 0x1684 <DF_Reset+0x328>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    163c:	68 85       	ldd	r22, Y+8	; 0x08
    163e:	79 85       	ldd	r23, Y+9	; 0x09
    1640:	8a 85       	ldd	r24, Y+10	; 0x0a
    1642:	9b 85       	ldd	r25, Y+11	; 0x0b
    1644:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
    1648:	dc 01       	movw	r26, r24
    164a:	cb 01       	movw	r24, r22
    164c:	9f 83       	std	Y+7, r25	; 0x07
    164e:	8e 83       	std	Y+6, r24	; 0x06
    1650:	8e 81       	ldd	r24, Y+6	; 0x06
    1652:	9f 81       	ldd	r25, Y+7	; 0x07
    1654:	9b 83       	std	Y+3, r25	; 0x03
    1656:	8a 83       	std	Y+2, r24	; 0x02
    1658:	8a 81       	ldd	r24, Y+2	; 0x02
    165a:	9b 81       	ldd	r25, Y+3	; 0x03
    165c:	01 97       	sbiw	r24, 0x01	; 1
    165e:	f1 f7       	brne	.-4      	; 0x165c <DF_Reset+0x300>
    1660:	9b 83       	std	Y+3, r25	; 0x03
    1662:	8a 83       	std	Y+2, r24	; 0x02
    1664:	0f c0       	rjmp	.+30     	; 0x1684 <DF_Reset+0x328>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1666:	69 89       	ldd	r22, Y+17	; 0x11
    1668:	7a 89       	ldd	r23, Y+18	; 0x12
    166a:	8b 89       	ldd	r24, Y+19	; 0x13
    166c:	9c 89       	ldd	r25, Y+20	; 0x14
    166e:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <__fixunssfsi>
    1672:	dc 01       	movw	r26, r24
    1674:	cb 01       	movw	r24, r22
    1676:	88 8b       	std	Y+16, r24	; 0x10
    1678:	88 89       	ldd	r24, Y+16	; 0x10
    167a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    167c:	89 81       	ldd	r24, Y+1	; 0x01
    167e:	8a 95       	dec	r24
    1680:	f1 f7       	brne	.-4      	; 0x167e <DF_Reset+0x322>
    1682:	89 83       	std	Y+1, r24	; 0x01
  _delay_us(10);
}
    1684:	e0 96       	adiw	r28, 0x30	; 48
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	de bf       	out	0x3e, r29	; 62
    168c:	0f be       	out	0x3f, r0	; 63
    168e:	cd bf       	out	0x3d, r28	; 61
    1690:	cf 91       	pop	r28
    1692:	df 91       	pop	r29
    1694:	08 95       	ret

00001696 <Test_Flash_Buffer_to_Buffer>:
/************************************************************
*Test DataFlash
************************************************************/
//Test_Flash_Buffer_to_Buffer
void Test_Flash_Buffer_to_Buffer(void)
{
    1696:	df 93       	push	r29
    1698:	cf 93       	push	r28
    169a:	cd b7       	in	r28, 0x3d	; 61
    169c:	de b7       	in	r29, 0x3e	; 62
    169e:	69 97       	sbiw	r28, 0x19	; 25
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	f8 94       	cli
    16a4:	de bf       	out	0x3e, r29	; 62
    16a6:	0f be       	out	0x3f, r0	; 63
    16a8:	cd bf       	out	0x3d, r28	; 61
  unsigned char TestWriteBuffer[10]={1,2,3,4,5,6,7,8,9,10};
    16aa:	ce 01       	movw	r24, r28
    16ac:	01 96       	adiw	r24, 0x01	; 1
    16ae:	9e 8b       	std	Y+22, r25	; 0x16
    16b0:	8d 8b       	std	Y+21, r24	; 0x15
    16b2:	af e1       	ldi	r26, 0x1F	; 31
    16b4:	b1 e0       	ldi	r27, 0x01	; 1
    16b6:	b8 8f       	std	Y+24, r27	; 0x18
    16b8:	af 8b       	std	Y+23, r26	; 0x17
    16ba:	ba e0       	ldi	r27, 0x0A	; 10
    16bc:	b9 8f       	std	Y+25, r27	; 0x19
    16be:	ef 89       	ldd	r30, Y+23	; 0x17
    16c0:	f8 8d       	ldd	r31, Y+24	; 0x18
    16c2:	00 80       	ld	r0, Z
    16c4:	8f 89       	ldd	r24, Y+23	; 0x17
    16c6:	98 8d       	ldd	r25, Y+24	; 0x18
    16c8:	01 96       	adiw	r24, 0x01	; 1
    16ca:	98 8f       	std	Y+24, r25	; 0x18
    16cc:	8f 8b       	std	Y+23, r24	; 0x17
    16ce:	ad 89       	ldd	r26, Y+21	; 0x15
    16d0:	be 89       	ldd	r27, Y+22	; 0x16
    16d2:	0c 92       	st	X, r0
    16d4:	ed 89       	ldd	r30, Y+21	; 0x15
    16d6:	fe 89       	ldd	r31, Y+22	; 0x16
    16d8:	31 96       	adiw	r30, 0x01	; 1
    16da:	fe 8b       	std	Y+22, r31	; 0x16
    16dc:	ed 8b       	std	Y+21, r30	; 0x15
    16de:	f9 8d       	ldd	r31, Y+25	; 0x19
    16e0:	f1 50       	subi	r31, 0x01	; 1
    16e2:	f9 8f       	std	Y+25, r31	; 0x19
    16e4:	89 8d       	ldd	r24, Y+25	; 0x19
    16e6:	88 23       	and	r24, r24
    16e8:	51 f7       	brne	.-44     	; 0x16be <Test_Flash_Buffer_to_Buffer+0x28>
  unsigned char TestReadBuffer[10] ={0,0,0,0,0,0,0,0,0,0};
    16ea:	8a e0       	ldi	r24, 0x0A	; 10
    16ec:	fe 01       	movw	r30, r28
    16ee:	3b 96       	adiw	r30, 0x0b	; 11
    16f0:	df 01       	movw	r26, r30
    16f2:	98 2f       	mov	r25, r24
    16f4:	1d 92       	st	X+, r1
    16f6:	9a 95       	dec	r25
    16f8:	e9 f7       	brne	.-6      	; 0x16f4 <Test_Flash_Buffer_to_Buffer+0x5e>

  //写数据到Buffer中
  DF_Write_to_Buffer(Buffer1,0,TestWriteBuffer,10);
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	60 e0       	ldi	r22, 0x00	; 0
    16fe:	70 e0       	ldi	r23, 0x00	; 0
    1700:	9e 01       	movw	r18, r28
    1702:	2f 5f       	subi	r18, 0xFF	; 255
    1704:	3f 4f       	sbci	r19, 0xFF	; 255
    1706:	a9 01       	movw	r20, r18
    1708:	2a e0       	ldi	r18, 0x0A	; 10
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	0e 94 45 07 	call	0xe8a	; 0xe8a <DF_Write_to_Buffer>
  //从Buffer中读取数据
  DF_Read_from_Buffer(Buffer1,0,TestReadBuffer,10);
    1710:	9e 01       	movw	r18, r28
    1712:	25 5f       	subi	r18, 0xF5	; 245
    1714:	3f 4f       	sbci	r19, 0xFF	; 255
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	60 e0       	ldi	r22, 0x00	; 0
    171a:	70 e0       	ldi	r23, 0x00	; 0
    171c:	a9 01       	movw	r20, r18
    171e:	2a e0       	ldi	r18, 0x0A	; 10
    1720:	30 e0       	ldi	r19, 0x00	; 0
    1722:	0e 94 94 07 	call	0xf28	; 0xf28 <DF_Read_from_Buffer>
  for(i=0;i<10;i++)//把要写入的和读出的数据写入EEPROM用于比较
  {
    eeprom_write_byte((i+16*0),TestWriteBuffer[i]);
	eeprom_write_byte((i+16*1),TestReadBuffer[i]);
  }*/
}
    1726:	69 96       	adiw	r28, 0x19	; 25
    1728:	0f b6       	in	r0, 0x3f	; 63
    172a:	f8 94       	cli
    172c:	de bf       	out	0x3e, r29	; 62
    172e:	0f be       	out	0x3f, r0	; 63
    1730:	cd bf       	out	0x3d, r28	; 61
    1732:	cf 91       	pop	r28
    1734:	df 91       	pop	r29
    1736:	08 95       	ret

00001738 <Test_Flash_Page_to_Page>:

//Test_Flash_Page_to_Page
void Test_Flash_Page_to_Page(void)
{
    1738:	0f 93       	push	r16
    173a:	1f 93       	push	r17
    173c:	df 93       	push	r29
    173e:	cf 93       	push	r28
    1740:	cd b7       	in	r28, 0x3d	; 61
    1742:	de b7       	in	r29, 0x3e	; 62
    1744:	69 97       	sbiw	r28, 0x19	; 25
    1746:	0f b6       	in	r0, 0x3f	; 63
    1748:	f8 94       	cli
    174a:	de bf       	out	0x3e, r29	; 62
    174c:	0f be       	out	0x3f, r0	; 63
    174e:	cd bf       	out	0x3d, r28	; 61
  unsigned char TestWriteBuffer[10]={10,9,8,7,6,5,4,3,2,1};
    1750:	ce 01       	movw	r24, r28
    1752:	01 96       	adiw	r24, 0x01	; 1
    1754:	9e 8b       	std	Y+22, r25	; 0x16
    1756:	8d 8b       	std	Y+21, r24	; 0x15
    1758:	a9 e2       	ldi	r26, 0x29	; 41
    175a:	b1 e0       	ldi	r27, 0x01	; 1
    175c:	b8 8f       	std	Y+24, r27	; 0x18
    175e:	af 8b       	std	Y+23, r26	; 0x17
    1760:	ba e0       	ldi	r27, 0x0A	; 10
    1762:	b9 8f       	std	Y+25, r27	; 0x19
    1764:	ef 89       	ldd	r30, Y+23	; 0x17
    1766:	f8 8d       	ldd	r31, Y+24	; 0x18
    1768:	00 80       	ld	r0, Z
    176a:	8f 89       	ldd	r24, Y+23	; 0x17
    176c:	98 8d       	ldd	r25, Y+24	; 0x18
    176e:	01 96       	adiw	r24, 0x01	; 1
    1770:	98 8f       	std	Y+24, r25	; 0x18
    1772:	8f 8b       	std	Y+23, r24	; 0x17
    1774:	ad 89       	ldd	r26, Y+21	; 0x15
    1776:	be 89       	ldd	r27, Y+22	; 0x16
    1778:	0c 92       	st	X, r0
    177a:	ed 89       	ldd	r30, Y+21	; 0x15
    177c:	fe 89       	ldd	r31, Y+22	; 0x16
    177e:	31 96       	adiw	r30, 0x01	; 1
    1780:	fe 8b       	std	Y+22, r31	; 0x16
    1782:	ed 8b       	std	Y+21, r30	; 0x15
    1784:	f9 8d       	ldd	r31, Y+25	; 0x19
    1786:	f1 50       	subi	r31, 0x01	; 1
    1788:	f9 8f       	std	Y+25, r31	; 0x19
    178a:	89 8d       	ldd	r24, Y+25	; 0x19
    178c:	88 23       	and	r24, r24
    178e:	51 f7       	brne	.-44     	; 0x1764 <Test_Flash_Page_to_Page+0x2c>
  unsigned char TestReadBuffer[10] ={0,0,0,0,0,0,0,0,0,0};
    1790:	8a e0       	ldi	r24, 0x0A	; 10
    1792:	fe 01       	movw	r30, r28
    1794:	3b 96       	adiw	r30, 0x0b	; 11
    1796:	df 01       	movw	r26, r30
    1798:	98 2f       	mov	r25, r24
    179a:	1d 92       	st	X+, r1
    179c:	9a 95       	dec	r25
    179e:	e9 f7       	brne	.-6      	; 0x179a <Test_Flash_Page_to_Page+0x62>
  
  //将数据写到内存中(自动先写到BUFFER1 OR BURRER2中再将数据写到内存中)
  Main_Memory_Page_Program_Through_Buffer(Buffer1,0,0,TestWriteBuffer,10);
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	60 e0       	ldi	r22, 0x00	; 0
    17a4:	70 e0       	ldi	r23, 0x00	; 0
    17a6:	40 e0       	ldi	r20, 0x00	; 0
    17a8:	9e 01       	movw	r18, r28
    17aa:	2f 5f       	subi	r18, 0xFF	; 255
    17ac:	3f 4f       	sbci	r19, 0xFF	; 255
    17ae:	0a e0       	ldi	r16, 0x0A	; 10
    17b0:	10 e0       	ldi	r17, 0x00	; 0
    17b2:	0e 94 4a 08 	call	0x1094	; 0x1094 <Main_Memory_Page_Program_Through_Buffer>
  //从内存中读取数据到数组rData中(直接读取数据不经过BUFFER1 OR BURRER2)
  DF_Main_Memory_Page_Read(0,0,TestReadBuffer,10);
    17b6:	9e 01       	movw	r18, r28
    17b8:	25 5f       	subi	r18, 0xF5	; 245
    17ba:	3f 4f       	sbci	r19, 0xFF	; 255
    17bc:	80 e0       	ldi	r24, 0x00	; 0
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	60 e0       	ldi	r22, 0x00	; 0
    17c2:	a9 01       	movw	r20, r18
    17c4:	2a e0       	ldi	r18, 0x0A	; 10
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	0e 94 aa 08 	call	0x1154	; 0x1154 <DF_Main_Memory_Page_Read>
  for(i=0;i<10;i++)//把要写入的和读出的数据写入EEPROM用于比较
  {
    eeprom_write_byte((i+16*2),TestWriteBuffer[i]);
	eeprom_write_byte((i+16*3),TestReadBuffer[i]);
  }*/
}
    17cc:	69 96       	adiw	r28, 0x19	; 25
    17ce:	0f b6       	in	r0, 0x3f	; 63
    17d0:	f8 94       	cli
    17d2:	de bf       	out	0x3e, r29	; 62
    17d4:	0f be       	out	0x3f, r0	; 63
    17d6:	cd bf       	out	0x3d, r28	; 61
    17d8:	cf 91       	pop	r28
    17da:	df 91       	pop	r29
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	08 95       	ret

000017e2 <Test_Flash_Buffer_Page_to_Page>:

//Test_Flash_Buffer_Page_to_Page
void Test_Flash_Buffer_Page_to_Page(void)
{
    17e2:	df 93       	push	r29
    17e4:	cf 93       	push	r28
    17e6:	cd b7       	in	r28, 0x3d	; 61
    17e8:	de b7       	in	r29, 0x3e	; 62
    17ea:	69 97       	sbiw	r28, 0x19	; 25
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	de bf       	out	0x3e, r29	; 62
    17f2:	0f be       	out	0x3f, r0	; 63
    17f4:	cd bf       	out	0x3d, r28	; 61
  unsigned char TestWriteBuffer[10]={1,2,3,4,5,6,7,8,9,10};
    17f6:	ce 01       	movw	r24, r28
    17f8:	01 96       	adiw	r24, 0x01	; 1
    17fa:	9e 8b       	std	Y+22, r25	; 0x16
    17fc:	8d 8b       	std	Y+21, r24	; 0x15
    17fe:	a3 e3       	ldi	r26, 0x33	; 51
    1800:	b1 e0       	ldi	r27, 0x01	; 1
    1802:	b8 8f       	std	Y+24, r27	; 0x18
    1804:	af 8b       	std	Y+23, r26	; 0x17
    1806:	ba e0       	ldi	r27, 0x0A	; 10
    1808:	b9 8f       	std	Y+25, r27	; 0x19
    180a:	ef 89       	ldd	r30, Y+23	; 0x17
    180c:	f8 8d       	ldd	r31, Y+24	; 0x18
    180e:	00 80       	ld	r0, Z
    1810:	8f 89       	ldd	r24, Y+23	; 0x17
    1812:	98 8d       	ldd	r25, Y+24	; 0x18
    1814:	01 96       	adiw	r24, 0x01	; 1
    1816:	98 8f       	std	Y+24, r25	; 0x18
    1818:	8f 8b       	std	Y+23, r24	; 0x17
    181a:	ad 89       	ldd	r26, Y+21	; 0x15
    181c:	be 89       	ldd	r27, Y+22	; 0x16
    181e:	0c 92       	st	X, r0
    1820:	ed 89       	ldd	r30, Y+21	; 0x15
    1822:	fe 89       	ldd	r31, Y+22	; 0x16
    1824:	31 96       	adiw	r30, 0x01	; 1
    1826:	fe 8b       	std	Y+22, r31	; 0x16
    1828:	ed 8b       	std	Y+21, r30	; 0x15
    182a:	f9 8d       	ldd	r31, Y+25	; 0x19
    182c:	f1 50       	subi	r31, 0x01	; 1
    182e:	f9 8f       	std	Y+25, r31	; 0x19
    1830:	89 8d       	ldd	r24, Y+25	; 0x19
    1832:	88 23       	and	r24, r24
    1834:	51 f7       	brne	.-44     	; 0x180a <Test_Flash_Buffer_Page_to_Page+0x28>
  unsigned char TestReadBuffer[10] ={0,0,0,0,0,0,0,0,0,0};
    1836:	8a e0       	ldi	r24, 0x0A	; 10
    1838:	fe 01       	movw	r30, r28
    183a:	3b 96       	adiw	r30, 0x0b	; 11
    183c:	df 01       	movw	r26, r30
    183e:	98 2f       	mov	r25, r24
    1840:	1d 92       	st	X+, r1
    1842:	9a 95       	dec	r25
    1844:	e9 f7       	brne	.-6      	; 0x1840 <Test_Flash_Buffer_Page_to_Page+0x5e>
  //写数据到Buffer中
  DF_Write_to_Buffer(Buffer1,0,TestWriteBuffer,10);
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	60 e0       	ldi	r22, 0x00	; 0
    184a:	70 e0       	ldi	r23, 0x00	; 0
    184c:	9e 01       	movw	r18, r28
    184e:	2f 5f       	subi	r18, 0xFF	; 255
    1850:	3f 4f       	sbci	r19, 0xFF	; 255
    1852:	a9 01       	movw	r20, r18
    1854:	2a e0       	ldi	r18, 0x0A	; 10
    1856:	30 e0       	ldi	r19, 0x00	; 0
    1858:	0e 94 45 07 	call	0xe8a	; 0xe8a <DF_Write_to_Buffer>
  //将Buffer中的数据写到DataFlash中
  DF_Write_Buffer_to_Page(Buffer1,0);
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	60 e0       	ldi	r22, 0x00	; 0
    1860:	70 e0       	ldi	r23, 0x00	; 0
    1862:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <DF_Write_Buffer_to_Page>
  //读出DataFlash中的数据
  //DF_Main_Memory_Page_Read(0,0,TestReadBuffer,10);
  DF_Continuous_Array_Read(0,0,TestReadBuffer,10);
    1866:	9e 01       	movw	r18, r28
    1868:	25 5f       	subi	r18, 0xF5	; 245
    186a:	3f 4f       	sbci	r19, 0xFF	; 255
    186c:	80 e0       	ldi	r24, 0x00	; 0
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	60 e0       	ldi	r22, 0x00	; 0
    1872:	a9 01       	movw	r20, r18
    1874:	2a e0       	ldi	r18, 0x0A	; 10
    1876:	30 e0       	ldi	r19, 0x00	; 0
    1878:	0e 94 14 09 	call	0x1228	; 0x1228 <DF_Continuous_Array_Read>
  for(i=0;i<10;i++)//把要写入的和读出的数据写入EEPROM用于比较
  {
    eeprom_write_byte((i+16*4),TestWriteBuffer[i]);
	eeprom_write_byte((i+16*5),TestReadBuffer[i]);
  }*/
}
    187c:	69 96       	adiw	r28, 0x19	; 25
    187e:	0f b6       	in	r0, 0x3f	; 63
    1880:	f8 94       	cli
    1882:	de bf       	out	0x3e, r29	; 62
    1884:	0f be       	out	0x3f, r0	; 63
    1886:	cd bf       	out	0x3d, r28	; 61
    1888:	cf 91       	pop	r28
    188a:	df 91       	pop	r29
    188c:	08 95       	ret

0000188e <Test_Flash_Buffer_Page_to_Page_Buffer>:

//Test_Flash_Buffer_Page_to_Page_Buffer
void Test_Flash_Buffer_Page_to_Page_Buffer(void)
{
    188e:	df 93       	push	r29
    1890:	cf 93       	push	r28
    1892:	cd b7       	in	r28, 0x3d	; 61
    1894:	de b7       	in	r29, 0x3e	; 62
    1896:	69 97       	sbiw	r28, 0x19	; 25
    1898:	0f b6       	in	r0, 0x3f	; 63
    189a:	f8 94       	cli
    189c:	de bf       	out	0x3e, r29	; 62
    189e:	0f be       	out	0x3f, r0	; 63
    18a0:	cd bf       	out	0x3d, r28	; 61
  unsigned char TestWriteBuffer[10]={10,9,8,7,6,5,4,3,2,1};
    18a2:	ce 01       	movw	r24, r28
    18a4:	01 96       	adiw	r24, 0x01	; 1
    18a6:	9e 8b       	std	Y+22, r25	; 0x16
    18a8:	8d 8b       	std	Y+21, r24	; 0x15
    18aa:	ad e3       	ldi	r26, 0x3D	; 61
    18ac:	b1 e0       	ldi	r27, 0x01	; 1
    18ae:	b8 8f       	std	Y+24, r27	; 0x18
    18b0:	af 8b       	std	Y+23, r26	; 0x17
    18b2:	ba e0       	ldi	r27, 0x0A	; 10
    18b4:	b9 8f       	std	Y+25, r27	; 0x19
    18b6:	ef 89       	ldd	r30, Y+23	; 0x17
    18b8:	f8 8d       	ldd	r31, Y+24	; 0x18
    18ba:	00 80       	ld	r0, Z
    18bc:	8f 89       	ldd	r24, Y+23	; 0x17
    18be:	98 8d       	ldd	r25, Y+24	; 0x18
    18c0:	01 96       	adiw	r24, 0x01	; 1
    18c2:	98 8f       	std	Y+24, r25	; 0x18
    18c4:	8f 8b       	std	Y+23, r24	; 0x17
    18c6:	ad 89       	ldd	r26, Y+21	; 0x15
    18c8:	be 89       	ldd	r27, Y+22	; 0x16
    18ca:	0c 92       	st	X, r0
    18cc:	ed 89       	ldd	r30, Y+21	; 0x15
    18ce:	fe 89       	ldd	r31, Y+22	; 0x16
    18d0:	31 96       	adiw	r30, 0x01	; 1
    18d2:	fe 8b       	std	Y+22, r31	; 0x16
    18d4:	ed 8b       	std	Y+21, r30	; 0x15
    18d6:	f9 8d       	ldd	r31, Y+25	; 0x19
    18d8:	f1 50       	subi	r31, 0x01	; 1
    18da:	f9 8f       	std	Y+25, r31	; 0x19
    18dc:	89 8d       	ldd	r24, Y+25	; 0x19
    18de:	88 23       	and	r24, r24
    18e0:	51 f7       	brne	.-44     	; 0x18b6 <Test_Flash_Buffer_Page_to_Page_Buffer+0x28>
  unsigned char TestReadBuffer[10] ={0,0,0,0,0,0,0,0,0,0};
    18e2:	8a e0       	ldi	r24, 0x0A	; 10
    18e4:	fe 01       	movw	r30, r28
    18e6:	3b 96       	adiw	r30, 0x0b	; 11
    18e8:	df 01       	movw	r26, r30
    18ea:	98 2f       	mov	r25, r24
    18ec:	1d 92       	st	X+, r1
    18ee:	9a 95       	dec	r25
    18f0:	e9 f7       	brne	.-6      	; 0x18ec <Test_Flash_Buffer_Page_to_Page_Buffer+0x5e>

  //写数据到Buffer中
  DF_Write_to_Buffer(Buffer1,0,TestWriteBuffer,10);
    18f2:	81 e0       	ldi	r24, 0x01	; 1
    18f4:	60 e0       	ldi	r22, 0x00	; 0
    18f6:	70 e0       	ldi	r23, 0x00	; 0
    18f8:	9e 01       	movw	r18, r28
    18fa:	2f 5f       	subi	r18, 0xFF	; 255
    18fc:	3f 4f       	sbci	r19, 0xFF	; 255
    18fe:	a9 01       	movw	r20, r18
    1900:	2a e0       	ldi	r18, 0x0A	; 10
    1902:	30 e0       	ldi	r19, 0x00	; 0
    1904:	0e 94 45 07 	call	0xe8a	; 0xe8a <DF_Write_to_Buffer>
  //将Buffer中的数据写到Page中
  DF_Write_Buffer_to_Page(Buffer1,0);
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	60 e0       	ldi	r22, 0x00	; 0
    190c:	70 e0       	ldi	r23, 0x00	; 0
    190e:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <DF_Write_Buffer_to_Page>
  //从Page中读取数据到Buffer中
  DF_Read_Buffer_from_Page(Buffer1,0);
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	60 e0       	ldi	r22, 0x00	; 0
    1916:	70 e0       	ldi	r23, 0x00	; 0
    1918:	0e 94 1b 08 	call	0x1036	; 0x1036 <DF_Read_Buffer_from_Page>
  //从Buffer中读取数据
  DF_Read_from_Buffer(Buffer1,0,TestReadBuffer,10);
    191c:	9e 01       	movw	r18, r28
    191e:	25 5f       	subi	r18, 0xF5	; 245
    1920:	3f 4f       	sbci	r19, 0xFF	; 255
    1922:	81 e0       	ldi	r24, 0x01	; 1
    1924:	60 e0       	ldi	r22, 0x00	; 0
    1926:	70 e0       	ldi	r23, 0x00	; 0
    1928:	a9 01       	movw	r20, r18
    192a:	2a e0       	ldi	r18, 0x0A	; 10
    192c:	30 e0       	ldi	r19, 0x00	; 0
    192e:	0e 94 94 07 	call	0xf28	; 0xf28 <DF_Read_from_Buffer>
  for(i=0;i<10;i++)//把要写入的和读出的数据写入EEPROM用于比较
  {
    eeprom_write_byte((i+16*6),TestWriteBuffer[i]);
	eeprom_write_byte((i+16*7),TestReadBuffer[i]);
  }*/
}
    1932:	69 96       	adiw	r28, 0x19	; 25
    1934:	0f b6       	in	r0, 0x3f	; 63
    1936:	f8 94       	cli
    1938:	de bf       	out	0x3e, r29	; 62
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	cd bf       	out	0x3d, r28	; 61
    193e:	cf 91       	pop	r28
    1940:	df 91       	pop	r29
    1942:	08 95       	ret

00001944 <uart_putchar>:
#include <avr/io.h>
#include "uart.h"

FILE uart_str = FDEV_SETUP_STREAM(uart_putchar, 0, _FDEV_SETUP_RW);
int uart_putchar(char c, FILE *stream)
{
    1944:	df 93       	push	r29
    1946:	cf 93       	push	r28
    1948:	00 d0       	rcall	.+0      	; 0x194a <uart_putchar+0x6>
    194a:	00 d0       	rcall	.+0      	; 0x194c <uart_putchar+0x8>
    194c:	0f 92       	push	r0
    194e:	cd b7       	in	r28, 0x3d	; 61
    1950:	de b7       	in	r29, 0x3e	; 62
    1952:	89 83       	std	Y+1, r24	; 0x01
    1954:	7b 83       	std	Y+3, r23	; 0x03
    1956:	6a 83       	std	Y+2, r22	; 0x02

  if (c == '\a')
    1958:	89 81       	ldd	r24, Y+1	; 0x01
    195a:	87 30       	cpi	r24, 0x07	; 7
    195c:	79 f4       	brne	.+30     	; 0x197c <uart_putchar+0x38>
    {
      fputs("*ring*\n", stderr);
    195e:	20 91 92 01 	lds	r18, 0x0192
    1962:	30 91 93 01 	lds	r19, 0x0193
    1966:	85 e5       	ldi	r24, 0x55	; 85
    1968:	91 e0       	ldi	r25, 0x01	; 1
    196a:	61 e0       	ldi	r22, 0x01	; 1
    196c:	70 e0       	ldi	r23, 0x00	; 0
    196e:	47 e0       	ldi	r20, 0x07	; 7
    1970:	50 e0       	ldi	r21, 0x00	; 0
    1972:	0e 94 ad 14 	call	0x295a	; 0x295a <fwrite>
      return 0;
    1976:	1d 82       	std	Y+5, r1	; 0x05
    1978:	1c 82       	std	Y+4, r1	; 0x04
    197a:	18 c0       	rjmp	.+48     	; 0x19ac <uart_putchar+0x68>
    }

  if (c == '\n')
    197c:	89 81       	ldd	r24, Y+1	; 0x01
    197e:	8a 30       	cpi	r24, 0x0A	; 10
    1980:	31 f4       	brne	.+12     	; 0x198e <uart_putchar+0x4a>
    uart_putchar('\r', stream);
    1982:	2a 81       	ldd	r18, Y+2	; 0x02
    1984:	3b 81       	ldd	r19, Y+3	; 0x03
    1986:	8d e0       	ldi	r24, 0x0D	; 13
    1988:	b9 01       	movw	r22, r18
    198a:	0e 94 a2 0c 	call	0x1944	; 0x1944 <uart_putchar>
  loop_until_bit_is_set(UCSR0A, UDRE0);
    198e:	eb e2       	ldi	r30, 0x2B	; 43
    1990:	f0 e0       	ldi	r31, 0x00	; 0
    1992:	80 81       	ld	r24, Z
    1994:	88 2f       	mov	r24, r24
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	80 72       	andi	r24, 0x20	; 32
    199a:	90 70       	andi	r25, 0x00	; 0
    199c:	00 97       	sbiw	r24, 0x00	; 0
    199e:	b9 f3       	breq	.-18     	; 0x198e <uart_putchar+0x4a>
  UDR0 = c;
    19a0:	ec e2       	ldi	r30, 0x2C	; 44
    19a2:	f0 e0       	ldi	r31, 0x00	; 0
    19a4:	89 81       	ldd	r24, Y+1	; 0x01
    19a6:	80 83       	st	Z, r24

  return 0;
    19a8:	1d 82       	std	Y+5, r1	; 0x05
    19aa:	1c 82       	std	Y+4, r1	; 0x04
    19ac:	8c 81       	ldd	r24, Y+4	; 0x04
    19ae:	9d 81       	ldd	r25, Y+5	; 0x05
}
    19b0:	0f 90       	pop	r0
    19b2:	0f 90       	pop	r0
    19b4:	0f 90       	pop	r0
    19b6:	0f 90       	pop	r0
    19b8:	0f 90       	pop	r0
    19ba:	cf 91       	pop	r28
    19bc:	df 91       	pop	r29
    19be:	08 95       	ret

000019c0 <uart_init>:
//*串口初始化函数*/
void uart_init(void)
{
    19c0:	df 93       	push	r29
    19c2:	cf 93       	push	r28
    19c4:	cd b7       	in	r28, 0x3d	; 61
    19c6:	de b7       	in	r29, 0x3e	; 62
	/* 初始化串口0 */
	UCSR0A = (1 << U2X0);								/*倍速*/
    19c8:	eb e2       	ldi	r30, 0x2B	; 43
    19ca:	f0 e0       	ldi	r31, 0x00	; 0
    19cc:	82 e0       	ldi	r24, 0x02	; 2
    19ce:	80 83       	st	Z, r24
	UCSR0B = (1 << TXEN0) | (1 << RXEN0)| (1<<RXCIE0); 				/*允许接收和发送，中断接收*/
    19d0:	ea e2       	ldi	r30, 0x2A	; 42
    19d2:	f0 e0       	ldi	r31, 0x00	; 0
    19d4:	88 e9       	ldi	r24, 0x98	; 152
    19d6:	80 83       	st	Z, r24
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);				/*8位数据、1 位停止、异步、无校验*/
    19d8:	e5 e9       	ldi	r30, 0x95	; 149
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	86 e0       	ldi	r24, 0x06	; 6
    19de:	80 83       	st	Z, r24
	UBRR0L = Crystal/8/(Baud0+1) % 256;   //若为正常异步模式USX0=0则位(Crystal/16/(Baud+1))%BUFFSIZE
    19e0:	e9 e2       	ldi	r30, 0x29	; 41
    19e2:	f0 e0       	ldi	r31, 0x00	; 0
    19e4:	8b e0       	ldi	r24, 0x0B	; 11
    19e6:	80 83       	st	Z, r24
	UBRR0H = Crystal/8/(Baud0+1) / 256;   //
    19e8:	e0 e9       	ldi	r30, 0x90	; 144
    19ea:	f0 e0       	ldi	r31, 0x00	; 0
    19ec:	10 82       	st	Z, r1
	
	/* 初始化串口1 */
	UCSR0A = (1 << U2X1);								/*倍速*/
    19ee:	eb e2       	ldi	r30, 0x2B	; 43
    19f0:	f0 e0       	ldi	r31, 0x00	; 0
    19f2:	82 e0       	ldi	r24, 0x02	; 2
    19f4:	80 83       	st	Z, r24
	UCSR1B = (1 << TXEN1) | (1 << RXEN1) | (1<<RXCIE1);				/*允许接收和发送，中断接收*/
    19f6:	ea e9       	ldi	r30, 0x9A	; 154
    19f8:	f0 e0       	ldi	r31, 0x00	; 0
    19fa:	88 e9       	ldi	r24, 0x98	; 152
    19fc:	80 83       	st	Z, r24
	UCSR1C = (1 << UCSZ11) | (1 << UCSZ10);				/*8位数据、1 位停止、异步、无校验*/
    19fe:	ed e9       	ldi	r30, 0x9D	; 157
    1a00:	f0 e0       	ldi	r31, 0x00	; 0
    1a02:	86 e0       	ldi	r24, 0x06	; 6
    1a04:	80 83       	st	Z, r24
	UBRR1L = Crystal/8/(Baud1+1) % 256;   //若为正常异步模式USX0=0则位(Crystal/16/(Baud+1))%BUFFSIZE
    1a06:	e9 e9       	ldi	r30, 0x99	; 153
    1a08:	f0 e0       	ldi	r31, 0x00	; 0
    1a0a:	8b e0       	ldi	r24, 0x0B	; 11
    1a0c:	80 83       	st	Z, r24
	UBRR1H = Crystal/8/(Baud1+1) / 256;   //
    1a0e:	e8 e9       	ldi	r30, 0x98	; 152
    1a10:	f0 e0       	ldi	r31, 0x00	; 0
    1a12:	10 82       	st	Z, r1
	stdout = stdin = &uart_str;
    1a14:	87 e4       	ldi	r24, 0x47	; 71
    1a16:	91 e0       	ldi	r25, 0x01	; 1
    1a18:	90 93 8f 01 	sts	0x018F, r25
    1a1c:	80 93 8e 01 	sts	0x018E, r24
    1a20:	80 91 8e 01 	lds	r24, 0x018E
    1a24:	90 91 8f 01 	lds	r25, 0x018F
    1a28:	90 93 91 01 	sts	0x0191, r25
    1a2c:	80 93 90 01 	sts	0x0190, r24
	printf("USART Init OK!\n");
    1a30:	8d e5       	ldi	r24, 0x5D	; 93
    1a32:	91 e0       	ldi	r25, 0x01	; 1
    1a34:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <puts>

}
    1a38:	cf 91       	pop	r28
    1a3a:	df 91       	pop	r29
    1a3c:	08 95       	ret

00001a3e <usart0_char_send>:

//****************发送一个字符******************************
void usart0_char_send(unsigned char data)
{
    1a3e:	df 93       	push	r29
    1a40:	cf 93       	push	r28
    1a42:	0f 92       	push	r0
    1a44:	cd b7       	in	r28, 0x3d	; 61
    1a46:	de b7       	in	r29, 0x3e	; 62
    1a48:	89 83       	std	Y+1, r24	; 0x01
	/* 等待发送缓冲区为空 */
	while (!(UCSR0A & (1<<UDRE0)));
    1a4a:	eb e2       	ldi	r30, 0x2B	; 43
    1a4c:	f0 e0       	ldi	r31, 0x00	; 0
    1a4e:	80 81       	ld	r24, Z
    1a50:	88 2f       	mov	r24, r24
    1a52:	90 e0       	ldi	r25, 0x00	; 0
    1a54:	80 72       	andi	r24, 0x20	; 32
    1a56:	90 70       	andi	r25, 0x00	; 0
    1a58:	00 97       	sbiw	r24, 0x00	; 0
    1a5a:	b9 f3       	breq	.-18     	; 0x1a4a <usart0_char_send+0xc>
	/* 将数据放入缓冲区，发送数据 */
	UDR0 = data;
    1a5c:	ec e2       	ldi	r30, 0x2C	; 44
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
    1a62:	80 83       	st	Z, r24
}
    1a64:	0f 90       	pop	r0
    1a66:	cf 91       	pop	r28
    1a68:	df 91       	pop	r29
    1a6a:	08 95       	ret

00001a6c <usart1_char_send>:
//****************发送一个字符******************************
void usart1_char_send(unsigned char data)
{
    1a6c:	df 93       	push	r29
    1a6e:	cf 93       	push	r28
    1a70:	0f 92       	push	r0
    1a72:	cd b7       	in	r28, 0x3d	; 61
    1a74:	de b7       	in	r29, 0x3e	; 62
    1a76:	89 83       	std	Y+1, r24	; 0x01
	/* 等待发送缓冲区为空 */
	while (!(UCSR1A & (1<<UDRE1)));
    1a78:	eb e9       	ldi	r30, 0x9B	; 155
    1a7a:	f0 e0       	ldi	r31, 0x00	; 0
    1a7c:	80 81       	ld	r24, Z
    1a7e:	88 2f       	mov	r24, r24
    1a80:	90 e0       	ldi	r25, 0x00	; 0
    1a82:	80 72       	andi	r24, 0x20	; 32
    1a84:	90 70       	andi	r25, 0x00	; 0
    1a86:	00 97       	sbiw	r24, 0x00	; 0
    1a88:	b9 f3       	breq	.-18     	; 0x1a78 <usart1_char_send+0xc>
	/* 将数据放入缓冲区，发送数据 */
	UDR1 = data;
    1a8a:	ec e9       	ldi	r30, 0x9C	; 156
    1a8c:	f0 e0       	ldi	r31, 0x00	; 0
    1a8e:	89 81       	ldd	r24, Y+1	; 0x01
    1a90:	80 83       	st	Z, r24
}
    1a92:	0f 90       	pop	r0
    1a94:	cf 91       	pop	r28
    1a96:	df 91       	pop	r29
    1a98:	08 95       	ret

00001a9a <usart_send>:

//******************发送字符串*************************/
void usart_send(char *s, unsigned int len, char channel)
{
    1a9a:	df 93       	push	r29
    1a9c:	cf 93       	push	r28
    1a9e:	cd b7       	in	r28, 0x3d	; 61
    1aa0:	de b7       	in	r29, 0x3e	; 62
    1aa2:	28 97       	sbiw	r28, 0x08	; 8
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	f8 94       	cli
    1aa8:	de bf       	out	0x3e, r29	; 62
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	cd bf       	out	0x3d, r28	; 61
    1aae:	9c 83       	std	Y+4, r25	; 0x04
    1ab0:	8b 83       	std	Y+3, r24	; 0x03
    1ab2:	7e 83       	std	Y+6, r23	; 0x06
    1ab4:	6d 83       	std	Y+5, r22	; 0x05
    1ab6:	4f 83       	std	Y+7, r20	; 0x07
	void (*f)(unsigned char data);
	//unsigned int i;
	if (CH_USART1 == channel)
    1ab8:	8f 81       	ldd	r24, Y+7	; 0x07
    1aba:	81 30       	cpi	r24, 0x01	; 1
    1abc:	29 f4       	brne	.+10     	; 0x1ac8 <usart_send+0x2e>
		f = usart1_char_send;
    1abe:	86 e3       	ldi	r24, 0x36	; 54
    1ac0:	9d e0       	ldi	r25, 0x0D	; 13
    1ac2:	9a 83       	std	Y+2, r25	; 0x02
    1ac4:	89 83       	std	Y+1, r24	; 0x01
    1ac6:	10 c0       	rjmp	.+32     	; 0x1ae8 <usart_send+0x4e>
	else
		f = usart0_char_send;
    1ac8:	8f e1       	ldi	r24, 0x1F	; 31
    1aca:	9d e0       	ldi	r25, 0x0D	; 13
    1acc:	9a 83       	std	Y+2, r25	; 0x02
    1ace:	89 83       	std	Y+1, r24	; 0x01
    1ad0:	0b c0       	rjmp	.+22     	; 0x1ae8 <usart_send+0x4e>

	while(len--)
	{
		(*f)(*s);
    1ad2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad6:	80 81       	ld	r24, Z
    1ad8:	e9 81       	ldd	r30, Y+1	; 0x01
    1ada:	fa 81       	ldd	r31, Y+2	; 0x02
    1adc:	09 95       	icall
		s++;
    1ade:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae2:	01 96       	adiw	r24, 0x01	; 1
    1ae4:	9c 83       	std	Y+4, r25	; 0x04
    1ae6:	8b 83       	std	Y+3, r24	; 0x03
	if (CH_USART1 == channel)
		f = usart1_char_send;
	else
		f = usart0_char_send;

	while(len--)
    1ae8:	18 86       	std	Y+8, r1	; 0x08
    1aea:	8d 81       	ldd	r24, Y+5	; 0x05
    1aec:	9e 81       	ldd	r25, Y+6	; 0x06
    1aee:	00 97       	sbiw	r24, 0x00	; 0
    1af0:	11 f0       	breq	.+4      	; 0x1af6 <usart_send+0x5c>
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	88 87       	std	Y+8, r24	; 0x08
    1af6:	8d 81       	ldd	r24, Y+5	; 0x05
    1af8:	9e 81       	ldd	r25, Y+6	; 0x06
    1afa:	01 97       	sbiw	r24, 0x01	; 1
    1afc:	9e 83       	std	Y+6, r25	; 0x06
    1afe:	8d 83       	std	Y+5, r24	; 0x05
    1b00:	88 85       	ldd	r24, Y+8	; 0x08
    1b02:	88 23       	and	r24, r24
    1b04:	31 f7       	brne	.-52     	; 0x1ad2 <usart_send+0x38>
	{
		(*f)(*s);
		s++;
	}
}
    1b06:	28 96       	adiw	r28, 0x08	; 8
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	f8 94       	cli
    1b0c:	de bf       	out	0x3e, r29	; 62
    1b0e:	0f be       	out	0x3f, r0	; 63
    1b10:	cd bf       	out	0x3d, r28	; 61
    1b12:	cf 91       	pop	r28
    1b14:	df 91       	pop	r29
    1b16:	08 95       	ret

00001b18 <usart0_char_receive>:

/*****************接收一个字符****************************/
unsigned char usart0_char_receive(void)
{
    1b18:	df 93       	push	r29
    1b1a:	cf 93       	push	r28
    1b1c:	cd b7       	in	r28, 0x3d	; 61
    1b1e:	de b7       	in	r29, 0x3e	; 62
	while (!(UCSR0A & (1<<RXC0)));
    1b20:	eb e2       	ldi	r30, 0x2B	; 43
    1b22:	f0 e0       	ldi	r31, 0x00	; 0
    1b24:	80 81       	ld	r24, Z
    1b26:	88 23       	and	r24, r24
    1b28:	dc f7       	brge	.-10     	; 0x1b20 <usart0_char_receive+0x8>
	return UDR0;
    1b2a:	ec e2       	ldi	r30, 0x2C	; 44
    1b2c:	f0 e0       	ldi	r31, 0x00	; 0
    1b2e:	80 81       	ld	r24, Z
}
    1b30:	cf 91       	pop	r28
    1b32:	df 91       	pop	r29
    1b34:	08 95       	ret

00001b36 <__fixunssfsi>:
    1b36:	ef 92       	push	r14
    1b38:	ff 92       	push	r15
    1b3a:	0f 93       	push	r16
    1b3c:	1f 93       	push	r17
    1b3e:	7b 01       	movw	r14, r22
    1b40:	8c 01       	movw	r16, r24
    1b42:	20 e0       	ldi	r18, 0x00	; 0
    1b44:	30 e0       	ldi	r19, 0x00	; 0
    1b46:	40 e0       	ldi	r20, 0x00	; 0
    1b48:	5f e4       	ldi	r21, 0x4F	; 79
    1b4a:	0e 94 47 11 	call	0x228e	; 0x228e <__gesf2>
    1b4e:	88 23       	and	r24, r24
    1b50:	8c f0       	brlt	.+34     	; 0x1b74 <__fixunssfsi+0x3e>
    1b52:	c8 01       	movw	r24, r16
    1b54:	b7 01       	movw	r22, r14
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e0       	ldi	r20, 0x00	; 0
    1b5c:	5f e4       	ldi	r21, 0x4F	; 79
    1b5e:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <__subsf3>
    1b62:	0e 94 a7 11 	call	0x234e	; 0x234e <__fixsfsi>
    1b66:	9b 01       	movw	r18, r22
    1b68:	ac 01       	movw	r20, r24
    1b6a:	20 50       	subi	r18, 0x00	; 0
    1b6c:	30 40       	sbci	r19, 0x00	; 0
    1b6e:	40 40       	sbci	r20, 0x00	; 0
    1b70:	50 48       	sbci	r21, 0x80	; 128
    1b72:	06 c0       	rjmp	.+12     	; 0x1b80 <__fixunssfsi+0x4a>
    1b74:	c8 01       	movw	r24, r16
    1b76:	b7 01       	movw	r22, r14
    1b78:	0e 94 a7 11 	call	0x234e	; 0x234e <__fixsfsi>
    1b7c:	9b 01       	movw	r18, r22
    1b7e:	ac 01       	movw	r20, r24
    1b80:	b9 01       	movw	r22, r18
    1b82:	ca 01       	movw	r24, r20
    1b84:	1f 91       	pop	r17
    1b86:	0f 91       	pop	r16
    1b88:	ff 90       	pop	r15
    1b8a:	ef 90       	pop	r14
    1b8c:	08 95       	ret

00001b8e <_fpadd_parts>:
    1b8e:	a0 e0       	ldi	r26, 0x00	; 0
    1b90:	b0 e0       	ldi	r27, 0x00	; 0
    1b92:	ed ec       	ldi	r30, 0xCD	; 205
    1b94:	fd e0       	ldi	r31, 0x0D	; 13
    1b96:	0c 94 17 15 	jmp	0x2a2e	; 0x2a2e <__prologue_saves__>
    1b9a:	dc 01       	movw	r26, r24
    1b9c:	2b 01       	movw	r4, r22
    1b9e:	fa 01       	movw	r30, r20
    1ba0:	9c 91       	ld	r25, X
    1ba2:	92 30       	cpi	r25, 0x02	; 2
    1ba4:	08 f4       	brcc	.+2      	; 0x1ba8 <_fpadd_parts+0x1a>
    1ba6:	39 c1       	rjmp	.+626    	; 0x1e1a <_fpadd_parts+0x28c>
    1ba8:	eb 01       	movw	r28, r22
    1baa:	88 81       	ld	r24, Y
    1bac:	82 30       	cpi	r24, 0x02	; 2
    1bae:	08 f4       	brcc	.+2      	; 0x1bb2 <_fpadd_parts+0x24>
    1bb0:	33 c1       	rjmp	.+614    	; 0x1e18 <_fpadd_parts+0x28a>
    1bb2:	94 30       	cpi	r25, 0x04	; 4
    1bb4:	69 f4       	brne	.+26     	; 0x1bd0 <_fpadd_parts+0x42>
    1bb6:	84 30       	cpi	r24, 0x04	; 4
    1bb8:	09 f0       	breq	.+2      	; 0x1bbc <_fpadd_parts+0x2e>
    1bba:	2f c1       	rjmp	.+606    	; 0x1e1a <_fpadd_parts+0x28c>
    1bbc:	11 96       	adiw	r26, 0x01	; 1
    1bbe:	9c 91       	ld	r25, X
    1bc0:	11 97       	sbiw	r26, 0x01	; 1
    1bc2:	89 81       	ldd	r24, Y+1	; 0x01
    1bc4:	98 17       	cp	r25, r24
    1bc6:	09 f4       	brne	.+2      	; 0x1bca <_fpadd_parts+0x3c>
    1bc8:	28 c1       	rjmp	.+592    	; 0x1e1a <_fpadd_parts+0x28c>
    1bca:	ac e6       	ldi	r26, 0x6C	; 108
    1bcc:	b1 e0       	ldi	r27, 0x01	; 1
    1bce:	25 c1       	rjmp	.+586    	; 0x1e1a <_fpadd_parts+0x28c>
    1bd0:	84 30       	cpi	r24, 0x04	; 4
    1bd2:	09 f4       	brne	.+2      	; 0x1bd6 <_fpadd_parts+0x48>
    1bd4:	21 c1       	rjmp	.+578    	; 0x1e18 <_fpadd_parts+0x28a>
    1bd6:	82 30       	cpi	r24, 0x02	; 2
    1bd8:	a9 f4       	brne	.+42     	; 0x1c04 <_fpadd_parts+0x76>
    1bda:	92 30       	cpi	r25, 0x02	; 2
    1bdc:	09 f0       	breq	.+2      	; 0x1be0 <_fpadd_parts+0x52>
    1bde:	1d c1       	rjmp	.+570    	; 0x1e1a <_fpadd_parts+0x28c>
    1be0:	9a 01       	movw	r18, r20
    1be2:	ad 01       	movw	r20, r26
    1be4:	88 e0       	ldi	r24, 0x08	; 8
    1be6:	ea 01       	movw	r28, r20
    1be8:	09 90       	ld	r0, Y+
    1bea:	ae 01       	movw	r20, r28
    1bec:	e9 01       	movw	r28, r18
    1bee:	09 92       	st	Y+, r0
    1bf0:	9e 01       	movw	r18, r28
    1bf2:	81 50       	subi	r24, 0x01	; 1
    1bf4:	c1 f7       	brne	.-16     	; 0x1be6 <_fpadd_parts+0x58>
    1bf6:	e2 01       	movw	r28, r4
    1bf8:	89 81       	ldd	r24, Y+1	; 0x01
    1bfa:	11 96       	adiw	r26, 0x01	; 1
    1bfc:	9c 91       	ld	r25, X
    1bfe:	89 23       	and	r24, r25
    1c00:	81 83       	std	Z+1, r24	; 0x01
    1c02:	08 c1       	rjmp	.+528    	; 0x1e14 <_fpadd_parts+0x286>
    1c04:	92 30       	cpi	r25, 0x02	; 2
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <_fpadd_parts+0x7c>
    1c08:	07 c1       	rjmp	.+526    	; 0x1e18 <_fpadd_parts+0x28a>
    1c0a:	12 96       	adiw	r26, 0x02	; 2
    1c0c:	2d 90       	ld	r2, X+
    1c0e:	3c 90       	ld	r3, X
    1c10:	13 97       	sbiw	r26, 0x03	; 3
    1c12:	eb 01       	movw	r28, r22
    1c14:	8a 81       	ldd	r24, Y+2	; 0x02
    1c16:	9b 81       	ldd	r25, Y+3	; 0x03
    1c18:	14 96       	adiw	r26, 0x04	; 4
    1c1a:	ad 90       	ld	r10, X+
    1c1c:	bd 90       	ld	r11, X+
    1c1e:	cd 90       	ld	r12, X+
    1c20:	dc 90       	ld	r13, X
    1c22:	17 97       	sbiw	r26, 0x07	; 7
    1c24:	ec 80       	ldd	r14, Y+4	; 0x04
    1c26:	fd 80       	ldd	r15, Y+5	; 0x05
    1c28:	0e 81       	ldd	r16, Y+6	; 0x06
    1c2a:	1f 81       	ldd	r17, Y+7	; 0x07
    1c2c:	91 01       	movw	r18, r2
    1c2e:	28 1b       	sub	r18, r24
    1c30:	39 0b       	sbc	r19, r25
    1c32:	b9 01       	movw	r22, r18
    1c34:	37 ff       	sbrs	r19, 7
    1c36:	04 c0       	rjmp	.+8      	; 0x1c40 <_fpadd_parts+0xb2>
    1c38:	66 27       	eor	r22, r22
    1c3a:	77 27       	eor	r23, r23
    1c3c:	62 1b       	sub	r22, r18
    1c3e:	73 0b       	sbc	r23, r19
    1c40:	60 32       	cpi	r22, 0x20	; 32
    1c42:	71 05       	cpc	r23, r1
    1c44:	0c f0       	brlt	.+2      	; 0x1c48 <_fpadd_parts+0xba>
    1c46:	61 c0       	rjmp	.+194    	; 0x1d0a <_fpadd_parts+0x17c>
    1c48:	12 16       	cp	r1, r18
    1c4a:	13 06       	cpc	r1, r19
    1c4c:	6c f5       	brge	.+90     	; 0x1ca8 <_fpadd_parts+0x11a>
    1c4e:	37 01       	movw	r6, r14
    1c50:	48 01       	movw	r8, r16
    1c52:	06 2e       	mov	r0, r22
    1c54:	04 c0       	rjmp	.+8      	; 0x1c5e <_fpadd_parts+0xd0>
    1c56:	96 94       	lsr	r9
    1c58:	87 94       	ror	r8
    1c5a:	77 94       	ror	r7
    1c5c:	67 94       	ror	r6
    1c5e:	0a 94       	dec	r0
    1c60:	d2 f7       	brpl	.-12     	; 0x1c56 <_fpadd_parts+0xc8>
    1c62:	21 e0       	ldi	r18, 0x01	; 1
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	40 e0       	ldi	r20, 0x00	; 0
    1c68:	50 e0       	ldi	r21, 0x00	; 0
    1c6a:	04 c0       	rjmp	.+8      	; 0x1c74 <_fpadd_parts+0xe6>
    1c6c:	22 0f       	add	r18, r18
    1c6e:	33 1f       	adc	r19, r19
    1c70:	44 1f       	adc	r20, r20
    1c72:	55 1f       	adc	r21, r21
    1c74:	6a 95       	dec	r22
    1c76:	d2 f7       	brpl	.-12     	; 0x1c6c <_fpadd_parts+0xde>
    1c78:	21 50       	subi	r18, 0x01	; 1
    1c7a:	30 40       	sbci	r19, 0x00	; 0
    1c7c:	40 40       	sbci	r20, 0x00	; 0
    1c7e:	50 40       	sbci	r21, 0x00	; 0
    1c80:	2e 21       	and	r18, r14
    1c82:	3f 21       	and	r19, r15
    1c84:	40 23       	and	r20, r16
    1c86:	51 23       	and	r21, r17
    1c88:	21 15       	cp	r18, r1
    1c8a:	31 05       	cpc	r19, r1
    1c8c:	41 05       	cpc	r20, r1
    1c8e:	51 05       	cpc	r21, r1
    1c90:	21 f0       	breq	.+8      	; 0x1c9a <_fpadd_parts+0x10c>
    1c92:	21 e0       	ldi	r18, 0x01	; 1
    1c94:	30 e0       	ldi	r19, 0x00	; 0
    1c96:	40 e0       	ldi	r20, 0x00	; 0
    1c98:	50 e0       	ldi	r21, 0x00	; 0
    1c9a:	79 01       	movw	r14, r18
    1c9c:	8a 01       	movw	r16, r20
    1c9e:	e6 28       	or	r14, r6
    1ca0:	f7 28       	or	r15, r7
    1ca2:	08 29       	or	r16, r8
    1ca4:	19 29       	or	r17, r9
    1ca6:	3c c0       	rjmp	.+120    	; 0x1d20 <_fpadd_parts+0x192>
    1ca8:	23 2b       	or	r18, r19
    1caa:	d1 f1       	breq	.+116    	; 0x1d20 <_fpadd_parts+0x192>
    1cac:	26 0e       	add	r2, r22
    1cae:	37 1e       	adc	r3, r23
    1cb0:	35 01       	movw	r6, r10
    1cb2:	46 01       	movw	r8, r12
    1cb4:	06 2e       	mov	r0, r22
    1cb6:	04 c0       	rjmp	.+8      	; 0x1cc0 <_fpadd_parts+0x132>
    1cb8:	96 94       	lsr	r9
    1cba:	87 94       	ror	r8
    1cbc:	77 94       	ror	r7
    1cbe:	67 94       	ror	r6
    1cc0:	0a 94       	dec	r0
    1cc2:	d2 f7       	brpl	.-12     	; 0x1cb8 <_fpadd_parts+0x12a>
    1cc4:	21 e0       	ldi	r18, 0x01	; 1
    1cc6:	30 e0       	ldi	r19, 0x00	; 0
    1cc8:	40 e0       	ldi	r20, 0x00	; 0
    1cca:	50 e0       	ldi	r21, 0x00	; 0
    1ccc:	04 c0       	rjmp	.+8      	; 0x1cd6 <_fpadd_parts+0x148>
    1cce:	22 0f       	add	r18, r18
    1cd0:	33 1f       	adc	r19, r19
    1cd2:	44 1f       	adc	r20, r20
    1cd4:	55 1f       	adc	r21, r21
    1cd6:	6a 95       	dec	r22
    1cd8:	d2 f7       	brpl	.-12     	; 0x1cce <_fpadd_parts+0x140>
    1cda:	21 50       	subi	r18, 0x01	; 1
    1cdc:	30 40       	sbci	r19, 0x00	; 0
    1cde:	40 40       	sbci	r20, 0x00	; 0
    1ce0:	50 40       	sbci	r21, 0x00	; 0
    1ce2:	2a 21       	and	r18, r10
    1ce4:	3b 21       	and	r19, r11
    1ce6:	4c 21       	and	r20, r12
    1ce8:	5d 21       	and	r21, r13
    1cea:	21 15       	cp	r18, r1
    1cec:	31 05       	cpc	r19, r1
    1cee:	41 05       	cpc	r20, r1
    1cf0:	51 05       	cpc	r21, r1
    1cf2:	21 f0       	breq	.+8      	; 0x1cfc <_fpadd_parts+0x16e>
    1cf4:	21 e0       	ldi	r18, 0x01	; 1
    1cf6:	30 e0       	ldi	r19, 0x00	; 0
    1cf8:	40 e0       	ldi	r20, 0x00	; 0
    1cfa:	50 e0       	ldi	r21, 0x00	; 0
    1cfc:	59 01       	movw	r10, r18
    1cfe:	6a 01       	movw	r12, r20
    1d00:	a6 28       	or	r10, r6
    1d02:	b7 28       	or	r11, r7
    1d04:	c8 28       	or	r12, r8
    1d06:	d9 28       	or	r13, r9
    1d08:	0b c0       	rjmp	.+22     	; 0x1d20 <_fpadd_parts+0x192>
    1d0a:	82 15       	cp	r24, r2
    1d0c:	93 05       	cpc	r25, r3
    1d0e:	2c f0       	brlt	.+10     	; 0x1d1a <_fpadd_parts+0x18c>
    1d10:	1c 01       	movw	r2, r24
    1d12:	aa 24       	eor	r10, r10
    1d14:	bb 24       	eor	r11, r11
    1d16:	65 01       	movw	r12, r10
    1d18:	03 c0       	rjmp	.+6      	; 0x1d20 <_fpadd_parts+0x192>
    1d1a:	ee 24       	eor	r14, r14
    1d1c:	ff 24       	eor	r15, r15
    1d1e:	87 01       	movw	r16, r14
    1d20:	11 96       	adiw	r26, 0x01	; 1
    1d22:	9c 91       	ld	r25, X
    1d24:	d2 01       	movw	r26, r4
    1d26:	11 96       	adiw	r26, 0x01	; 1
    1d28:	8c 91       	ld	r24, X
    1d2a:	98 17       	cp	r25, r24
    1d2c:	09 f4       	brne	.+2      	; 0x1d30 <_fpadd_parts+0x1a2>
    1d2e:	45 c0       	rjmp	.+138    	; 0x1dba <_fpadd_parts+0x22c>
    1d30:	99 23       	and	r25, r25
    1d32:	39 f0       	breq	.+14     	; 0x1d42 <_fpadd_parts+0x1b4>
    1d34:	a8 01       	movw	r20, r16
    1d36:	97 01       	movw	r18, r14
    1d38:	2a 19       	sub	r18, r10
    1d3a:	3b 09       	sbc	r19, r11
    1d3c:	4c 09       	sbc	r20, r12
    1d3e:	5d 09       	sbc	r21, r13
    1d40:	06 c0       	rjmp	.+12     	; 0x1d4e <_fpadd_parts+0x1c0>
    1d42:	a6 01       	movw	r20, r12
    1d44:	95 01       	movw	r18, r10
    1d46:	2e 19       	sub	r18, r14
    1d48:	3f 09       	sbc	r19, r15
    1d4a:	40 0b       	sbc	r20, r16
    1d4c:	51 0b       	sbc	r21, r17
    1d4e:	57 fd       	sbrc	r21, 7
    1d50:	08 c0       	rjmp	.+16     	; 0x1d62 <_fpadd_parts+0x1d4>
    1d52:	11 82       	std	Z+1, r1	; 0x01
    1d54:	33 82       	std	Z+3, r3	; 0x03
    1d56:	22 82       	std	Z+2, r2	; 0x02
    1d58:	24 83       	std	Z+4, r18	; 0x04
    1d5a:	35 83       	std	Z+5, r19	; 0x05
    1d5c:	46 83       	std	Z+6, r20	; 0x06
    1d5e:	57 83       	std	Z+7, r21	; 0x07
    1d60:	1d c0       	rjmp	.+58     	; 0x1d9c <_fpadd_parts+0x20e>
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	81 83       	std	Z+1, r24	; 0x01
    1d66:	33 82       	std	Z+3, r3	; 0x03
    1d68:	22 82       	std	Z+2, r2	; 0x02
    1d6a:	88 27       	eor	r24, r24
    1d6c:	99 27       	eor	r25, r25
    1d6e:	dc 01       	movw	r26, r24
    1d70:	82 1b       	sub	r24, r18
    1d72:	93 0b       	sbc	r25, r19
    1d74:	a4 0b       	sbc	r26, r20
    1d76:	b5 0b       	sbc	r27, r21
    1d78:	84 83       	std	Z+4, r24	; 0x04
    1d7a:	95 83       	std	Z+5, r25	; 0x05
    1d7c:	a6 83       	std	Z+6, r26	; 0x06
    1d7e:	b7 83       	std	Z+7, r27	; 0x07
    1d80:	0d c0       	rjmp	.+26     	; 0x1d9c <_fpadd_parts+0x20e>
    1d82:	22 0f       	add	r18, r18
    1d84:	33 1f       	adc	r19, r19
    1d86:	44 1f       	adc	r20, r20
    1d88:	55 1f       	adc	r21, r21
    1d8a:	24 83       	std	Z+4, r18	; 0x04
    1d8c:	35 83       	std	Z+5, r19	; 0x05
    1d8e:	46 83       	std	Z+6, r20	; 0x06
    1d90:	57 83       	std	Z+7, r21	; 0x07
    1d92:	82 81       	ldd	r24, Z+2	; 0x02
    1d94:	93 81       	ldd	r25, Z+3	; 0x03
    1d96:	01 97       	sbiw	r24, 0x01	; 1
    1d98:	93 83       	std	Z+3, r25	; 0x03
    1d9a:	82 83       	std	Z+2, r24	; 0x02
    1d9c:	24 81       	ldd	r18, Z+4	; 0x04
    1d9e:	35 81       	ldd	r19, Z+5	; 0x05
    1da0:	46 81       	ldd	r20, Z+6	; 0x06
    1da2:	57 81       	ldd	r21, Z+7	; 0x07
    1da4:	da 01       	movw	r26, r20
    1da6:	c9 01       	movw	r24, r18
    1da8:	01 97       	sbiw	r24, 0x01	; 1
    1daa:	a1 09       	sbc	r26, r1
    1dac:	b1 09       	sbc	r27, r1
    1dae:	8f 5f       	subi	r24, 0xFF	; 255
    1db0:	9f 4f       	sbci	r25, 0xFF	; 255
    1db2:	af 4f       	sbci	r26, 0xFF	; 255
    1db4:	bf 43       	sbci	r27, 0x3F	; 63
    1db6:	28 f3       	brcs	.-54     	; 0x1d82 <_fpadd_parts+0x1f4>
    1db8:	0b c0       	rjmp	.+22     	; 0x1dd0 <_fpadd_parts+0x242>
    1dba:	91 83       	std	Z+1, r25	; 0x01
    1dbc:	33 82       	std	Z+3, r3	; 0x03
    1dbe:	22 82       	std	Z+2, r2	; 0x02
    1dc0:	ea 0c       	add	r14, r10
    1dc2:	fb 1c       	adc	r15, r11
    1dc4:	0c 1d       	adc	r16, r12
    1dc6:	1d 1d       	adc	r17, r13
    1dc8:	e4 82       	std	Z+4, r14	; 0x04
    1dca:	f5 82       	std	Z+5, r15	; 0x05
    1dcc:	06 83       	std	Z+6, r16	; 0x06
    1dce:	17 83       	std	Z+7, r17	; 0x07
    1dd0:	83 e0       	ldi	r24, 0x03	; 3
    1dd2:	80 83       	st	Z, r24
    1dd4:	24 81       	ldd	r18, Z+4	; 0x04
    1dd6:	35 81       	ldd	r19, Z+5	; 0x05
    1dd8:	46 81       	ldd	r20, Z+6	; 0x06
    1dda:	57 81       	ldd	r21, Z+7	; 0x07
    1ddc:	57 ff       	sbrs	r21, 7
    1dde:	1a c0       	rjmp	.+52     	; 0x1e14 <_fpadd_parts+0x286>
    1de0:	c9 01       	movw	r24, r18
    1de2:	aa 27       	eor	r26, r26
    1de4:	97 fd       	sbrc	r25, 7
    1de6:	a0 95       	com	r26
    1de8:	ba 2f       	mov	r27, r26
    1dea:	81 70       	andi	r24, 0x01	; 1
    1dec:	90 70       	andi	r25, 0x00	; 0
    1dee:	a0 70       	andi	r26, 0x00	; 0
    1df0:	b0 70       	andi	r27, 0x00	; 0
    1df2:	56 95       	lsr	r21
    1df4:	47 95       	ror	r20
    1df6:	37 95       	ror	r19
    1df8:	27 95       	ror	r18
    1dfa:	82 2b       	or	r24, r18
    1dfc:	93 2b       	or	r25, r19
    1dfe:	a4 2b       	or	r26, r20
    1e00:	b5 2b       	or	r27, r21
    1e02:	84 83       	std	Z+4, r24	; 0x04
    1e04:	95 83       	std	Z+5, r25	; 0x05
    1e06:	a6 83       	std	Z+6, r26	; 0x06
    1e08:	b7 83       	std	Z+7, r27	; 0x07
    1e0a:	82 81       	ldd	r24, Z+2	; 0x02
    1e0c:	93 81       	ldd	r25, Z+3	; 0x03
    1e0e:	01 96       	adiw	r24, 0x01	; 1
    1e10:	93 83       	std	Z+3, r25	; 0x03
    1e12:	82 83       	std	Z+2, r24	; 0x02
    1e14:	df 01       	movw	r26, r30
    1e16:	01 c0       	rjmp	.+2      	; 0x1e1a <_fpadd_parts+0x28c>
    1e18:	d2 01       	movw	r26, r4
    1e1a:	cd 01       	movw	r24, r26
    1e1c:	cd b7       	in	r28, 0x3d	; 61
    1e1e:	de b7       	in	r29, 0x3e	; 62
    1e20:	e2 e1       	ldi	r30, 0x12	; 18
    1e22:	0c 94 33 15 	jmp	0x2a66	; 0x2a66 <__epilogue_restores__>

00001e26 <__subsf3>:
    1e26:	a0 e2       	ldi	r26, 0x20	; 32
    1e28:	b0 e0       	ldi	r27, 0x00	; 0
    1e2a:	e9 e1       	ldi	r30, 0x19	; 25
    1e2c:	ff e0       	ldi	r31, 0x0F	; 15
    1e2e:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__prologue_saves__+0x18>
    1e32:	69 83       	std	Y+1, r22	; 0x01
    1e34:	7a 83       	std	Y+2, r23	; 0x02
    1e36:	8b 83       	std	Y+3, r24	; 0x03
    1e38:	9c 83       	std	Y+4, r25	; 0x04
    1e3a:	2d 83       	std	Y+5, r18	; 0x05
    1e3c:	3e 83       	std	Y+6, r19	; 0x06
    1e3e:	4f 83       	std	Y+7, r20	; 0x07
    1e40:	58 87       	std	Y+8, r21	; 0x08
    1e42:	e9 e0       	ldi	r30, 0x09	; 9
    1e44:	ee 2e       	mov	r14, r30
    1e46:	f1 2c       	mov	r15, r1
    1e48:	ec 0e       	add	r14, r28
    1e4a:	fd 1e       	adc	r15, r29
    1e4c:	ce 01       	movw	r24, r28
    1e4e:	01 96       	adiw	r24, 0x01	; 1
    1e50:	b7 01       	movw	r22, r14
    1e52:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    1e56:	8e 01       	movw	r16, r28
    1e58:	0f 5e       	subi	r16, 0xEF	; 239
    1e5a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e5c:	ce 01       	movw	r24, r28
    1e5e:	05 96       	adiw	r24, 0x05	; 5
    1e60:	b8 01       	movw	r22, r16
    1e62:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    1e66:	8a 89       	ldd	r24, Y+18	; 0x12
    1e68:	91 e0       	ldi	r25, 0x01	; 1
    1e6a:	89 27       	eor	r24, r25
    1e6c:	8a 8b       	std	Y+18, r24	; 0x12
    1e6e:	c7 01       	movw	r24, r14
    1e70:	b8 01       	movw	r22, r16
    1e72:	ae 01       	movw	r20, r28
    1e74:	47 5e       	subi	r20, 0xE7	; 231
    1e76:	5f 4f       	sbci	r21, 0xFF	; 255
    1e78:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <_fpadd_parts>
    1e7c:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__pack_f>
    1e80:	a0 96       	adiw	r28, 0x20	; 32
    1e82:	e6 e0       	ldi	r30, 0x06	; 6
    1e84:	0c 94 3f 15 	jmp	0x2a7e	; 0x2a7e <__epilogue_restores__+0x18>

00001e88 <__addsf3>:
    1e88:	a0 e2       	ldi	r26, 0x20	; 32
    1e8a:	b0 e0       	ldi	r27, 0x00	; 0
    1e8c:	ea e4       	ldi	r30, 0x4A	; 74
    1e8e:	ff e0       	ldi	r31, 0x0F	; 15
    1e90:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__prologue_saves__+0x18>
    1e94:	69 83       	std	Y+1, r22	; 0x01
    1e96:	7a 83       	std	Y+2, r23	; 0x02
    1e98:	8b 83       	std	Y+3, r24	; 0x03
    1e9a:	9c 83       	std	Y+4, r25	; 0x04
    1e9c:	2d 83       	std	Y+5, r18	; 0x05
    1e9e:	3e 83       	std	Y+6, r19	; 0x06
    1ea0:	4f 83       	std	Y+7, r20	; 0x07
    1ea2:	58 87       	std	Y+8, r21	; 0x08
    1ea4:	f9 e0       	ldi	r31, 0x09	; 9
    1ea6:	ef 2e       	mov	r14, r31
    1ea8:	f1 2c       	mov	r15, r1
    1eaa:	ec 0e       	add	r14, r28
    1eac:	fd 1e       	adc	r15, r29
    1eae:	ce 01       	movw	r24, r28
    1eb0:	01 96       	adiw	r24, 0x01	; 1
    1eb2:	b7 01       	movw	r22, r14
    1eb4:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    1eb8:	8e 01       	movw	r16, r28
    1eba:	0f 5e       	subi	r16, 0xEF	; 239
    1ebc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ebe:	ce 01       	movw	r24, r28
    1ec0:	05 96       	adiw	r24, 0x05	; 5
    1ec2:	b8 01       	movw	r22, r16
    1ec4:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    1ec8:	c7 01       	movw	r24, r14
    1eca:	b8 01       	movw	r22, r16
    1ecc:	ae 01       	movw	r20, r28
    1ece:	47 5e       	subi	r20, 0xE7	; 231
    1ed0:	5f 4f       	sbci	r21, 0xFF	; 255
    1ed2:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <_fpadd_parts>
    1ed6:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__pack_f>
    1eda:	a0 96       	adiw	r28, 0x20	; 32
    1edc:	e6 e0       	ldi	r30, 0x06	; 6
    1ede:	0c 94 3f 15 	jmp	0x2a7e	; 0x2a7e <__epilogue_restores__+0x18>

00001ee2 <__mulsf3>:
    1ee2:	a0 e2       	ldi	r26, 0x20	; 32
    1ee4:	b0 e0       	ldi	r27, 0x00	; 0
    1ee6:	e7 e7       	ldi	r30, 0x77	; 119
    1ee8:	ff e0       	ldi	r31, 0x0F	; 15
    1eea:	0c 94 17 15 	jmp	0x2a2e	; 0x2a2e <__prologue_saves__>
    1eee:	69 83       	std	Y+1, r22	; 0x01
    1ef0:	7a 83       	std	Y+2, r23	; 0x02
    1ef2:	8b 83       	std	Y+3, r24	; 0x03
    1ef4:	9c 83       	std	Y+4, r25	; 0x04
    1ef6:	2d 83       	std	Y+5, r18	; 0x05
    1ef8:	3e 83       	std	Y+6, r19	; 0x06
    1efa:	4f 83       	std	Y+7, r20	; 0x07
    1efc:	58 87       	std	Y+8, r21	; 0x08
    1efe:	ce 01       	movw	r24, r28
    1f00:	01 96       	adiw	r24, 0x01	; 1
    1f02:	be 01       	movw	r22, r28
    1f04:	67 5f       	subi	r22, 0xF7	; 247
    1f06:	7f 4f       	sbci	r23, 0xFF	; 255
    1f08:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    1f0c:	ce 01       	movw	r24, r28
    1f0e:	05 96       	adiw	r24, 0x05	; 5
    1f10:	be 01       	movw	r22, r28
    1f12:	6f 5e       	subi	r22, 0xEF	; 239
    1f14:	7f 4f       	sbci	r23, 0xFF	; 255
    1f16:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    1f1a:	99 85       	ldd	r25, Y+9	; 0x09
    1f1c:	92 30       	cpi	r25, 0x02	; 2
    1f1e:	88 f0       	brcs	.+34     	; 0x1f42 <__mulsf3+0x60>
    1f20:	89 89       	ldd	r24, Y+17	; 0x11
    1f22:	82 30       	cpi	r24, 0x02	; 2
    1f24:	c8 f0       	brcs	.+50     	; 0x1f58 <__mulsf3+0x76>
    1f26:	94 30       	cpi	r25, 0x04	; 4
    1f28:	19 f4       	brne	.+6      	; 0x1f30 <__mulsf3+0x4e>
    1f2a:	82 30       	cpi	r24, 0x02	; 2
    1f2c:	51 f4       	brne	.+20     	; 0x1f42 <__mulsf3+0x60>
    1f2e:	04 c0       	rjmp	.+8      	; 0x1f38 <__mulsf3+0x56>
    1f30:	84 30       	cpi	r24, 0x04	; 4
    1f32:	29 f4       	brne	.+10     	; 0x1f3e <__mulsf3+0x5c>
    1f34:	92 30       	cpi	r25, 0x02	; 2
    1f36:	81 f4       	brne	.+32     	; 0x1f58 <__mulsf3+0x76>
    1f38:	8c e6       	ldi	r24, 0x6C	; 108
    1f3a:	91 e0       	ldi	r25, 0x01	; 1
    1f3c:	c6 c0       	rjmp	.+396    	; 0x20ca <__mulsf3+0x1e8>
    1f3e:	92 30       	cpi	r25, 0x02	; 2
    1f40:	49 f4       	brne	.+18     	; 0x1f54 <__mulsf3+0x72>
    1f42:	20 e0       	ldi	r18, 0x00	; 0
    1f44:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f46:	8a 89       	ldd	r24, Y+18	; 0x12
    1f48:	98 13       	cpse	r25, r24
    1f4a:	21 e0       	ldi	r18, 0x01	; 1
    1f4c:	2a 87       	std	Y+10, r18	; 0x0a
    1f4e:	ce 01       	movw	r24, r28
    1f50:	09 96       	adiw	r24, 0x09	; 9
    1f52:	bb c0       	rjmp	.+374    	; 0x20ca <__mulsf3+0x1e8>
    1f54:	82 30       	cpi	r24, 0x02	; 2
    1f56:	49 f4       	brne	.+18     	; 0x1f6a <__mulsf3+0x88>
    1f58:	20 e0       	ldi	r18, 0x00	; 0
    1f5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f5c:	8a 89       	ldd	r24, Y+18	; 0x12
    1f5e:	98 13       	cpse	r25, r24
    1f60:	21 e0       	ldi	r18, 0x01	; 1
    1f62:	2a 8b       	std	Y+18, r18	; 0x12
    1f64:	ce 01       	movw	r24, r28
    1f66:	41 96       	adiw	r24, 0x11	; 17
    1f68:	b0 c0       	rjmp	.+352    	; 0x20ca <__mulsf3+0x1e8>
    1f6a:	2d 84       	ldd	r2, Y+13	; 0x0d
    1f6c:	3e 84       	ldd	r3, Y+14	; 0x0e
    1f6e:	4f 84       	ldd	r4, Y+15	; 0x0f
    1f70:	58 88       	ldd	r5, Y+16	; 0x10
    1f72:	6d 88       	ldd	r6, Y+21	; 0x15
    1f74:	7e 88       	ldd	r7, Y+22	; 0x16
    1f76:	8f 88       	ldd	r8, Y+23	; 0x17
    1f78:	98 8c       	ldd	r9, Y+24	; 0x18
    1f7a:	ee 24       	eor	r14, r14
    1f7c:	ff 24       	eor	r15, r15
    1f7e:	87 01       	movw	r16, r14
    1f80:	aa 24       	eor	r10, r10
    1f82:	bb 24       	eor	r11, r11
    1f84:	65 01       	movw	r12, r10
    1f86:	40 e0       	ldi	r20, 0x00	; 0
    1f88:	50 e0       	ldi	r21, 0x00	; 0
    1f8a:	60 e0       	ldi	r22, 0x00	; 0
    1f8c:	70 e0       	ldi	r23, 0x00	; 0
    1f8e:	e0 e0       	ldi	r30, 0x00	; 0
    1f90:	f0 e0       	ldi	r31, 0x00	; 0
    1f92:	c1 01       	movw	r24, r2
    1f94:	81 70       	andi	r24, 0x01	; 1
    1f96:	90 70       	andi	r25, 0x00	; 0
    1f98:	89 2b       	or	r24, r25
    1f9a:	e9 f0       	breq	.+58     	; 0x1fd6 <__mulsf3+0xf4>
    1f9c:	e6 0c       	add	r14, r6
    1f9e:	f7 1c       	adc	r15, r7
    1fa0:	08 1d       	adc	r16, r8
    1fa2:	19 1d       	adc	r17, r9
    1fa4:	9a 01       	movw	r18, r20
    1fa6:	ab 01       	movw	r20, r22
    1fa8:	2a 0d       	add	r18, r10
    1faa:	3b 1d       	adc	r19, r11
    1fac:	4c 1d       	adc	r20, r12
    1fae:	5d 1d       	adc	r21, r13
    1fb0:	80 e0       	ldi	r24, 0x00	; 0
    1fb2:	90 e0       	ldi	r25, 0x00	; 0
    1fb4:	a0 e0       	ldi	r26, 0x00	; 0
    1fb6:	b0 e0       	ldi	r27, 0x00	; 0
    1fb8:	e6 14       	cp	r14, r6
    1fba:	f7 04       	cpc	r15, r7
    1fbc:	08 05       	cpc	r16, r8
    1fbe:	19 05       	cpc	r17, r9
    1fc0:	20 f4       	brcc	.+8      	; 0x1fca <__mulsf3+0xe8>
    1fc2:	81 e0       	ldi	r24, 0x01	; 1
    1fc4:	90 e0       	ldi	r25, 0x00	; 0
    1fc6:	a0 e0       	ldi	r26, 0x00	; 0
    1fc8:	b0 e0       	ldi	r27, 0x00	; 0
    1fca:	ba 01       	movw	r22, r20
    1fcc:	a9 01       	movw	r20, r18
    1fce:	48 0f       	add	r20, r24
    1fd0:	59 1f       	adc	r21, r25
    1fd2:	6a 1f       	adc	r22, r26
    1fd4:	7b 1f       	adc	r23, r27
    1fd6:	aa 0c       	add	r10, r10
    1fd8:	bb 1c       	adc	r11, r11
    1fda:	cc 1c       	adc	r12, r12
    1fdc:	dd 1c       	adc	r13, r13
    1fde:	97 fe       	sbrs	r9, 7
    1fe0:	08 c0       	rjmp	.+16     	; 0x1ff2 <__mulsf3+0x110>
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	a0 e0       	ldi	r26, 0x00	; 0
    1fe8:	b0 e0       	ldi	r27, 0x00	; 0
    1fea:	a8 2a       	or	r10, r24
    1fec:	b9 2a       	or	r11, r25
    1fee:	ca 2a       	or	r12, r26
    1ff0:	db 2a       	or	r13, r27
    1ff2:	31 96       	adiw	r30, 0x01	; 1
    1ff4:	e0 32       	cpi	r30, 0x20	; 32
    1ff6:	f1 05       	cpc	r31, r1
    1ff8:	49 f0       	breq	.+18     	; 0x200c <__mulsf3+0x12a>
    1ffa:	66 0c       	add	r6, r6
    1ffc:	77 1c       	adc	r7, r7
    1ffe:	88 1c       	adc	r8, r8
    2000:	99 1c       	adc	r9, r9
    2002:	56 94       	lsr	r5
    2004:	47 94       	ror	r4
    2006:	37 94       	ror	r3
    2008:	27 94       	ror	r2
    200a:	c3 cf       	rjmp	.-122    	; 0x1f92 <__mulsf3+0xb0>
    200c:	fa 85       	ldd	r31, Y+10	; 0x0a
    200e:	ea 89       	ldd	r30, Y+18	; 0x12
    2010:	2b 89       	ldd	r18, Y+19	; 0x13
    2012:	3c 89       	ldd	r19, Y+20	; 0x14
    2014:	8b 85       	ldd	r24, Y+11	; 0x0b
    2016:	9c 85       	ldd	r25, Y+12	; 0x0c
    2018:	28 0f       	add	r18, r24
    201a:	39 1f       	adc	r19, r25
    201c:	2e 5f       	subi	r18, 0xFE	; 254
    201e:	3f 4f       	sbci	r19, 0xFF	; 255
    2020:	17 c0       	rjmp	.+46     	; 0x2050 <__mulsf3+0x16e>
    2022:	ca 01       	movw	r24, r20
    2024:	81 70       	andi	r24, 0x01	; 1
    2026:	90 70       	andi	r25, 0x00	; 0
    2028:	89 2b       	or	r24, r25
    202a:	61 f0       	breq	.+24     	; 0x2044 <__mulsf3+0x162>
    202c:	16 95       	lsr	r17
    202e:	07 95       	ror	r16
    2030:	f7 94       	ror	r15
    2032:	e7 94       	ror	r14
    2034:	80 e0       	ldi	r24, 0x00	; 0
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	a0 e0       	ldi	r26, 0x00	; 0
    203a:	b0 e8       	ldi	r27, 0x80	; 128
    203c:	e8 2a       	or	r14, r24
    203e:	f9 2a       	or	r15, r25
    2040:	0a 2b       	or	r16, r26
    2042:	1b 2b       	or	r17, r27
    2044:	76 95       	lsr	r23
    2046:	67 95       	ror	r22
    2048:	57 95       	ror	r21
    204a:	47 95       	ror	r20
    204c:	2f 5f       	subi	r18, 0xFF	; 255
    204e:	3f 4f       	sbci	r19, 0xFF	; 255
    2050:	77 fd       	sbrc	r23, 7
    2052:	e7 cf       	rjmp	.-50     	; 0x2022 <__mulsf3+0x140>
    2054:	0c c0       	rjmp	.+24     	; 0x206e <__mulsf3+0x18c>
    2056:	44 0f       	add	r20, r20
    2058:	55 1f       	adc	r21, r21
    205a:	66 1f       	adc	r22, r22
    205c:	77 1f       	adc	r23, r23
    205e:	17 fd       	sbrc	r17, 7
    2060:	41 60       	ori	r20, 0x01	; 1
    2062:	ee 0c       	add	r14, r14
    2064:	ff 1c       	adc	r15, r15
    2066:	00 1f       	adc	r16, r16
    2068:	11 1f       	adc	r17, r17
    206a:	21 50       	subi	r18, 0x01	; 1
    206c:	30 40       	sbci	r19, 0x00	; 0
    206e:	40 30       	cpi	r20, 0x00	; 0
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	59 07       	cpc	r21, r25
    2074:	90 e0       	ldi	r25, 0x00	; 0
    2076:	69 07       	cpc	r22, r25
    2078:	90 e4       	ldi	r25, 0x40	; 64
    207a:	79 07       	cpc	r23, r25
    207c:	60 f3       	brcs	.-40     	; 0x2056 <__mulsf3+0x174>
    207e:	2b 8f       	std	Y+27, r18	; 0x1b
    2080:	3c 8f       	std	Y+28, r19	; 0x1c
    2082:	db 01       	movw	r26, r22
    2084:	ca 01       	movw	r24, r20
    2086:	8f 77       	andi	r24, 0x7F	; 127
    2088:	90 70       	andi	r25, 0x00	; 0
    208a:	a0 70       	andi	r26, 0x00	; 0
    208c:	b0 70       	andi	r27, 0x00	; 0
    208e:	80 34       	cpi	r24, 0x40	; 64
    2090:	91 05       	cpc	r25, r1
    2092:	a1 05       	cpc	r26, r1
    2094:	b1 05       	cpc	r27, r1
    2096:	61 f4       	brne	.+24     	; 0x20b0 <__mulsf3+0x1ce>
    2098:	47 fd       	sbrc	r20, 7
    209a:	0a c0       	rjmp	.+20     	; 0x20b0 <__mulsf3+0x1ce>
    209c:	e1 14       	cp	r14, r1
    209e:	f1 04       	cpc	r15, r1
    20a0:	01 05       	cpc	r16, r1
    20a2:	11 05       	cpc	r17, r1
    20a4:	29 f0       	breq	.+10     	; 0x20b0 <__mulsf3+0x1ce>
    20a6:	40 5c       	subi	r20, 0xC0	; 192
    20a8:	5f 4f       	sbci	r21, 0xFF	; 255
    20aa:	6f 4f       	sbci	r22, 0xFF	; 255
    20ac:	7f 4f       	sbci	r23, 0xFF	; 255
    20ae:	40 78       	andi	r20, 0x80	; 128
    20b0:	1a 8e       	std	Y+26, r1	; 0x1a
    20b2:	fe 17       	cp	r31, r30
    20b4:	11 f0       	breq	.+4      	; 0x20ba <__mulsf3+0x1d8>
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	8a 8f       	std	Y+26, r24	; 0x1a
    20ba:	4d 8f       	std	Y+29, r20	; 0x1d
    20bc:	5e 8f       	std	Y+30, r21	; 0x1e
    20be:	6f 8f       	std	Y+31, r22	; 0x1f
    20c0:	78 a3       	std	Y+32, r23	; 0x20
    20c2:	83 e0       	ldi	r24, 0x03	; 3
    20c4:	89 8f       	std	Y+25, r24	; 0x19
    20c6:	ce 01       	movw	r24, r28
    20c8:	49 96       	adiw	r24, 0x19	; 25
    20ca:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__pack_f>
    20ce:	a0 96       	adiw	r28, 0x20	; 32
    20d0:	e2 e1       	ldi	r30, 0x12	; 18
    20d2:	0c 94 33 15 	jmp	0x2a66	; 0x2a66 <__epilogue_restores__>

000020d6 <__divsf3>:
    20d6:	a8 e1       	ldi	r26, 0x18	; 24
    20d8:	b0 e0       	ldi	r27, 0x00	; 0
    20da:	e1 e7       	ldi	r30, 0x71	; 113
    20dc:	f0 e1       	ldi	r31, 0x10	; 16
    20de:	0c 94 1f 15 	jmp	0x2a3e	; 0x2a3e <__prologue_saves__+0x10>
    20e2:	69 83       	std	Y+1, r22	; 0x01
    20e4:	7a 83       	std	Y+2, r23	; 0x02
    20e6:	8b 83       	std	Y+3, r24	; 0x03
    20e8:	9c 83       	std	Y+4, r25	; 0x04
    20ea:	2d 83       	std	Y+5, r18	; 0x05
    20ec:	3e 83       	std	Y+6, r19	; 0x06
    20ee:	4f 83       	std	Y+7, r20	; 0x07
    20f0:	58 87       	std	Y+8, r21	; 0x08
    20f2:	b9 e0       	ldi	r27, 0x09	; 9
    20f4:	eb 2e       	mov	r14, r27
    20f6:	f1 2c       	mov	r15, r1
    20f8:	ec 0e       	add	r14, r28
    20fa:	fd 1e       	adc	r15, r29
    20fc:	ce 01       	movw	r24, r28
    20fe:	01 96       	adiw	r24, 0x01	; 1
    2100:	b7 01       	movw	r22, r14
    2102:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    2106:	8e 01       	movw	r16, r28
    2108:	0f 5e       	subi	r16, 0xEF	; 239
    210a:	1f 4f       	sbci	r17, 0xFF	; 255
    210c:	ce 01       	movw	r24, r28
    210e:	05 96       	adiw	r24, 0x05	; 5
    2110:	b8 01       	movw	r22, r16
    2112:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    2116:	29 85       	ldd	r18, Y+9	; 0x09
    2118:	22 30       	cpi	r18, 0x02	; 2
    211a:	08 f4       	brcc	.+2      	; 0x211e <__divsf3+0x48>
    211c:	7e c0       	rjmp	.+252    	; 0x221a <__divsf3+0x144>
    211e:	39 89       	ldd	r19, Y+17	; 0x11
    2120:	32 30       	cpi	r19, 0x02	; 2
    2122:	10 f4       	brcc	.+4      	; 0x2128 <__divsf3+0x52>
    2124:	b8 01       	movw	r22, r16
    2126:	7c c0       	rjmp	.+248    	; 0x2220 <__divsf3+0x14a>
    2128:	8a 85       	ldd	r24, Y+10	; 0x0a
    212a:	9a 89       	ldd	r25, Y+18	; 0x12
    212c:	89 27       	eor	r24, r25
    212e:	8a 87       	std	Y+10, r24	; 0x0a
    2130:	24 30       	cpi	r18, 0x04	; 4
    2132:	11 f0       	breq	.+4      	; 0x2138 <__divsf3+0x62>
    2134:	22 30       	cpi	r18, 0x02	; 2
    2136:	31 f4       	brne	.+12     	; 0x2144 <__divsf3+0x6e>
    2138:	23 17       	cp	r18, r19
    213a:	09 f0       	breq	.+2      	; 0x213e <__divsf3+0x68>
    213c:	6e c0       	rjmp	.+220    	; 0x221a <__divsf3+0x144>
    213e:	6c e6       	ldi	r22, 0x6C	; 108
    2140:	71 e0       	ldi	r23, 0x01	; 1
    2142:	6e c0       	rjmp	.+220    	; 0x2220 <__divsf3+0x14a>
    2144:	34 30       	cpi	r19, 0x04	; 4
    2146:	39 f4       	brne	.+14     	; 0x2156 <__divsf3+0x80>
    2148:	1d 86       	std	Y+13, r1	; 0x0d
    214a:	1e 86       	std	Y+14, r1	; 0x0e
    214c:	1f 86       	std	Y+15, r1	; 0x0f
    214e:	18 8a       	std	Y+16, r1	; 0x10
    2150:	1c 86       	std	Y+12, r1	; 0x0c
    2152:	1b 86       	std	Y+11, r1	; 0x0b
    2154:	04 c0       	rjmp	.+8      	; 0x215e <__divsf3+0x88>
    2156:	32 30       	cpi	r19, 0x02	; 2
    2158:	21 f4       	brne	.+8      	; 0x2162 <__divsf3+0x8c>
    215a:	84 e0       	ldi	r24, 0x04	; 4
    215c:	89 87       	std	Y+9, r24	; 0x09
    215e:	b7 01       	movw	r22, r14
    2160:	5f c0       	rjmp	.+190    	; 0x2220 <__divsf3+0x14a>
    2162:	2b 85       	ldd	r18, Y+11	; 0x0b
    2164:	3c 85       	ldd	r19, Y+12	; 0x0c
    2166:	8b 89       	ldd	r24, Y+19	; 0x13
    2168:	9c 89       	ldd	r25, Y+20	; 0x14
    216a:	28 1b       	sub	r18, r24
    216c:	39 0b       	sbc	r19, r25
    216e:	3c 87       	std	Y+12, r19	; 0x0c
    2170:	2b 87       	std	Y+11, r18	; 0x0b
    2172:	ed 84       	ldd	r14, Y+13	; 0x0d
    2174:	fe 84       	ldd	r15, Y+14	; 0x0e
    2176:	0f 85       	ldd	r16, Y+15	; 0x0f
    2178:	18 89       	ldd	r17, Y+16	; 0x10
    217a:	ad 88       	ldd	r10, Y+21	; 0x15
    217c:	be 88       	ldd	r11, Y+22	; 0x16
    217e:	cf 88       	ldd	r12, Y+23	; 0x17
    2180:	d8 8c       	ldd	r13, Y+24	; 0x18
    2182:	ea 14       	cp	r14, r10
    2184:	fb 04       	cpc	r15, r11
    2186:	0c 05       	cpc	r16, r12
    2188:	1d 05       	cpc	r17, r13
    218a:	40 f4       	brcc	.+16     	; 0x219c <__divsf3+0xc6>
    218c:	ee 0c       	add	r14, r14
    218e:	ff 1c       	adc	r15, r15
    2190:	00 1f       	adc	r16, r16
    2192:	11 1f       	adc	r17, r17
    2194:	21 50       	subi	r18, 0x01	; 1
    2196:	30 40       	sbci	r19, 0x00	; 0
    2198:	3c 87       	std	Y+12, r19	; 0x0c
    219a:	2b 87       	std	Y+11, r18	; 0x0b
    219c:	20 e0       	ldi	r18, 0x00	; 0
    219e:	30 e0       	ldi	r19, 0x00	; 0
    21a0:	40 e0       	ldi	r20, 0x00	; 0
    21a2:	50 e0       	ldi	r21, 0x00	; 0
    21a4:	80 e0       	ldi	r24, 0x00	; 0
    21a6:	90 e0       	ldi	r25, 0x00	; 0
    21a8:	a0 e0       	ldi	r26, 0x00	; 0
    21aa:	b0 e4       	ldi	r27, 0x40	; 64
    21ac:	60 e0       	ldi	r22, 0x00	; 0
    21ae:	70 e0       	ldi	r23, 0x00	; 0
    21b0:	ea 14       	cp	r14, r10
    21b2:	fb 04       	cpc	r15, r11
    21b4:	0c 05       	cpc	r16, r12
    21b6:	1d 05       	cpc	r17, r13
    21b8:	40 f0       	brcs	.+16     	; 0x21ca <__divsf3+0xf4>
    21ba:	28 2b       	or	r18, r24
    21bc:	39 2b       	or	r19, r25
    21be:	4a 2b       	or	r20, r26
    21c0:	5b 2b       	or	r21, r27
    21c2:	ea 18       	sub	r14, r10
    21c4:	fb 08       	sbc	r15, r11
    21c6:	0c 09       	sbc	r16, r12
    21c8:	1d 09       	sbc	r17, r13
    21ca:	b6 95       	lsr	r27
    21cc:	a7 95       	ror	r26
    21ce:	97 95       	ror	r25
    21d0:	87 95       	ror	r24
    21d2:	ee 0c       	add	r14, r14
    21d4:	ff 1c       	adc	r15, r15
    21d6:	00 1f       	adc	r16, r16
    21d8:	11 1f       	adc	r17, r17
    21da:	6f 5f       	subi	r22, 0xFF	; 255
    21dc:	7f 4f       	sbci	r23, 0xFF	; 255
    21de:	6f 31       	cpi	r22, 0x1F	; 31
    21e0:	71 05       	cpc	r23, r1
    21e2:	31 f7       	brne	.-52     	; 0x21b0 <__divsf3+0xda>
    21e4:	da 01       	movw	r26, r20
    21e6:	c9 01       	movw	r24, r18
    21e8:	8f 77       	andi	r24, 0x7F	; 127
    21ea:	90 70       	andi	r25, 0x00	; 0
    21ec:	a0 70       	andi	r26, 0x00	; 0
    21ee:	b0 70       	andi	r27, 0x00	; 0
    21f0:	80 34       	cpi	r24, 0x40	; 64
    21f2:	91 05       	cpc	r25, r1
    21f4:	a1 05       	cpc	r26, r1
    21f6:	b1 05       	cpc	r27, r1
    21f8:	61 f4       	brne	.+24     	; 0x2212 <__divsf3+0x13c>
    21fa:	27 fd       	sbrc	r18, 7
    21fc:	0a c0       	rjmp	.+20     	; 0x2212 <__divsf3+0x13c>
    21fe:	e1 14       	cp	r14, r1
    2200:	f1 04       	cpc	r15, r1
    2202:	01 05       	cpc	r16, r1
    2204:	11 05       	cpc	r17, r1
    2206:	29 f0       	breq	.+10     	; 0x2212 <__divsf3+0x13c>
    2208:	20 5c       	subi	r18, 0xC0	; 192
    220a:	3f 4f       	sbci	r19, 0xFF	; 255
    220c:	4f 4f       	sbci	r20, 0xFF	; 255
    220e:	5f 4f       	sbci	r21, 0xFF	; 255
    2210:	20 78       	andi	r18, 0x80	; 128
    2212:	2d 87       	std	Y+13, r18	; 0x0d
    2214:	3e 87       	std	Y+14, r19	; 0x0e
    2216:	4f 87       	std	Y+15, r20	; 0x0f
    2218:	58 8b       	std	Y+16, r21	; 0x10
    221a:	be 01       	movw	r22, r28
    221c:	67 5f       	subi	r22, 0xF7	; 247
    221e:	7f 4f       	sbci	r23, 0xFF	; 255
    2220:	cb 01       	movw	r24, r22
    2222:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <__pack_f>
    2226:	68 96       	adiw	r28, 0x18	; 24
    2228:	ea e0       	ldi	r30, 0x0A	; 10
    222a:	0c 94 3b 15 	jmp	0x2a76	; 0x2a76 <__epilogue_restores__+0x10>

0000222e <__gtsf2>:
    222e:	a8 e1       	ldi	r26, 0x18	; 24
    2230:	b0 e0       	ldi	r27, 0x00	; 0
    2232:	ed e1       	ldi	r30, 0x1D	; 29
    2234:	f1 e1       	ldi	r31, 0x11	; 17
    2236:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__prologue_saves__+0x18>
    223a:	69 83       	std	Y+1, r22	; 0x01
    223c:	7a 83       	std	Y+2, r23	; 0x02
    223e:	8b 83       	std	Y+3, r24	; 0x03
    2240:	9c 83       	std	Y+4, r25	; 0x04
    2242:	2d 83       	std	Y+5, r18	; 0x05
    2244:	3e 83       	std	Y+6, r19	; 0x06
    2246:	4f 83       	std	Y+7, r20	; 0x07
    2248:	58 87       	std	Y+8, r21	; 0x08
    224a:	89 e0       	ldi	r24, 0x09	; 9
    224c:	e8 2e       	mov	r14, r24
    224e:	f1 2c       	mov	r15, r1
    2250:	ec 0e       	add	r14, r28
    2252:	fd 1e       	adc	r15, r29
    2254:	ce 01       	movw	r24, r28
    2256:	01 96       	adiw	r24, 0x01	; 1
    2258:	b7 01       	movw	r22, r14
    225a:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    225e:	8e 01       	movw	r16, r28
    2260:	0f 5e       	subi	r16, 0xEF	; 239
    2262:	1f 4f       	sbci	r17, 0xFF	; 255
    2264:	ce 01       	movw	r24, r28
    2266:	05 96       	adiw	r24, 0x05	; 5
    2268:	b8 01       	movw	r22, r16
    226a:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    226e:	89 85       	ldd	r24, Y+9	; 0x09
    2270:	82 30       	cpi	r24, 0x02	; 2
    2272:	40 f0       	brcs	.+16     	; 0x2284 <__gtsf2+0x56>
    2274:	89 89       	ldd	r24, Y+17	; 0x11
    2276:	82 30       	cpi	r24, 0x02	; 2
    2278:	28 f0       	brcs	.+10     	; 0x2284 <__gtsf2+0x56>
    227a:	c7 01       	movw	r24, r14
    227c:	b8 01       	movw	r22, r16
    227e:	0e 94 48 13 	call	0x2690	; 0x2690 <__fpcmp_parts_f>
    2282:	01 c0       	rjmp	.+2      	; 0x2286 <__gtsf2+0x58>
    2284:	8f ef       	ldi	r24, 0xFF	; 255
    2286:	68 96       	adiw	r28, 0x18	; 24
    2288:	e6 e0       	ldi	r30, 0x06	; 6
    228a:	0c 94 3f 15 	jmp	0x2a7e	; 0x2a7e <__epilogue_restores__+0x18>

0000228e <__gesf2>:
    228e:	a8 e1       	ldi	r26, 0x18	; 24
    2290:	b0 e0       	ldi	r27, 0x00	; 0
    2292:	ed e4       	ldi	r30, 0x4D	; 77
    2294:	f1 e1       	ldi	r31, 0x11	; 17
    2296:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__prologue_saves__+0x18>
    229a:	69 83       	std	Y+1, r22	; 0x01
    229c:	7a 83       	std	Y+2, r23	; 0x02
    229e:	8b 83       	std	Y+3, r24	; 0x03
    22a0:	9c 83       	std	Y+4, r25	; 0x04
    22a2:	2d 83       	std	Y+5, r18	; 0x05
    22a4:	3e 83       	std	Y+6, r19	; 0x06
    22a6:	4f 83       	std	Y+7, r20	; 0x07
    22a8:	58 87       	std	Y+8, r21	; 0x08
    22aa:	89 e0       	ldi	r24, 0x09	; 9
    22ac:	e8 2e       	mov	r14, r24
    22ae:	f1 2c       	mov	r15, r1
    22b0:	ec 0e       	add	r14, r28
    22b2:	fd 1e       	adc	r15, r29
    22b4:	ce 01       	movw	r24, r28
    22b6:	01 96       	adiw	r24, 0x01	; 1
    22b8:	b7 01       	movw	r22, r14
    22ba:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    22be:	8e 01       	movw	r16, r28
    22c0:	0f 5e       	subi	r16, 0xEF	; 239
    22c2:	1f 4f       	sbci	r17, 0xFF	; 255
    22c4:	ce 01       	movw	r24, r28
    22c6:	05 96       	adiw	r24, 0x05	; 5
    22c8:	b8 01       	movw	r22, r16
    22ca:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    22ce:	89 85       	ldd	r24, Y+9	; 0x09
    22d0:	82 30       	cpi	r24, 0x02	; 2
    22d2:	40 f0       	brcs	.+16     	; 0x22e4 <__gesf2+0x56>
    22d4:	89 89       	ldd	r24, Y+17	; 0x11
    22d6:	82 30       	cpi	r24, 0x02	; 2
    22d8:	28 f0       	brcs	.+10     	; 0x22e4 <__gesf2+0x56>
    22da:	c7 01       	movw	r24, r14
    22dc:	b8 01       	movw	r22, r16
    22de:	0e 94 48 13 	call	0x2690	; 0x2690 <__fpcmp_parts_f>
    22e2:	01 c0       	rjmp	.+2      	; 0x22e6 <__gesf2+0x58>
    22e4:	8f ef       	ldi	r24, 0xFF	; 255
    22e6:	68 96       	adiw	r28, 0x18	; 24
    22e8:	e6 e0       	ldi	r30, 0x06	; 6
    22ea:	0c 94 3f 15 	jmp	0x2a7e	; 0x2a7e <__epilogue_restores__+0x18>

000022ee <__ltsf2>:
    22ee:	a8 e1       	ldi	r26, 0x18	; 24
    22f0:	b0 e0       	ldi	r27, 0x00	; 0
    22f2:	ed e7       	ldi	r30, 0x7D	; 125
    22f4:	f1 e1       	ldi	r31, 0x11	; 17
    22f6:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <__prologue_saves__+0x18>
    22fa:	69 83       	std	Y+1, r22	; 0x01
    22fc:	7a 83       	std	Y+2, r23	; 0x02
    22fe:	8b 83       	std	Y+3, r24	; 0x03
    2300:	9c 83       	std	Y+4, r25	; 0x04
    2302:	2d 83       	std	Y+5, r18	; 0x05
    2304:	3e 83       	std	Y+6, r19	; 0x06
    2306:	4f 83       	std	Y+7, r20	; 0x07
    2308:	58 87       	std	Y+8, r21	; 0x08
    230a:	89 e0       	ldi	r24, 0x09	; 9
    230c:	e8 2e       	mov	r14, r24
    230e:	f1 2c       	mov	r15, r1
    2310:	ec 0e       	add	r14, r28
    2312:	fd 1e       	adc	r15, r29
    2314:	ce 01       	movw	r24, r28
    2316:	01 96       	adiw	r24, 0x01	; 1
    2318:	b7 01       	movw	r22, r14
    231a:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    231e:	8e 01       	movw	r16, r28
    2320:	0f 5e       	subi	r16, 0xEF	; 239
    2322:	1f 4f       	sbci	r17, 0xFF	; 255
    2324:	ce 01       	movw	r24, r28
    2326:	05 96       	adiw	r24, 0x05	; 5
    2328:	b8 01       	movw	r22, r16
    232a:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    232e:	89 85       	ldd	r24, Y+9	; 0x09
    2330:	82 30       	cpi	r24, 0x02	; 2
    2332:	40 f0       	brcs	.+16     	; 0x2344 <__ltsf2+0x56>
    2334:	89 89       	ldd	r24, Y+17	; 0x11
    2336:	82 30       	cpi	r24, 0x02	; 2
    2338:	28 f0       	brcs	.+10     	; 0x2344 <__ltsf2+0x56>
    233a:	c7 01       	movw	r24, r14
    233c:	b8 01       	movw	r22, r16
    233e:	0e 94 48 13 	call	0x2690	; 0x2690 <__fpcmp_parts_f>
    2342:	01 c0       	rjmp	.+2      	; 0x2346 <__ltsf2+0x58>
    2344:	81 e0       	ldi	r24, 0x01	; 1
    2346:	68 96       	adiw	r28, 0x18	; 24
    2348:	e6 e0       	ldi	r30, 0x06	; 6
    234a:	0c 94 3f 15 	jmp	0x2a7e	; 0x2a7e <__epilogue_restores__+0x18>

0000234e <__fixsfsi>:
    234e:	ac e0       	ldi	r26, 0x0C	; 12
    2350:	b0 e0       	ldi	r27, 0x00	; 0
    2352:	ed ea       	ldi	r30, 0xAD	; 173
    2354:	f1 e1       	ldi	r31, 0x11	; 17
    2356:	0c 94 27 15 	jmp	0x2a4e	; 0x2a4e <__prologue_saves__+0x20>
    235a:	69 83       	std	Y+1, r22	; 0x01
    235c:	7a 83       	std	Y+2, r23	; 0x02
    235e:	8b 83       	std	Y+3, r24	; 0x03
    2360:	9c 83       	std	Y+4, r25	; 0x04
    2362:	ce 01       	movw	r24, r28
    2364:	01 96       	adiw	r24, 0x01	; 1
    2366:	be 01       	movw	r22, r28
    2368:	6b 5f       	subi	r22, 0xFB	; 251
    236a:	7f 4f       	sbci	r23, 0xFF	; 255
    236c:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <__unpack_f>
    2370:	8d 81       	ldd	r24, Y+5	; 0x05
    2372:	82 30       	cpi	r24, 0x02	; 2
    2374:	61 f1       	breq	.+88     	; 0x23ce <__fixsfsi+0x80>
    2376:	82 30       	cpi	r24, 0x02	; 2
    2378:	50 f1       	brcs	.+84     	; 0x23ce <__fixsfsi+0x80>
    237a:	84 30       	cpi	r24, 0x04	; 4
    237c:	21 f4       	brne	.+8      	; 0x2386 <__fixsfsi+0x38>
    237e:	8e 81       	ldd	r24, Y+6	; 0x06
    2380:	88 23       	and	r24, r24
    2382:	51 f1       	breq	.+84     	; 0x23d8 <__fixsfsi+0x8a>
    2384:	2e c0       	rjmp	.+92     	; 0x23e2 <__fixsfsi+0x94>
    2386:	2f 81       	ldd	r18, Y+7	; 0x07
    2388:	38 85       	ldd	r19, Y+8	; 0x08
    238a:	37 fd       	sbrc	r19, 7
    238c:	20 c0       	rjmp	.+64     	; 0x23ce <__fixsfsi+0x80>
    238e:	6e 81       	ldd	r22, Y+6	; 0x06
    2390:	2f 31       	cpi	r18, 0x1F	; 31
    2392:	31 05       	cpc	r19, r1
    2394:	1c f0       	brlt	.+6      	; 0x239c <__fixsfsi+0x4e>
    2396:	66 23       	and	r22, r22
    2398:	f9 f0       	breq	.+62     	; 0x23d8 <__fixsfsi+0x8a>
    239a:	23 c0       	rjmp	.+70     	; 0x23e2 <__fixsfsi+0x94>
    239c:	8e e1       	ldi	r24, 0x1E	; 30
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	82 1b       	sub	r24, r18
    23a2:	93 0b       	sbc	r25, r19
    23a4:	29 85       	ldd	r18, Y+9	; 0x09
    23a6:	3a 85       	ldd	r19, Y+10	; 0x0a
    23a8:	4b 85       	ldd	r20, Y+11	; 0x0b
    23aa:	5c 85       	ldd	r21, Y+12	; 0x0c
    23ac:	04 c0       	rjmp	.+8      	; 0x23b6 <__fixsfsi+0x68>
    23ae:	56 95       	lsr	r21
    23b0:	47 95       	ror	r20
    23b2:	37 95       	ror	r19
    23b4:	27 95       	ror	r18
    23b6:	8a 95       	dec	r24
    23b8:	d2 f7       	brpl	.-12     	; 0x23ae <__fixsfsi+0x60>
    23ba:	66 23       	and	r22, r22
    23bc:	b1 f0       	breq	.+44     	; 0x23ea <__fixsfsi+0x9c>
    23be:	50 95       	com	r21
    23c0:	40 95       	com	r20
    23c2:	30 95       	com	r19
    23c4:	21 95       	neg	r18
    23c6:	3f 4f       	sbci	r19, 0xFF	; 255
    23c8:	4f 4f       	sbci	r20, 0xFF	; 255
    23ca:	5f 4f       	sbci	r21, 0xFF	; 255
    23cc:	0e c0       	rjmp	.+28     	; 0x23ea <__fixsfsi+0x9c>
    23ce:	20 e0       	ldi	r18, 0x00	; 0
    23d0:	30 e0       	ldi	r19, 0x00	; 0
    23d2:	40 e0       	ldi	r20, 0x00	; 0
    23d4:	50 e0       	ldi	r21, 0x00	; 0
    23d6:	09 c0       	rjmp	.+18     	; 0x23ea <__fixsfsi+0x9c>
    23d8:	2f ef       	ldi	r18, 0xFF	; 255
    23da:	3f ef       	ldi	r19, 0xFF	; 255
    23dc:	4f ef       	ldi	r20, 0xFF	; 255
    23de:	5f e7       	ldi	r21, 0x7F	; 127
    23e0:	04 c0       	rjmp	.+8      	; 0x23ea <__fixsfsi+0x9c>
    23e2:	20 e0       	ldi	r18, 0x00	; 0
    23e4:	30 e0       	ldi	r19, 0x00	; 0
    23e6:	40 e0       	ldi	r20, 0x00	; 0
    23e8:	50 e8       	ldi	r21, 0x80	; 128
    23ea:	b9 01       	movw	r22, r18
    23ec:	ca 01       	movw	r24, r20
    23ee:	2c 96       	adiw	r28, 0x0c	; 12
    23f0:	e2 e0       	ldi	r30, 0x02	; 2
    23f2:	0c 94 43 15 	jmp	0x2a86	; 0x2a86 <__epilogue_restores__+0x20>

000023f6 <__pack_f>:
    23f6:	df 92       	push	r13
    23f8:	ef 92       	push	r14
    23fa:	ff 92       	push	r15
    23fc:	0f 93       	push	r16
    23fe:	1f 93       	push	r17
    2400:	fc 01       	movw	r30, r24
    2402:	e4 80       	ldd	r14, Z+4	; 0x04
    2404:	f5 80       	ldd	r15, Z+5	; 0x05
    2406:	06 81       	ldd	r16, Z+6	; 0x06
    2408:	17 81       	ldd	r17, Z+7	; 0x07
    240a:	d1 80       	ldd	r13, Z+1	; 0x01
    240c:	80 81       	ld	r24, Z
    240e:	82 30       	cpi	r24, 0x02	; 2
    2410:	48 f4       	brcc	.+18     	; 0x2424 <__pack_f+0x2e>
    2412:	80 e0       	ldi	r24, 0x00	; 0
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	a0 e1       	ldi	r26, 0x10	; 16
    2418:	b0 e0       	ldi	r27, 0x00	; 0
    241a:	e8 2a       	or	r14, r24
    241c:	f9 2a       	or	r15, r25
    241e:	0a 2b       	or	r16, r26
    2420:	1b 2b       	or	r17, r27
    2422:	a5 c0       	rjmp	.+330    	; 0x256e <__pack_f+0x178>
    2424:	84 30       	cpi	r24, 0x04	; 4
    2426:	09 f4       	brne	.+2      	; 0x242a <__pack_f+0x34>
    2428:	9f c0       	rjmp	.+318    	; 0x2568 <__pack_f+0x172>
    242a:	82 30       	cpi	r24, 0x02	; 2
    242c:	21 f4       	brne	.+8      	; 0x2436 <__pack_f+0x40>
    242e:	ee 24       	eor	r14, r14
    2430:	ff 24       	eor	r15, r15
    2432:	87 01       	movw	r16, r14
    2434:	05 c0       	rjmp	.+10     	; 0x2440 <__pack_f+0x4a>
    2436:	e1 14       	cp	r14, r1
    2438:	f1 04       	cpc	r15, r1
    243a:	01 05       	cpc	r16, r1
    243c:	11 05       	cpc	r17, r1
    243e:	19 f4       	brne	.+6      	; 0x2446 <__pack_f+0x50>
    2440:	e0 e0       	ldi	r30, 0x00	; 0
    2442:	f0 e0       	ldi	r31, 0x00	; 0
    2444:	96 c0       	rjmp	.+300    	; 0x2572 <__pack_f+0x17c>
    2446:	62 81       	ldd	r22, Z+2	; 0x02
    2448:	73 81       	ldd	r23, Z+3	; 0x03
    244a:	9f ef       	ldi	r25, 0xFF	; 255
    244c:	62 38       	cpi	r22, 0x82	; 130
    244e:	79 07       	cpc	r23, r25
    2450:	0c f0       	brlt	.+2      	; 0x2454 <__pack_f+0x5e>
    2452:	5b c0       	rjmp	.+182    	; 0x250a <__pack_f+0x114>
    2454:	22 e8       	ldi	r18, 0x82	; 130
    2456:	3f ef       	ldi	r19, 0xFF	; 255
    2458:	26 1b       	sub	r18, r22
    245a:	37 0b       	sbc	r19, r23
    245c:	2a 31       	cpi	r18, 0x1A	; 26
    245e:	31 05       	cpc	r19, r1
    2460:	2c f0       	brlt	.+10     	; 0x246c <__pack_f+0x76>
    2462:	20 e0       	ldi	r18, 0x00	; 0
    2464:	30 e0       	ldi	r19, 0x00	; 0
    2466:	40 e0       	ldi	r20, 0x00	; 0
    2468:	50 e0       	ldi	r21, 0x00	; 0
    246a:	2a c0       	rjmp	.+84     	; 0x24c0 <__pack_f+0xca>
    246c:	b8 01       	movw	r22, r16
    246e:	a7 01       	movw	r20, r14
    2470:	02 2e       	mov	r0, r18
    2472:	04 c0       	rjmp	.+8      	; 0x247c <__pack_f+0x86>
    2474:	76 95       	lsr	r23
    2476:	67 95       	ror	r22
    2478:	57 95       	ror	r21
    247a:	47 95       	ror	r20
    247c:	0a 94       	dec	r0
    247e:	d2 f7       	brpl	.-12     	; 0x2474 <__pack_f+0x7e>
    2480:	81 e0       	ldi	r24, 0x01	; 1
    2482:	90 e0       	ldi	r25, 0x00	; 0
    2484:	a0 e0       	ldi	r26, 0x00	; 0
    2486:	b0 e0       	ldi	r27, 0x00	; 0
    2488:	04 c0       	rjmp	.+8      	; 0x2492 <__pack_f+0x9c>
    248a:	88 0f       	add	r24, r24
    248c:	99 1f       	adc	r25, r25
    248e:	aa 1f       	adc	r26, r26
    2490:	bb 1f       	adc	r27, r27
    2492:	2a 95       	dec	r18
    2494:	d2 f7       	brpl	.-12     	; 0x248a <__pack_f+0x94>
    2496:	01 97       	sbiw	r24, 0x01	; 1
    2498:	a1 09       	sbc	r26, r1
    249a:	b1 09       	sbc	r27, r1
    249c:	8e 21       	and	r24, r14
    249e:	9f 21       	and	r25, r15
    24a0:	a0 23       	and	r26, r16
    24a2:	b1 23       	and	r27, r17
    24a4:	00 97       	sbiw	r24, 0x00	; 0
    24a6:	a1 05       	cpc	r26, r1
    24a8:	b1 05       	cpc	r27, r1
    24aa:	21 f0       	breq	.+8      	; 0x24b4 <__pack_f+0xbe>
    24ac:	81 e0       	ldi	r24, 0x01	; 1
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	a0 e0       	ldi	r26, 0x00	; 0
    24b2:	b0 e0       	ldi	r27, 0x00	; 0
    24b4:	9a 01       	movw	r18, r20
    24b6:	ab 01       	movw	r20, r22
    24b8:	28 2b       	or	r18, r24
    24ba:	39 2b       	or	r19, r25
    24bc:	4a 2b       	or	r20, r26
    24be:	5b 2b       	or	r21, r27
    24c0:	da 01       	movw	r26, r20
    24c2:	c9 01       	movw	r24, r18
    24c4:	8f 77       	andi	r24, 0x7F	; 127
    24c6:	90 70       	andi	r25, 0x00	; 0
    24c8:	a0 70       	andi	r26, 0x00	; 0
    24ca:	b0 70       	andi	r27, 0x00	; 0
    24cc:	80 34       	cpi	r24, 0x40	; 64
    24ce:	91 05       	cpc	r25, r1
    24d0:	a1 05       	cpc	r26, r1
    24d2:	b1 05       	cpc	r27, r1
    24d4:	39 f4       	brne	.+14     	; 0x24e4 <__pack_f+0xee>
    24d6:	27 ff       	sbrs	r18, 7
    24d8:	09 c0       	rjmp	.+18     	; 0x24ec <__pack_f+0xf6>
    24da:	20 5c       	subi	r18, 0xC0	; 192
    24dc:	3f 4f       	sbci	r19, 0xFF	; 255
    24de:	4f 4f       	sbci	r20, 0xFF	; 255
    24e0:	5f 4f       	sbci	r21, 0xFF	; 255
    24e2:	04 c0       	rjmp	.+8      	; 0x24ec <__pack_f+0xf6>
    24e4:	21 5c       	subi	r18, 0xC1	; 193
    24e6:	3f 4f       	sbci	r19, 0xFF	; 255
    24e8:	4f 4f       	sbci	r20, 0xFF	; 255
    24ea:	5f 4f       	sbci	r21, 0xFF	; 255
    24ec:	e0 e0       	ldi	r30, 0x00	; 0
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	20 30       	cpi	r18, 0x00	; 0
    24f2:	a0 e0       	ldi	r26, 0x00	; 0
    24f4:	3a 07       	cpc	r19, r26
    24f6:	a0 e0       	ldi	r26, 0x00	; 0
    24f8:	4a 07       	cpc	r20, r26
    24fa:	a0 e4       	ldi	r26, 0x40	; 64
    24fc:	5a 07       	cpc	r21, r26
    24fe:	10 f0       	brcs	.+4      	; 0x2504 <__pack_f+0x10e>
    2500:	e1 e0       	ldi	r30, 0x01	; 1
    2502:	f0 e0       	ldi	r31, 0x00	; 0
    2504:	79 01       	movw	r14, r18
    2506:	8a 01       	movw	r16, r20
    2508:	27 c0       	rjmp	.+78     	; 0x2558 <__pack_f+0x162>
    250a:	60 38       	cpi	r22, 0x80	; 128
    250c:	71 05       	cpc	r23, r1
    250e:	64 f5       	brge	.+88     	; 0x2568 <__pack_f+0x172>
    2510:	fb 01       	movw	r30, r22
    2512:	e1 58       	subi	r30, 0x81	; 129
    2514:	ff 4f       	sbci	r31, 0xFF	; 255
    2516:	d8 01       	movw	r26, r16
    2518:	c7 01       	movw	r24, r14
    251a:	8f 77       	andi	r24, 0x7F	; 127
    251c:	90 70       	andi	r25, 0x00	; 0
    251e:	a0 70       	andi	r26, 0x00	; 0
    2520:	b0 70       	andi	r27, 0x00	; 0
    2522:	80 34       	cpi	r24, 0x40	; 64
    2524:	91 05       	cpc	r25, r1
    2526:	a1 05       	cpc	r26, r1
    2528:	b1 05       	cpc	r27, r1
    252a:	39 f4       	brne	.+14     	; 0x253a <__pack_f+0x144>
    252c:	e7 fe       	sbrs	r14, 7
    252e:	0d c0       	rjmp	.+26     	; 0x254a <__pack_f+0x154>
    2530:	80 e4       	ldi	r24, 0x40	; 64
    2532:	90 e0       	ldi	r25, 0x00	; 0
    2534:	a0 e0       	ldi	r26, 0x00	; 0
    2536:	b0 e0       	ldi	r27, 0x00	; 0
    2538:	04 c0       	rjmp	.+8      	; 0x2542 <__pack_f+0x14c>
    253a:	8f e3       	ldi	r24, 0x3F	; 63
    253c:	90 e0       	ldi	r25, 0x00	; 0
    253e:	a0 e0       	ldi	r26, 0x00	; 0
    2540:	b0 e0       	ldi	r27, 0x00	; 0
    2542:	e8 0e       	add	r14, r24
    2544:	f9 1e       	adc	r15, r25
    2546:	0a 1f       	adc	r16, r26
    2548:	1b 1f       	adc	r17, r27
    254a:	17 ff       	sbrs	r17, 7
    254c:	05 c0       	rjmp	.+10     	; 0x2558 <__pack_f+0x162>
    254e:	16 95       	lsr	r17
    2550:	07 95       	ror	r16
    2552:	f7 94       	ror	r15
    2554:	e7 94       	ror	r14
    2556:	31 96       	adiw	r30, 0x01	; 1
    2558:	87 e0       	ldi	r24, 0x07	; 7
    255a:	16 95       	lsr	r17
    255c:	07 95       	ror	r16
    255e:	f7 94       	ror	r15
    2560:	e7 94       	ror	r14
    2562:	8a 95       	dec	r24
    2564:	d1 f7       	brne	.-12     	; 0x255a <__pack_f+0x164>
    2566:	05 c0       	rjmp	.+10     	; 0x2572 <__pack_f+0x17c>
    2568:	ee 24       	eor	r14, r14
    256a:	ff 24       	eor	r15, r15
    256c:	87 01       	movw	r16, r14
    256e:	ef ef       	ldi	r30, 0xFF	; 255
    2570:	f0 e0       	ldi	r31, 0x00	; 0
    2572:	6e 2f       	mov	r22, r30
    2574:	67 95       	ror	r22
    2576:	66 27       	eor	r22, r22
    2578:	67 95       	ror	r22
    257a:	90 2f       	mov	r25, r16
    257c:	9f 77       	andi	r25, 0x7F	; 127
    257e:	d7 94       	ror	r13
    2580:	dd 24       	eor	r13, r13
    2582:	d7 94       	ror	r13
    2584:	8e 2f       	mov	r24, r30
    2586:	86 95       	lsr	r24
    2588:	49 2f       	mov	r20, r25
    258a:	46 2b       	or	r20, r22
    258c:	58 2f       	mov	r21, r24
    258e:	5d 29       	or	r21, r13
    2590:	b7 01       	movw	r22, r14
    2592:	ca 01       	movw	r24, r20
    2594:	1f 91       	pop	r17
    2596:	0f 91       	pop	r16
    2598:	ff 90       	pop	r15
    259a:	ef 90       	pop	r14
    259c:	df 90       	pop	r13
    259e:	08 95       	ret

000025a0 <__unpack_f>:
    25a0:	fc 01       	movw	r30, r24
    25a2:	db 01       	movw	r26, r22
    25a4:	40 81       	ld	r20, Z
    25a6:	51 81       	ldd	r21, Z+1	; 0x01
    25a8:	22 81       	ldd	r18, Z+2	; 0x02
    25aa:	62 2f       	mov	r22, r18
    25ac:	6f 77       	andi	r22, 0x7F	; 127
    25ae:	70 e0       	ldi	r23, 0x00	; 0
    25b0:	22 1f       	adc	r18, r18
    25b2:	22 27       	eor	r18, r18
    25b4:	22 1f       	adc	r18, r18
    25b6:	93 81       	ldd	r25, Z+3	; 0x03
    25b8:	89 2f       	mov	r24, r25
    25ba:	88 0f       	add	r24, r24
    25bc:	82 2b       	or	r24, r18
    25be:	28 2f       	mov	r18, r24
    25c0:	30 e0       	ldi	r19, 0x00	; 0
    25c2:	99 1f       	adc	r25, r25
    25c4:	99 27       	eor	r25, r25
    25c6:	99 1f       	adc	r25, r25
    25c8:	11 96       	adiw	r26, 0x01	; 1
    25ca:	9c 93       	st	X, r25
    25cc:	11 97       	sbiw	r26, 0x01	; 1
    25ce:	21 15       	cp	r18, r1
    25d0:	31 05       	cpc	r19, r1
    25d2:	a9 f5       	brne	.+106    	; 0x263e <__unpack_f+0x9e>
    25d4:	41 15       	cp	r20, r1
    25d6:	51 05       	cpc	r21, r1
    25d8:	61 05       	cpc	r22, r1
    25da:	71 05       	cpc	r23, r1
    25dc:	11 f4       	brne	.+4      	; 0x25e2 <__unpack_f+0x42>
    25de:	82 e0       	ldi	r24, 0x02	; 2
    25e0:	37 c0       	rjmp	.+110    	; 0x2650 <__unpack_f+0xb0>
    25e2:	82 e8       	ldi	r24, 0x82	; 130
    25e4:	9f ef       	ldi	r25, 0xFF	; 255
    25e6:	13 96       	adiw	r26, 0x03	; 3
    25e8:	9c 93       	st	X, r25
    25ea:	8e 93       	st	-X, r24
    25ec:	12 97       	sbiw	r26, 0x02	; 2
    25ee:	9a 01       	movw	r18, r20
    25f0:	ab 01       	movw	r20, r22
    25f2:	67 e0       	ldi	r22, 0x07	; 7
    25f4:	22 0f       	add	r18, r18
    25f6:	33 1f       	adc	r19, r19
    25f8:	44 1f       	adc	r20, r20
    25fa:	55 1f       	adc	r21, r21
    25fc:	6a 95       	dec	r22
    25fe:	d1 f7       	brne	.-12     	; 0x25f4 <__unpack_f+0x54>
    2600:	83 e0       	ldi	r24, 0x03	; 3
    2602:	8c 93       	st	X, r24
    2604:	0d c0       	rjmp	.+26     	; 0x2620 <__unpack_f+0x80>
    2606:	22 0f       	add	r18, r18
    2608:	33 1f       	adc	r19, r19
    260a:	44 1f       	adc	r20, r20
    260c:	55 1f       	adc	r21, r21
    260e:	12 96       	adiw	r26, 0x02	; 2
    2610:	8d 91       	ld	r24, X+
    2612:	9c 91       	ld	r25, X
    2614:	13 97       	sbiw	r26, 0x03	; 3
    2616:	01 97       	sbiw	r24, 0x01	; 1
    2618:	13 96       	adiw	r26, 0x03	; 3
    261a:	9c 93       	st	X, r25
    261c:	8e 93       	st	-X, r24
    261e:	12 97       	sbiw	r26, 0x02	; 2
    2620:	20 30       	cpi	r18, 0x00	; 0
    2622:	80 e0       	ldi	r24, 0x00	; 0
    2624:	38 07       	cpc	r19, r24
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	48 07       	cpc	r20, r24
    262a:	80 e4       	ldi	r24, 0x40	; 64
    262c:	58 07       	cpc	r21, r24
    262e:	58 f3       	brcs	.-42     	; 0x2606 <__unpack_f+0x66>
    2630:	14 96       	adiw	r26, 0x04	; 4
    2632:	2d 93       	st	X+, r18
    2634:	3d 93       	st	X+, r19
    2636:	4d 93       	st	X+, r20
    2638:	5c 93       	st	X, r21
    263a:	17 97       	sbiw	r26, 0x07	; 7
    263c:	08 95       	ret
    263e:	2f 3f       	cpi	r18, 0xFF	; 255
    2640:	31 05       	cpc	r19, r1
    2642:	79 f4       	brne	.+30     	; 0x2662 <__unpack_f+0xc2>
    2644:	41 15       	cp	r20, r1
    2646:	51 05       	cpc	r21, r1
    2648:	61 05       	cpc	r22, r1
    264a:	71 05       	cpc	r23, r1
    264c:	19 f4       	brne	.+6      	; 0x2654 <__unpack_f+0xb4>
    264e:	84 e0       	ldi	r24, 0x04	; 4
    2650:	8c 93       	st	X, r24
    2652:	08 95       	ret
    2654:	64 ff       	sbrs	r22, 4
    2656:	03 c0       	rjmp	.+6      	; 0x265e <__unpack_f+0xbe>
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	8c 93       	st	X, r24
    265c:	12 c0       	rjmp	.+36     	; 0x2682 <__unpack_f+0xe2>
    265e:	1c 92       	st	X, r1
    2660:	10 c0       	rjmp	.+32     	; 0x2682 <__unpack_f+0xe2>
    2662:	2f 57       	subi	r18, 0x7F	; 127
    2664:	30 40       	sbci	r19, 0x00	; 0
    2666:	13 96       	adiw	r26, 0x03	; 3
    2668:	3c 93       	st	X, r19
    266a:	2e 93       	st	-X, r18
    266c:	12 97       	sbiw	r26, 0x02	; 2
    266e:	83 e0       	ldi	r24, 0x03	; 3
    2670:	8c 93       	st	X, r24
    2672:	87 e0       	ldi	r24, 0x07	; 7
    2674:	44 0f       	add	r20, r20
    2676:	55 1f       	adc	r21, r21
    2678:	66 1f       	adc	r22, r22
    267a:	77 1f       	adc	r23, r23
    267c:	8a 95       	dec	r24
    267e:	d1 f7       	brne	.-12     	; 0x2674 <__unpack_f+0xd4>
    2680:	70 64       	ori	r23, 0x40	; 64
    2682:	14 96       	adiw	r26, 0x04	; 4
    2684:	4d 93       	st	X+, r20
    2686:	5d 93       	st	X+, r21
    2688:	6d 93       	st	X+, r22
    268a:	7c 93       	st	X, r23
    268c:	17 97       	sbiw	r26, 0x07	; 7
    268e:	08 95       	ret

00002690 <__fpcmp_parts_f>:
    2690:	1f 93       	push	r17
    2692:	dc 01       	movw	r26, r24
    2694:	fb 01       	movw	r30, r22
    2696:	9c 91       	ld	r25, X
    2698:	92 30       	cpi	r25, 0x02	; 2
    269a:	08 f4       	brcc	.+2      	; 0x269e <__fpcmp_parts_f+0xe>
    269c:	47 c0       	rjmp	.+142    	; 0x272c <__fpcmp_parts_f+0x9c>
    269e:	80 81       	ld	r24, Z
    26a0:	82 30       	cpi	r24, 0x02	; 2
    26a2:	08 f4       	brcc	.+2      	; 0x26a6 <__fpcmp_parts_f+0x16>
    26a4:	43 c0       	rjmp	.+134    	; 0x272c <__fpcmp_parts_f+0x9c>
    26a6:	94 30       	cpi	r25, 0x04	; 4
    26a8:	51 f4       	brne	.+20     	; 0x26be <__fpcmp_parts_f+0x2e>
    26aa:	11 96       	adiw	r26, 0x01	; 1
    26ac:	1c 91       	ld	r17, X
    26ae:	84 30       	cpi	r24, 0x04	; 4
    26b0:	99 f5       	brne	.+102    	; 0x2718 <__fpcmp_parts_f+0x88>
    26b2:	81 81       	ldd	r24, Z+1	; 0x01
    26b4:	68 2f       	mov	r22, r24
    26b6:	70 e0       	ldi	r23, 0x00	; 0
    26b8:	61 1b       	sub	r22, r17
    26ba:	71 09       	sbc	r23, r1
    26bc:	3f c0       	rjmp	.+126    	; 0x273c <__fpcmp_parts_f+0xac>
    26be:	84 30       	cpi	r24, 0x04	; 4
    26c0:	21 f0       	breq	.+8      	; 0x26ca <__fpcmp_parts_f+0x3a>
    26c2:	92 30       	cpi	r25, 0x02	; 2
    26c4:	31 f4       	brne	.+12     	; 0x26d2 <__fpcmp_parts_f+0x42>
    26c6:	82 30       	cpi	r24, 0x02	; 2
    26c8:	b9 f1       	breq	.+110    	; 0x2738 <__fpcmp_parts_f+0xa8>
    26ca:	81 81       	ldd	r24, Z+1	; 0x01
    26cc:	88 23       	and	r24, r24
    26ce:	89 f1       	breq	.+98     	; 0x2732 <__fpcmp_parts_f+0xa2>
    26d0:	2d c0       	rjmp	.+90     	; 0x272c <__fpcmp_parts_f+0x9c>
    26d2:	11 96       	adiw	r26, 0x01	; 1
    26d4:	1c 91       	ld	r17, X
    26d6:	11 97       	sbiw	r26, 0x01	; 1
    26d8:	82 30       	cpi	r24, 0x02	; 2
    26da:	f1 f0       	breq	.+60     	; 0x2718 <__fpcmp_parts_f+0x88>
    26dc:	81 81       	ldd	r24, Z+1	; 0x01
    26de:	18 17       	cp	r17, r24
    26e0:	d9 f4       	brne	.+54     	; 0x2718 <__fpcmp_parts_f+0x88>
    26e2:	12 96       	adiw	r26, 0x02	; 2
    26e4:	2d 91       	ld	r18, X+
    26e6:	3c 91       	ld	r19, X
    26e8:	13 97       	sbiw	r26, 0x03	; 3
    26ea:	82 81       	ldd	r24, Z+2	; 0x02
    26ec:	93 81       	ldd	r25, Z+3	; 0x03
    26ee:	82 17       	cp	r24, r18
    26f0:	93 07       	cpc	r25, r19
    26f2:	94 f0       	brlt	.+36     	; 0x2718 <__fpcmp_parts_f+0x88>
    26f4:	28 17       	cp	r18, r24
    26f6:	39 07       	cpc	r19, r25
    26f8:	bc f0       	brlt	.+46     	; 0x2728 <__fpcmp_parts_f+0x98>
    26fa:	14 96       	adiw	r26, 0x04	; 4
    26fc:	8d 91       	ld	r24, X+
    26fe:	9d 91       	ld	r25, X+
    2700:	0d 90       	ld	r0, X+
    2702:	bc 91       	ld	r27, X
    2704:	a0 2d       	mov	r26, r0
    2706:	24 81       	ldd	r18, Z+4	; 0x04
    2708:	35 81       	ldd	r19, Z+5	; 0x05
    270a:	46 81       	ldd	r20, Z+6	; 0x06
    270c:	57 81       	ldd	r21, Z+7	; 0x07
    270e:	28 17       	cp	r18, r24
    2710:	39 07       	cpc	r19, r25
    2712:	4a 07       	cpc	r20, r26
    2714:	5b 07       	cpc	r21, r27
    2716:	18 f4       	brcc	.+6      	; 0x271e <__fpcmp_parts_f+0x8e>
    2718:	11 23       	and	r17, r17
    271a:	41 f0       	breq	.+16     	; 0x272c <__fpcmp_parts_f+0x9c>
    271c:	0a c0       	rjmp	.+20     	; 0x2732 <__fpcmp_parts_f+0xa2>
    271e:	82 17       	cp	r24, r18
    2720:	93 07       	cpc	r25, r19
    2722:	a4 07       	cpc	r26, r20
    2724:	b5 07       	cpc	r27, r21
    2726:	40 f4       	brcc	.+16     	; 0x2738 <__fpcmp_parts_f+0xa8>
    2728:	11 23       	and	r17, r17
    272a:	19 f0       	breq	.+6      	; 0x2732 <__fpcmp_parts_f+0xa2>
    272c:	61 e0       	ldi	r22, 0x01	; 1
    272e:	70 e0       	ldi	r23, 0x00	; 0
    2730:	05 c0       	rjmp	.+10     	; 0x273c <__fpcmp_parts_f+0xac>
    2732:	6f ef       	ldi	r22, 0xFF	; 255
    2734:	7f ef       	ldi	r23, 0xFF	; 255
    2736:	02 c0       	rjmp	.+4      	; 0x273c <__fpcmp_parts_f+0xac>
    2738:	60 e0       	ldi	r22, 0x00	; 0
    273a:	70 e0       	ldi	r23, 0x00	; 0
    273c:	cb 01       	movw	r24, r22
    273e:	1f 91       	pop	r17
    2740:	08 95       	ret

00002742 <malloc>:
    2742:	cf 93       	push	r28
    2744:	df 93       	push	r29
    2746:	bc 01       	movw	r22, r24
    2748:	82 30       	cpi	r24, 0x02	; 2
    274a:	91 05       	cpc	r25, r1
    274c:	10 f4       	brcc	.+4      	; 0x2752 <malloc+0x10>
    274e:	62 e0       	ldi	r22, 0x02	; 2
    2750:	70 e0       	ldi	r23, 0x00	; 0
    2752:	a0 91 8c 01 	lds	r26, 0x018C
    2756:	b0 91 8d 01 	lds	r27, 0x018D
    275a:	ed 01       	movw	r28, r26
    275c:	e0 e0       	ldi	r30, 0x00	; 0
    275e:	f0 e0       	ldi	r31, 0x00	; 0
    2760:	40 e0       	ldi	r20, 0x00	; 0
    2762:	50 e0       	ldi	r21, 0x00	; 0
    2764:	21 c0       	rjmp	.+66     	; 0x27a8 <malloc+0x66>
    2766:	88 81       	ld	r24, Y
    2768:	99 81       	ldd	r25, Y+1	; 0x01
    276a:	86 17       	cp	r24, r22
    276c:	97 07       	cpc	r25, r23
    276e:	69 f4       	brne	.+26     	; 0x278a <malloc+0x48>
    2770:	8a 81       	ldd	r24, Y+2	; 0x02
    2772:	9b 81       	ldd	r25, Y+3	; 0x03
    2774:	30 97       	sbiw	r30, 0x00	; 0
    2776:	19 f0       	breq	.+6      	; 0x277e <malloc+0x3c>
    2778:	93 83       	std	Z+3, r25	; 0x03
    277a:	82 83       	std	Z+2, r24	; 0x02
    277c:	04 c0       	rjmp	.+8      	; 0x2786 <malloc+0x44>
    277e:	90 93 8d 01 	sts	0x018D, r25
    2782:	80 93 8c 01 	sts	0x018C, r24
    2786:	fe 01       	movw	r30, r28
    2788:	34 c0       	rjmp	.+104    	; 0x27f2 <malloc+0xb0>
    278a:	68 17       	cp	r22, r24
    278c:	79 07       	cpc	r23, r25
    278e:	38 f4       	brcc	.+14     	; 0x279e <malloc+0x5c>
    2790:	41 15       	cp	r20, r1
    2792:	51 05       	cpc	r21, r1
    2794:	19 f0       	breq	.+6      	; 0x279c <malloc+0x5a>
    2796:	84 17       	cp	r24, r20
    2798:	95 07       	cpc	r25, r21
    279a:	08 f4       	brcc	.+2      	; 0x279e <malloc+0x5c>
    279c:	ac 01       	movw	r20, r24
    279e:	fe 01       	movw	r30, r28
    27a0:	8a 81       	ldd	r24, Y+2	; 0x02
    27a2:	9b 81       	ldd	r25, Y+3	; 0x03
    27a4:	9c 01       	movw	r18, r24
    27a6:	e9 01       	movw	r28, r18
    27a8:	20 97       	sbiw	r28, 0x00	; 0
    27aa:	e9 f6       	brne	.-70     	; 0x2766 <malloc+0x24>
    27ac:	41 15       	cp	r20, r1
    27ae:	51 05       	cpc	r21, r1
    27b0:	a9 f1       	breq	.+106    	; 0x281c <malloc+0xda>
    27b2:	ca 01       	movw	r24, r20
    27b4:	86 1b       	sub	r24, r22
    27b6:	97 0b       	sbc	r25, r23
    27b8:	04 97       	sbiw	r24, 0x04	; 4
    27ba:	08 f4       	brcc	.+2      	; 0x27be <malloc+0x7c>
    27bc:	ba 01       	movw	r22, r20
    27be:	e0 e0       	ldi	r30, 0x00	; 0
    27c0:	f0 e0       	ldi	r31, 0x00	; 0
    27c2:	2a c0       	rjmp	.+84     	; 0x2818 <malloc+0xd6>
    27c4:	8d 91       	ld	r24, X+
    27c6:	9c 91       	ld	r25, X
    27c8:	11 97       	sbiw	r26, 0x01	; 1
    27ca:	84 17       	cp	r24, r20
    27cc:	95 07       	cpc	r25, r21
    27ce:	f9 f4       	brne	.+62     	; 0x280e <malloc+0xcc>
    27d0:	64 17       	cp	r22, r20
    27d2:	75 07       	cpc	r23, r21
    27d4:	81 f4       	brne	.+32     	; 0x27f6 <malloc+0xb4>
    27d6:	12 96       	adiw	r26, 0x02	; 2
    27d8:	8d 91       	ld	r24, X+
    27da:	9c 91       	ld	r25, X
    27dc:	13 97       	sbiw	r26, 0x03	; 3
    27de:	30 97       	sbiw	r30, 0x00	; 0
    27e0:	19 f0       	breq	.+6      	; 0x27e8 <malloc+0xa6>
    27e2:	93 83       	std	Z+3, r25	; 0x03
    27e4:	82 83       	std	Z+2, r24	; 0x02
    27e6:	04 c0       	rjmp	.+8      	; 0x27f0 <malloc+0xae>
    27e8:	90 93 8d 01 	sts	0x018D, r25
    27ec:	80 93 8c 01 	sts	0x018C, r24
    27f0:	fd 01       	movw	r30, r26
    27f2:	32 96       	adiw	r30, 0x02	; 2
    27f4:	4f c0       	rjmp	.+158    	; 0x2894 <malloc+0x152>
    27f6:	ca 01       	movw	r24, r20
    27f8:	86 1b       	sub	r24, r22
    27fa:	97 0b       	sbc	r25, r23
    27fc:	fd 01       	movw	r30, r26
    27fe:	e8 0f       	add	r30, r24
    2800:	f9 1f       	adc	r31, r25
    2802:	61 93       	st	Z+, r22
    2804:	71 93       	st	Z+, r23
    2806:	02 97       	sbiw	r24, 0x02	; 2
    2808:	8d 93       	st	X+, r24
    280a:	9c 93       	st	X, r25
    280c:	43 c0       	rjmp	.+134    	; 0x2894 <malloc+0x152>
    280e:	fd 01       	movw	r30, r26
    2810:	82 81       	ldd	r24, Z+2	; 0x02
    2812:	93 81       	ldd	r25, Z+3	; 0x03
    2814:	9c 01       	movw	r18, r24
    2816:	d9 01       	movw	r26, r18
    2818:	10 97       	sbiw	r26, 0x00	; 0
    281a:	a1 f6       	brne	.-88     	; 0x27c4 <malloc+0x82>
    281c:	80 91 8a 01 	lds	r24, 0x018A
    2820:	90 91 8b 01 	lds	r25, 0x018B
    2824:	89 2b       	or	r24, r25
    2826:	41 f4       	brne	.+16     	; 0x2838 <malloc+0xf6>
    2828:	80 91 76 01 	lds	r24, 0x0176
    282c:	90 91 77 01 	lds	r25, 0x0177
    2830:	90 93 8b 01 	sts	0x018B, r25
    2834:	80 93 8a 01 	sts	0x018A, r24
    2838:	40 91 78 01 	lds	r20, 0x0178
    283c:	50 91 79 01 	lds	r21, 0x0179
    2840:	41 15       	cp	r20, r1
    2842:	51 05       	cpc	r21, r1
    2844:	41 f4       	brne	.+16     	; 0x2856 <malloc+0x114>
    2846:	4d b7       	in	r20, 0x3d	; 61
    2848:	5e b7       	in	r21, 0x3e	; 62
    284a:	80 91 74 01 	lds	r24, 0x0174
    284e:	90 91 75 01 	lds	r25, 0x0175
    2852:	48 1b       	sub	r20, r24
    2854:	59 0b       	sbc	r21, r25
    2856:	20 91 8a 01 	lds	r18, 0x018A
    285a:	30 91 8b 01 	lds	r19, 0x018B
    285e:	24 17       	cp	r18, r20
    2860:	35 07       	cpc	r19, r21
    2862:	b0 f4       	brcc	.+44     	; 0x2890 <malloc+0x14e>
    2864:	ca 01       	movw	r24, r20
    2866:	82 1b       	sub	r24, r18
    2868:	93 0b       	sbc	r25, r19
    286a:	86 17       	cp	r24, r22
    286c:	97 07       	cpc	r25, r23
    286e:	80 f0       	brcs	.+32     	; 0x2890 <malloc+0x14e>
    2870:	ab 01       	movw	r20, r22
    2872:	4e 5f       	subi	r20, 0xFE	; 254
    2874:	5f 4f       	sbci	r21, 0xFF	; 255
    2876:	84 17       	cp	r24, r20
    2878:	95 07       	cpc	r25, r21
    287a:	50 f0       	brcs	.+20     	; 0x2890 <malloc+0x14e>
    287c:	42 0f       	add	r20, r18
    287e:	53 1f       	adc	r21, r19
    2880:	50 93 8b 01 	sts	0x018B, r21
    2884:	40 93 8a 01 	sts	0x018A, r20
    2888:	f9 01       	movw	r30, r18
    288a:	61 93       	st	Z+, r22
    288c:	71 93       	st	Z+, r23
    288e:	02 c0       	rjmp	.+4      	; 0x2894 <malloc+0x152>
    2890:	e0 e0       	ldi	r30, 0x00	; 0
    2892:	f0 e0       	ldi	r31, 0x00	; 0
    2894:	cf 01       	movw	r24, r30
    2896:	df 91       	pop	r29
    2898:	cf 91       	pop	r28
    289a:	08 95       	ret

0000289c <free>:
    289c:	cf 93       	push	r28
    289e:	df 93       	push	r29
    28a0:	00 97       	sbiw	r24, 0x00	; 0
    28a2:	09 f4       	brne	.+2      	; 0x28a6 <free+0xa>
    28a4:	50 c0       	rjmp	.+160    	; 0x2946 <free+0xaa>
    28a6:	ec 01       	movw	r28, r24
    28a8:	22 97       	sbiw	r28, 0x02	; 2
    28aa:	1b 82       	std	Y+3, r1	; 0x03
    28ac:	1a 82       	std	Y+2, r1	; 0x02
    28ae:	a0 91 8c 01 	lds	r26, 0x018C
    28b2:	b0 91 8d 01 	lds	r27, 0x018D
    28b6:	10 97       	sbiw	r26, 0x00	; 0
    28b8:	09 f1       	breq	.+66     	; 0x28fc <free+0x60>
    28ba:	40 e0       	ldi	r20, 0x00	; 0
    28bc:	50 e0       	ldi	r21, 0x00	; 0
    28be:	ac 17       	cp	r26, r28
    28c0:	bd 07       	cpc	r27, r29
    28c2:	08 f1       	brcs	.+66     	; 0x2906 <free+0x6a>
    28c4:	bb 83       	std	Y+3, r27	; 0x03
    28c6:	aa 83       	std	Y+2, r26	; 0x02
    28c8:	fe 01       	movw	r30, r28
    28ca:	21 91       	ld	r18, Z+
    28cc:	31 91       	ld	r19, Z+
    28ce:	e2 0f       	add	r30, r18
    28d0:	f3 1f       	adc	r31, r19
    28d2:	ae 17       	cp	r26, r30
    28d4:	bf 07       	cpc	r27, r31
    28d6:	79 f4       	brne	.+30     	; 0x28f6 <free+0x5a>
    28d8:	8d 91       	ld	r24, X+
    28da:	9c 91       	ld	r25, X
    28dc:	11 97       	sbiw	r26, 0x01	; 1
    28de:	28 0f       	add	r18, r24
    28e0:	39 1f       	adc	r19, r25
    28e2:	2e 5f       	subi	r18, 0xFE	; 254
    28e4:	3f 4f       	sbci	r19, 0xFF	; 255
    28e6:	39 83       	std	Y+1, r19	; 0x01
    28e8:	28 83       	st	Y, r18
    28ea:	12 96       	adiw	r26, 0x02	; 2
    28ec:	8d 91       	ld	r24, X+
    28ee:	9c 91       	ld	r25, X
    28f0:	13 97       	sbiw	r26, 0x03	; 3
    28f2:	9b 83       	std	Y+3, r25	; 0x03
    28f4:	8a 83       	std	Y+2, r24	; 0x02
    28f6:	41 15       	cp	r20, r1
    28f8:	51 05       	cpc	r21, r1
    28fa:	71 f4       	brne	.+28     	; 0x2918 <free+0x7c>
    28fc:	d0 93 8d 01 	sts	0x018D, r29
    2900:	c0 93 8c 01 	sts	0x018C, r28
    2904:	20 c0       	rjmp	.+64     	; 0x2946 <free+0xaa>
    2906:	12 96       	adiw	r26, 0x02	; 2
    2908:	8d 91       	ld	r24, X+
    290a:	9c 91       	ld	r25, X
    290c:	13 97       	sbiw	r26, 0x03	; 3
    290e:	ad 01       	movw	r20, r26
    2910:	00 97       	sbiw	r24, 0x00	; 0
    2912:	11 f0       	breq	.+4      	; 0x2918 <free+0x7c>
    2914:	dc 01       	movw	r26, r24
    2916:	d3 cf       	rjmp	.-90     	; 0x28be <free+0x22>
    2918:	fa 01       	movw	r30, r20
    291a:	d3 83       	std	Z+3, r29	; 0x03
    291c:	c2 83       	std	Z+2, r28	; 0x02
    291e:	21 91       	ld	r18, Z+
    2920:	31 91       	ld	r19, Z+
    2922:	e2 0f       	add	r30, r18
    2924:	f3 1f       	adc	r31, r19
    2926:	ce 17       	cp	r28, r30
    2928:	df 07       	cpc	r29, r31
    292a:	69 f4       	brne	.+26     	; 0x2946 <free+0xaa>
    292c:	88 81       	ld	r24, Y
    292e:	99 81       	ldd	r25, Y+1	; 0x01
    2930:	28 0f       	add	r18, r24
    2932:	39 1f       	adc	r19, r25
    2934:	2e 5f       	subi	r18, 0xFE	; 254
    2936:	3f 4f       	sbci	r19, 0xFF	; 255
    2938:	fa 01       	movw	r30, r20
    293a:	31 83       	std	Z+1, r19	; 0x01
    293c:	20 83       	st	Z, r18
    293e:	8a 81       	ldd	r24, Y+2	; 0x02
    2940:	9b 81       	ldd	r25, Y+3	; 0x03
    2942:	93 83       	std	Z+3, r25	; 0x03
    2944:	82 83       	std	Z+2, r24	; 0x02
    2946:	df 91       	pop	r29
    2948:	cf 91       	pop	r28
    294a:	08 95       	ret

0000294c <memset>:
    294c:	dc 01       	movw	r26, r24
    294e:	01 c0       	rjmp	.+2      	; 0x2952 <memset+0x6>
    2950:	6d 93       	st	X+, r22
    2952:	41 50       	subi	r20, 0x01	; 1
    2954:	50 40       	sbci	r21, 0x00	; 0
    2956:	e0 f7       	brcc	.-8      	; 0x2950 <memset+0x4>
    2958:	08 95       	ret

0000295a <fwrite>:
    295a:	a0 e0       	ldi	r26, 0x00	; 0
    295c:	b0 e0       	ldi	r27, 0x00	; 0
    295e:	e3 eb       	ldi	r30, 0xB3	; 179
    2960:	f4 e1       	ldi	r31, 0x14	; 20
    2962:	0c 94 1d 15 	jmp	0x2a3a	; 0x2a3a <__prologue_saves__+0xc>
    2966:	fc 01       	movw	r30, r24
    2968:	4b 01       	movw	r8, r22
    296a:	5a 01       	movw	r10, r20
    296c:	69 01       	movw	r12, r18
    296e:	d9 01       	movw	r26, r18
    2970:	13 96       	adiw	r26, 0x03	; 3
    2972:	8c 91       	ld	r24, X
    2974:	81 ff       	sbrs	r24, 1
    2976:	1e c0       	rjmp	.+60     	; 0x29b4 <fwrite+0x5a>
    2978:	7f 01       	movw	r14, r30
    297a:	c0 e0       	ldi	r28, 0x00	; 0
    297c:	d0 e0       	ldi	r29, 0x00	; 0
    297e:	14 c0       	rjmp	.+40     	; 0x29a8 <fwrite+0x4e>
    2980:	d6 01       	movw	r26, r12
    2982:	18 96       	adiw	r26, 0x08	; 8
    2984:	ed 91       	ld	r30, X+
    2986:	fc 91       	ld	r31, X
    2988:	19 97       	sbiw	r26, 0x09	; 9
    298a:	d7 01       	movw	r26, r14
    298c:	8c 91       	ld	r24, X
    298e:	b6 01       	movw	r22, r12
    2990:	09 95       	icall
    2992:	89 2b       	or	r24, r25
    2994:	89 f4       	brne	.+34     	; 0x29b8 <fwrite+0x5e>
    2996:	08 94       	sec
    2998:	e1 1c       	adc	r14, r1
    299a:	f1 1c       	adc	r15, r1
    299c:	0f 5f       	subi	r16, 0xFF	; 255
    299e:	1f 4f       	sbci	r17, 0xFF	; 255
    29a0:	08 15       	cp	r16, r8
    29a2:	19 05       	cpc	r17, r9
    29a4:	68 f3       	brcs	.-38     	; 0x2980 <fwrite+0x26>
    29a6:	21 96       	adiw	r28, 0x01	; 1
    29a8:	ca 15       	cp	r28, r10
    29aa:	db 05       	cpc	r29, r11
    29ac:	28 f4       	brcc	.+10     	; 0x29b8 <fwrite+0x5e>
    29ae:	00 e0       	ldi	r16, 0x00	; 0
    29b0:	10 e0       	ldi	r17, 0x00	; 0
    29b2:	f6 cf       	rjmp	.-20     	; 0x29a0 <fwrite+0x46>
    29b4:	c0 e0       	ldi	r28, 0x00	; 0
    29b6:	d0 e0       	ldi	r29, 0x00	; 0
    29b8:	ce 01       	movw	r24, r28
    29ba:	cd b7       	in	r28, 0x3d	; 61
    29bc:	de b7       	in	r29, 0x3e	; 62
    29be:	ec e0       	ldi	r30, 0x0C	; 12
    29c0:	0c 94 39 15 	jmp	0x2a72	; 0x2a72 <__epilogue_restores__+0xc>

000029c4 <puts>:
    29c4:	0f 93       	push	r16
    29c6:	1f 93       	push	r17
    29c8:	cf 93       	push	r28
    29ca:	df 93       	push	r29
    29cc:	8c 01       	movw	r16, r24
    29ce:	e0 91 90 01 	lds	r30, 0x0190
    29d2:	f0 91 91 01 	lds	r31, 0x0191
    29d6:	83 81       	ldd	r24, Z+3	; 0x03
    29d8:	81 ff       	sbrs	r24, 1
    29da:	21 c0       	rjmp	.+66     	; 0x2a1e <puts+0x5a>
    29dc:	c0 e0       	ldi	r28, 0x00	; 0
    29de:	d0 e0       	ldi	r29, 0x00	; 0
    29e0:	0d c0       	rjmp	.+26     	; 0x29fc <puts+0x38>
    29e2:	e0 91 90 01 	lds	r30, 0x0190
    29e6:	f0 91 91 01 	lds	r31, 0x0191
    29ea:	20 85       	ldd	r18, Z+8	; 0x08
    29ec:	31 85       	ldd	r19, Z+9	; 0x09
    29ee:	bf 01       	movw	r22, r30
    29f0:	f9 01       	movw	r30, r18
    29f2:	09 95       	icall
    29f4:	89 2b       	or	r24, r25
    29f6:	11 f0       	breq	.+4      	; 0x29fc <puts+0x38>
    29f8:	cf ef       	ldi	r28, 0xFF	; 255
    29fa:	df ef       	ldi	r29, 0xFF	; 255
    29fc:	f8 01       	movw	r30, r16
    29fe:	81 91       	ld	r24, Z+
    2a00:	8f 01       	movw	r16, r30
    2a02:	88 23       	and	r24, r24
    2a04:	71 f7       	brne	.-36     	; 0x29e2 <puts+0x1e>
    2a06:	e0 91 90 01 	lds	r30, 0x0190
    2a0a:	f0 91 91 01 	lds	r31, 0x0191
    2a0e:	20 85       	ldd	r18, Z+8	; 0x08
    2a10:	31 85       	ldd	r19, Z+9	; 0x09
    2a12:	8a e0       	ldi	r24, 0x0A	; 10
    2a14:	bf 01       	movw	r22, r30
    2a16:	f9 01       	movw	r30, r18
    2a18:	09 95       	icall
    2a1a:	89 2b       	or	r24, r25
    2a1c:	11 f0       	breq	.+4      	; 0x2a22 <puts+0x5e>
    2a1e:	cf ef       	ldi	r28, 0xFF	; 255
    2a20:	df ef       	ldi	r29, 0xFF	; 255
    2a22:	ce 01       	movw	r24, r28
    2a24:	df 91       	pop	r29
    2a26:	cf 91       	pop	r28
    2a28:	1f 91       	pop	r17
    2a2a:	0f 91       	pop	r16
    2a2c:	08 95       	ret

00002a2e <__prologue_saves__>:
    2a2e:	2f 92       	push	r2
    2a30:	3f 92       	push	r3
    2a32:	4f 92       	push	r4
    2a34:	5f 92       	push	r5
    2a36:	6f 92       	push	r6
    2a38:	7f 92       	push	r7
    2a3a:	8f 92       	push	r8
    2a3c:	9f 92       	push	r9
    2a3e:	af 92       	push	r10
    2a40:	bf 92       	push	r11
    2a42:	cf 92       	push	r12
    2a44:	df 92       	push	r13
    2a46:	ef 92       	push	r14
    2a48:	ff 92       	push	r15
    2a4a:	0f 93       	push	r16
    2a4c:	1f 93       	push	r17
    2a4e:	cf 93       	push	r28
    2a50:	df 93       	push	r29
    2a52:	cd b7       	in	r28, 0x3d	; 61
    2a54:	de b7       	in	r29, 0x3e	; 62
    2a56:	ca 1b       	sub	r28, r26
    2a58:	db 0b       	sbc	r29, r27
    2a5a:	0f b6       	in	r0, 0x3f	; 63
    2a5c:	f8 94       	cli
    2a5e:	de bf       	out	0x3e, r29	; 62
    2a60:	0f be       	out	0x3f, r0	; 63
    2a62:	cd bf       	out	0x3d, r28	; 61
    2a64:	09 94       	ijmp

00002a66 <__epilogue_restores__>:
    2a66:	2a 88       	ldd	r2, Y+18	; 0x12
    2a68:	39 88       	ldd	r3, Y+17	; 0x11
    2a6a:	48 88       	ldd	r4, Y+16	; 0x10
    2a6c:	5f 84       	ldd	r5, Y+15	; 0x0f
    2a6e:	6e 84       	ldd	r6, Y+14	; 0x0e
    2a70:	7d 84       	ldd	r7, Y+13	; 0x0d
    2a72:	8c 84       	ldd	r8, Y+12	; 0x0c
    2a74:	9b 84       	ldd	r9, Y+11	; 0x0b
    2a76:	aa 84       	ldd	r10, Y+10	; 0x0a
    2a78:	b9 84       	ldd	r11, Y+9	; 0x09
    2a7a:	c8 84       	ldd	r12, Y+8	; 0x08
    2a7c:	df 80       	ldd	r13, Y+7	; 0x07
    2a7e:	ee 80       	ldd	r14, Y+6	; 0x06
    2a80:	fd 80       	ldd	r15, Y+5	; 0x05
    2a82:	0c 81       	ldd	r16, Y+4	; 0x04
    2a84:	1b 81       	ldd	r17, Y+3	; 0x03
    2a86:	aa 81       	ldd	r26, Y+2	; 0x02
    2a88:	b9 81       	ldd	r27, Y+1	; 0x01
    2a8a:	ce 0f       	add	r28, r30
    2a8c:	d1 1d       	adc	r29, r1
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	de bf       	out	0x3e, r29	; 62
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	cd bf       	out	0x3d, r28	; 61
    2a98:	ed 01       	movw	r28, r26
    2a9a:	08 95       	ret

00002a9c <_exit>:
    2a9c:	f8 94       	cli

00002a9e <__stop_program>:
    2a9e:	ff cf       	rjmp	.-2      	; 0x2a9e <__stop_program>
