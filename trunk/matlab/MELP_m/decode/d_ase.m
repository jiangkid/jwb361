function [f,state_ase,state_tilt]=d_ase(e,lpcs,G,Gn,u,T,state_ase,state_tilt) 
% адаптивная спектральная коррекция
% ВХОДНЫЕ ПЕРЕМЕННЫЕ:
%   e         - входной сигнал
%   lpcs      - коэффициенты линейного предсказания
%   G         - значение усиления
%   Gn        - оценка уровня шума
%   u         - коээфициент отражения №1
%   T         - значение задержки ОТ
%   state_ase - начальное состояние корректирующего фильтра
%   state_tilt- начальное значение аддитивной составляющей
% ВЫХОДНЫЕ ПЕРЕМЕННЫЕ:
%   f         - выходной сигнал
%   state_ase - конечное состояние корректирующего фильтра
%   state_tilt- конечное значение аддитивной составляющей

ppp=(G-Gn-12)/18; %вероятность p 
% граничные условия вероятности
if ppp<0 
    ppp=0;
    elseif ppp>1
        ppp=1;
end
% Расчет коэффициентов корректирующего фильтра
a=0.5*ppp.^(1:10); 
b=0.8*ppp; 
a=[1,a]; 
b=b.^(1:10); 
a=a.*[1,lpcs];  
b=b.*lpcs;     
a=fliplr(a)';   % получение параметров числителя
b=fliplr(b)';   % получение параметров знаменателя
        
% коррекция коэффициента отражения
u=ppp*u; 
% фильтрация сигнала возбуждения в адаптивном корректирующем фильтре
buffer=state_ase; 
for i=1:T
    buffer(i+10)=e(i)-buffer(i:i+9)*b; 
    buffer(i)=buffer(i:i+10)*a; 
    f(i)=buffer(i)+u*state_tilt; % добавление аддитивной составляющей
    state_tilt=buffer(i); 
end 
state_ase=buffer(T+1:T+10);